<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HippoCamp - {{ dataset_name }}</title>
    <script src="/static/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;500;700&family=Ubuntu+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #0f0c29;
            --bg-gradient-mid: #302b63;
            --bg-gradient-end: #24243e;
            --bg-card: rgba(255, 255, 255, 0.05);
            --bg-card-hover: rgba(255, 255, 255, 0.1);
            --bg-glass: rgba(255, 255, 255, 0.08);
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --text-muted: rgba(255, 255, 255, 0.5);
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --accent-tertiary: #a855f7;
            --accent-green: #10b981;
            --accent-red: #ef4444;
            --accent-yellow: #f59e0b;
            --accent-cyan: #06b6d4;
            --accent-pink: #ec4899;
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow-glow: 0 0 40px rgba(99, 102, 241, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.3);
            --nautilus-icon-size: 40px;
        }


        body[data-dataset*="victoria"] {
            --bg-gradient-start: #0b1b2b;
            --bg-gradient-mid: #13406a;
            --bg-gradient-end: #0f2c4a;
            --accent-primary: #38bdf8;
            --accent-secondary: #22d3ee;
            --accent-tertiary: #0ea5e9;
            --shadow-glow: 0 0 40px rgba(56, 189, 248, 0.35);
        }

        body[data-dataset*="adam"] {
            --bg-gradient-start: #2a0b1e;
            --bg-gradient-mid: #5a1236;
            --bg-gradient-end: #3a0f26;
            --accent-primary: #f97316;
            --accent-secondary: #fb7185;
            --accent-tertiary: #f43f5e;
            --shadow-glow: 0 0 40px rgba(249, 115, 22, 0.35);
        }

        body[data-dataset*="bei"] {
            --bg-gradient-start: #0b2a1a;
            --bg-gradient-mid: #14532d;
            --bg-gradient-end: #0f3a22;
            --accent-primary: #34d399;
            --accent-secondary: #22c55e;
            --accent-tertiary: #10b981;
            --shadow-glow: 0 0 40px rgba(52, 211, 153, 0.35);
        }


        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
            background-attachment: fixed;
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(6, 182, 212, 0.1) 0%, transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        /* Layout */
        .container {
            display: flex;
            height: 100vh;
            position: absolute;
            z-index: 1;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            min-width: 200px;
            max-width: 600px;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            position: absolute;
        }

        /* Resize handles */
        .resize-handle {
            position: absolute;
            z-index: 120;
            opacity: 0.85;
            background: linear-gradient(to bottom, rgba(143, 149, 167, 0.36), rgba(143, 149, 167, 0.2));
            transition: background 0.18s ease, opacity 0.18s ease;
        }

        .resize-handle:hover,
        .resize-handle.active {
            background: linear-gradient(to bottom, rgba(249, 115, 22, 0.9), rgba(251, 146, 60, 0.9));
            opacity: 1;
        }

        .resize-handle-right {
            right: -5px;
            top: 8px;
            width: 10px;
            height: calc(100% - 16px);
            border-radius: 8px;
            cursor: ew-resize;
        }

        .resize-handle-left {
            left: -5px;
            top: 8px;
            width: 10px;
            height: calc(100% - 16px);
            border-radius: 8px;
            cursor: ew-resize;
        }

        .sidebar-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .logo-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-tertiary) 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            box-shadow: var(--shadow-glow);
        }

        .logo h1 {
            font-size: 22px;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.8) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .dataset-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .dataset-badge::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 12px 0;
        }

        .file-tree::-webkit-scrollbar {
            width: 6px;
        }

        .file-tree::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .file-tree::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .tree-item {
            padding: 10px 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .tree-item:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
        }

        .tree-item.selected {
            background: linear-gradient(90deg, rgba(99, 102, 241, 0.3) 0%, transparent 100%);
            color: var(--text-primary);
            border-left-color: var(--accent-primary);
        }

        .tree-item.highlighted {
            background: linear-gradient(90deg, rgba(6, 182, 212, 0.3) 0%, transparent 100%);
            color: var(--accent-cyan);
            border-left-color: var(--accent-cyan);
        }

        .tree-item .icon {
            width: 20px;
            text-align: center;
            font-size: 14px;
        }

        .tree-item.directory .icon::before { content: '\1F4C1'; }
        .tree-item.directory.open .icon::before { content: '\1F4C2'; }
        .tree-item.file .icon::before { content: '\1F4C4'; }

        .tree-item[data-ext=".pdf"] .icon::before { content: '\1F4D5'; }
        .tree-item[data-ext=".docx"] .icon::before,
        .tree-item[data-ext=".doc"] .icon::before { content: '\1F4D8'; }
        .tree-item[data-ext=".xlsx"] .icon::before,
        .tree-item[data-ext=".xls"] .icon::before { content: '\1F4D7'; }
        .tree-item[data-ext=".pptx"] .icon::before,
        .tree-item[data-ext=".ppt"] .icon::before { content: '\1F4D9'; }
        .tree-item[data-ext=".png"] .icon::before,
        .tree-item[data-ext=".jpg"] .icon::before,
        .tree-item[data-ext=".jpeg"] .icon::before,
        .tree-item[data-ext=".gif"] .icon::before { content: '\1F5BC'; }
        .tree-item[data-ext=".mp3"] .icon::before,
        .tree-item[data-ext=".wav"] .icon::before { content: '\1F3B5'; }
        .tree-item[data-ext=".mp4"] .icon::before,
        .tree-item[data-ext=".mov"] .icon::before { content: '\1F3AC'; }
        .tree-item[data-ext=".py"] .icon::before { content: '\1F40D'; }
        .tree-item[data-ext=".json"] .icon::before { content: '\2699'; }
        .tree-item[data-ext=".csv"] .icon::before { content: '\1F4CA'; }
        .tree-item[data-ext=".eml"] .icon::before { content: '\1F4E7'; }
        .tree-item[data-ext=".ics"] .icon::before { content: '\1F4C5'; }

        .tree-children {
            margin-left: 20px;
            display: none;
        }

        .tree-children.expanded {
            display: block;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            padding: 16px 24px;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .toolbar-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 10px;
            background: var(--bg-card);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-color);
        }

        .toolbar-btn:hover {
            background: var(--bg-card-hover);
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .toolbar-btn.api-btn {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.3) 0%, rgba(139, 92, 246, 0.3) 100%);
            border-color: rgba(99, 102, 241, 0.5);
        }

        .toolbar-btn.api-btn:hover {
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            border-color: transparent;
            box-shadow: var(--shadow-glow);
        }

        .breadcrumb {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--bg-card);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }

        .breadcrumb-icon {
            color: var(--accent-cyan);
        }

        .breadcrumb span {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .breadcrumb .path {
            color: var(--accent-cyan);
            font-weight: 500;
        }

        /* Content Area */
        .content-area {
            flex: 1;
            display: flex;
            overflow: hidden;
            padding: 20px;
            gap: 20px;
        }

        /* Preview Panel */
        .preview-panel {
            flex: 1;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
        }

        .preview-header h2 {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-header h2::before {
            content: '';
            width: 10px;
            height: 10px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border-radius: 3px;
        }

        .preview-tabs {
            display: flex;
            gap: 6px;
        }

        .preview-tab {
            padding: 8px 14px;
            border-radius: 8px;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .preview-tab:hover {
            background: var(--bg-card);
            color: var(--text-secondary);
        }

        .preview-tab.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            border-color: transparent;
        }

        .preview-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .preview-body::-webkit-scrollbar {
            width: 6px;
        }

        .preview-body::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .preview-content {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            min-height: 200px;
        }

        .preview-content img {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: var(--shadow-card);
        }

        .image-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .image-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0 16px 0;
            color: var(--text-muted);
            font-size: 12px;
        }

        .image-controls input[type="range"] {
            width: 160px;
        }

        .image-controls button {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
        }

        .zoomed-image {
            transform-origin: top left;
            transition: transform 0.15s ease;
        }

        .preview-content pre {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-break: break-word;
            color: var(--text-secondary);
        }

        .json-viewer {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .json-key { color: var(--accent-pink); }
        .json-string { color: var(--accent-green); }
        .json-number { color: var(--accent-yellow); }
        .json-boolean { color: var(--accent-cyan); }

        /* Metadata */
        .metadata-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .metadata-card {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
        }

        .metadata-card .label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .metadata-card .value {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Terminal Panel */
        .terminal-panel {
            width: 380px;
            min-width: 280px;
            max-width: 700px;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .terminal-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(6, 182, 212, 0.2) 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent-green);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .terminal-header h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent-green);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-green);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 10px var(--accent-green); }
            50% { box-shadow: 0 0 20px var(--accent-green), 0 0 30px var(--accent-green); }
        }

        .sync-badge {
            font-size: 10px;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: var(--text-muted);
        }

        .terminal-output {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            line-height: 1.6;
        }

        .terminal-output::-webkit-scrollbar {
            width: 6px;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .terminal-line {
            margin-bottom: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border-left: 3px solid var(--accent-primary);
        }

        .terminal-line.from-terminal {
            border-left-color: var(--accent-green);
        }

        .terminal-line-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .terminal-line .time {
            color: var(--text-muted);
            font-size: 10px;
        }

        .terminal-line .source {
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .terminal-line .source.terminal {
            background: linear-gradient(135deg, var(--accent-green), #059669);
            color: white;
        }

        .terminal-line .source.webui {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
        }

        .terminal-line .command {
            color: var(--accent-yellow);
            font-weight: 500;
        }

        .terminal-line .result {
            color: var(--text-muted);
            font-size: 11px;
            margin-top: 6px;
            padding-left: 12px;
            border-left: 2px solid var(--border-color);
        }

        .terminal-line .result.error {
            color: var(--accent-red);
            border-left-color: var(--accent-red);
        }

        .terminal-line .bash-output {
            color: var(--text-secondary);
            font-size: 11px;
            margin-top: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            white-space: pre-wrap;
            word-break: break-word;
            max-height: 150px;
            overflow-y: auto;
        }

        .terminal-line .bash-output.error {
            color: var(--accent-red);
            background: rgba(239, 68, 68, 0.1);
        }

        .terminal-input {
            padding: 16px;
            border-top: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
        }

        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 4px;
            border: 1px solid var(--border-color);
            transition: all 0.3s;
        }

        .input-wrapper:focus-within {
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        .input-prefix {
            padding: 8px 12px;
            color: var(--accent-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .terminal-input input {
            flex: 1;
            padding: 10px 0;
            border: none;
            background: transparent;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .terminal-input input:focus {
            outline: none;
        }

        .terminal-input input::placeholder {
            color: var(--text-muted);
        }

        .terminal-input button {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--accent-green), #059669);
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s;
        }

        .terminal-input button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        /* Status Bar */
        .status-bar {
            padding: 10px 24px;
            background: var(--bg-glass);
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
        }

        .status-dot.disconnected {
            background: var(--accent-red);
            box-shadow: 0 0 8px var(--accent-red);
        }

        /* Welcome Screen */
        .welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            text-align: center;
            padding: 40px;
        }

        .welcome-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            margin-bottom: 24px;
            box-shadow: var(--shadow-glow);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .welcome h2 {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #fff 0%, rgba(255,255,255,0.7) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .welcome p {
            color: var(--text-muted);
            margin-bottom: 32px;
            font-size: 15px;
        }

        .api-cards {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .api-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 24px;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }

        .api-card:hover {
            background: var(--bg-card-hover);
            transform: translateY(-4px);
            box-shadow: var(--shadow-card);
            border-color: var(--accent-primary);
        }

        .api-card-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            margin-bottom: 16px;
        }

        .api-card:nth-child(1) .api-card-icon {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.3), rgba(6, 182, 212, 0.3));
        }

        .api-card:nth-child(2) .api-card-icon {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.3), rgba(139, 92, 246, 0.3));
        }

        .api-card:nth-child(3) .api-card-icon {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.3), rgba(239, 68, 68, 0.3));
        }

        .api-card h4 {
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 15px;
            font-weight: 600;
        }

        .api-card p {
            font-size: 12px;
            color: var(--text-muted);
            margin: 0;
            line-height: 1.5;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: var(--text-muted);
            gap: 12px;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-color);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            right: 420px;
            padding: 14px 24px;
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 13px;
            display: none;
            z-index: 1000;
            animation: slideIn 0.3s ease;
            box-shadow: var(--shadow-card);
        }

        .toast.show {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toast.success {
            border-color: var(--accent-green);
        }

        .toast.success::before {
            content: '\2713';
            color: var(--accent-green);
            font-weight: bold;
        }

        .toast.error {
            border-color: var(--accent-red);
        }

        .toast.error::before {
            content: '\2717';
            color: var(--accent-red);
            font-weight: bold;
        }

        .toast.info {
            border-color: var(--accent-cyan);
        }

        .toast.info::before {
            content: '\2139';
            color: var(--accent-cyan);
            font-weight: bold;
        }

        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Ubuntu desktop theme override */
        :root {
            --ubuntu-topbar-height: 34px;
            --ubuntu-dock-width: 72px;
            --ubuntu-window-bg: rgba(44, 46, 58, 0.84);
            --ubuntu-window-header: rgba(57, 59, 73, 0.92);
            --ubuntu-border: rgba(255, 255, 255, 0.14);
            --ubuntu-shadow: 0 18px 36px rgba(0, 0, 0, 0.38);
        }

        body,
        body[data-dataset*="victoria"],
        body[data-dataset*="adam"],
        body[data-dataset*="bei"] {
            --bg-gradient-start: #2e2147;
            --bg-gradient-mid: #3b2352;
            --bg-gradient-end: #5c2f49;
            --bg-card: rgba(255, 255, 255, 0.08);
            --bg-card-hover: rgba(255, 255, 255, 0.14);
            --bg-glass: var(--ubuntu-window-bg);
            --text-primary: #f8f8f7;
            --text-secondary: rgba(248, 248, 247, 0.86);
            --text-muted: rgba(248, 248, 247, 0.56);
            --accent-primary: #f07f2f;
            --accent-secondary: #dd6138;
            --accent-tertiary: #f4a259;
            --accent-green: #4fc16d;
            --accent-red: #e05a5a;
            --accent-yellow: #f6be49;
            --accent-cyan: #67c6dd;
            --accent-pink: #f18ec6;
            --border-color: var(--ubuntu-border);
            --shadow-card: var(--ubuntu-shadow);
            --shadow-glow: 0 0 18px rgba(240, 127, 47, 0.34);
        }

        body {
            font-family: 'Ubuntu', 'Noto Sans', sans-serif;
            background:
                radial-gradient(1200px 620px at 15% 18%, rgba(255, 205, 148, 0.16), transparent 66%),
                radial-gradient(980px 540px at 82% 22%, rgba(255, 174, 104, 0.11), transparent 70%),
                linear-gradient(134deg, #2d1e46 0%, #4f2855 48%, #6d3248 100%);
        }

        body::before {
            background:
                radial-gradient(circle at 22% 74%, rgba(255, 183, 117, 0.12) 0%, transparent 50%),
                radial-gradient(circle at 85% 24%, rgba(255, 197, 123, 0.1) 0%, transparent 46%),
                linear-gradient(180deg, rgba(0, 0, 0, 0.08), rgba(0, 0, 0, 0.16));
        }

        body::after {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            background: radial-gradient(70% 80% at 50% 110%, rgba(0, 0, 0, 0.35), transparent 70%);
        }

        .ubuntu-topbar {
            height: var(--ubuntu-topbar-height);
            width: 100%;
            position: relative;
            z-index: 3;
            background: rgba(22, 23, 29, 0.78);
            border-bottom: 1px solid rgba(255, 255, 255, 0.11);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px 0 16px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
        }

        .ubuntu-topbar-left,
        .ubuntu-topbar-center,
        .ubuntu-topbar-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .ubuntu-topbar-center {
            color: rgba(255, 255, 255, 0.94);
            font-weight: 500;
        }

        .ubuntu-dock {
            position: fixed;
            z-index: 2;
            top: calc(var(--ubuntu-topbar-height) + 12px);
            left: 12px;
            bottom: 14px;
            width: var(--ubuntu-dock-width);
            border-radius: 20px;
            background: rgba(28, 29, 37, 0.68);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 18px 34px rgba(0, 0, 0, 0.42);
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
        }

        .ubuntu-dock-icon {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 21px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.88);
        }

        .ubuntu-dock-icon.active {
            background: rgba(240, 127, 47, 0.26);
            border-color: rgba(240, 127, 47, 0.56);
            box-shadow: 0 0 0 2px rgba(240, 127, 47, 0.22);
        }

        .container {
            height: calc(100vh - var(--ubuntu-topbar-height));
            margin-left: var(--ubuntu-dock-width);
            padding: 14px 14px 14px 8px;
            gap: 12px;
            z-index: 1;
        }

        .sidebar,
        .preview-panel,
        .terminal-panel {
            border-radius: 12px;
            border: 1px solid var(--ubuntu-border);
            box-shadow: var(--ubuntu-shadow);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            background: var(--ubuntu-window-bg);
        }

        .sidebar {
            border-right: 1px solid var(--ubuntu-border);
            overflow: hidden;
        }

        .sidebar-header,
        .toolbar,
        .terminal-header,
        .status-bar,
        .preview-header {
            background: var(--ubuntu-window-header);
            border-color: var(--ubuntu-border);
        }

        .logo-icon {
            border-radius: 12px;
            background: linear-gradient(150deg, #f58d3d 0%, #dc5f3a 100%);
            box-shadow: none;
        }

        .logo h1 {
            background: none;
            -webkit-text-fill-color: #ffffff;
            color: #ffffff;
            font-size: 20px;
        }

        .dataset-badge {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 999px;
        }

        .toolbar {
            border-radius: 12px;
            margin-bottom: 10px;
        }

        .toolbar-btn.api-btn {
            background: linear-gradient(138deg, rgba(240, 127, 47, 0.28) 0%, rgba(221, 97, 56, 0.28) 100%);
            border-color: rgba(240, 127, 47, 0.5);
        }

        .toolbar-btn.api-btn:hover {
            background: linear-gradient(138deg, #f58d3d 0%, #dd6138 100%);
        }

        .main-content {
            gap: 10px;
        }

        .content-area {
            padding: 0;
            gap: 12px;
        }

        .preview-panel,
        .terminal-panel {
            overflow: hidden;
        }

        .preview-header {
            min-height: 52px;
        }

        .preview-header h2::before {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: #f58d3d;
        }

        .preview-header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-source-badge {
            font-size: 11px;
            padding: 4px 10px;
            border-radius: 999px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.16);
        }

        .preview-close-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.85);
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .preview-close-btn:hover {
            background: rgba(224, 90, 90, 0.34);
            border-color: rgba(224, 90, 90, 0.64);
            color: #fff;
        }

        .terminal-header {
            background: linear-gradient(132deg, rgba(52, 68, 43, 0.7), rgba(43, 56, 66, 0.72));
        }

        .terminal-line {
            border-radius: 8px;
            border-left-width: 4px;
        }

        .terminal-output {
            font-family: 'Ubuntu Mono', monospace;
        }

        .input-prefix,
        .terminal-input input,
        .preview-content pre,
        .json-viewer {
            font-family: 'Ubuntu Mono', monospace;
        }

        .status-bar {
            border-radius: 12px;
        }

        .toast {
            right: 24px;
            bottom: 20px;
            background: rgba(41, 43, 54, 0.9);
        }

        .welcome-icon {
            background: linear-gradient(150deg, #f58d3d 0%, #dd6138 100%);
            box-shadow: none;
        }

        /* Ubuntu fidelity pass */
        :root {
            --ubuntu-topbar-height: 31px;
            --ubuntu-dock-width: 66px;
        }

        body,
        body[data-dataset*="victoria"],
        body[data-dataset*="adam"],
        body[data-dataset*="bei"] {
            --bg-gradient-start: #300a49;
            --bg-gradient-mid: #5e2750;
            --bg-gradient-end: #772953;
            --ubuntu-window-bg: rgba(31, 33, 41, 0.92);
            --ubuntu-window-header: rgba(43, 45, 54, 0.95);
            --ubuntu-border: rgba(255, 255, 255, 0.12);
        }

        body {
            background:
                radial-gradient(60% 90% at 80% 120%, rgba(255, 220, 170, 0.12), transparent 70%),
                linear-gradient(140deg, #2d082c 0%, #511f4d 38%, #7d2f68 100%);
        }

        .ubuntu-topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 80;
            background: rgba(12, 13, 16, 0.94);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            font-size: 14px;
        }

        .ubuntu-dock {
            top: var(--ubuntu-topbar-height);
            left: 0;
            bottom: 0;
            width: var(--ubuntu-dock-width);
            border-radius: 0;
            border: none;
            border-right: 1px solid rgba(255, 255, 255, 0.08);
            background: linear-gradient(180deg, rgba(14, 15, 19, 0.98), rgba(20, 22, 28, 0.95));
            box-shadow: none;
            padding-top: 10px;
        }

        .ubuntu-dock-icon {
            border-radius: 14px;
            width: 46px;
            height: 46px;
            font-size: 22px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.11);
        }

        .ubuntu-dock-icon.active {
            background: rgba(255, 255, 255, 0.18);
            border-color: rgba(255, 255, 255, 0.24);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.08);
        }

        .container {
            margin-top: var(--ubuntu-topbar-height);
            margin-left: var(--ubuntu-dock-width);
            height: calc(100vh - var(--ubuntu-topbar-height));
            padding: 18px 22px;
            gap: 0;
            align-items: stretch;
        }

        .sidebar {
            width: 255px;
            min-width: 220px;
            max-width: 440px;
            border-radius: 14px 0 0 14px;
            border-right: 1px solid rgba(255, 255, 255, 0.06);
            background: rgba(60, 62, 68, 0.9);
            box-shadow: 0 24px 44px rgba(0, 0, 0, 0.38);
        }

        .main-content {
            border-radius: 0 14px 14px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left: none;
            background: rgba(28, 30, 39, 0.92);
            box-shadow: 0 24px 44px rgba(0, 0, 0, 0.35);
        }

        .nautilus-titlebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .window-controls {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            min-width: 54px;
        }

        .win-dot {
            width: 11px;
            height: 11px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.35);
        }

        .dot-close { background: #e95420; }
        .dot-min { background: #f5c451; }
        .dot-max { background: #4fc16d; }

        .nautilus-title {
            font-size: 16px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.96);
            flex: 1;
            text-align: center;
            margin-right: 30px;
        }

        .nautilus-actions {
            width: 30px;
            text-align: right;
            color: rgba(255, 255, 255, 0.7);
        }

        .nautilus-pathbar {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 7px 10px;
            border-radius: 8px;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.88);
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.13);
        }

        .sidebar-header {
            padding: 12px 12px 10px;
            background: rgba(47, 49, 57, 0.9);
        }

        .places-list {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.07);
        }

        .place-item {
            padding: 7px 10px;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.86);
            font-size: 13px;
            margin-bottom: 2px;
        }

        .place-item.active {
            background: rgba(255, 255, 255, 0.17);
        }

        .place-item.muted {
            color: rgba(255, 255, 255, 0.58);
        }

        .place-sep {
            height: 1px;
            margin: 8px 6px;
            background: rgba(255, 255, 255, 0.1);
        }

        .sidebar-section-title {
            padding: 8px 14px 4px;
            color: rgba(255, 255, 255, 0.62);
            font-size: 11px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .sidebar-search-row {
            padding: 4px 10px 10px;
            display: flex;
            gap: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .sidebar-search-row input {
            flex: 1;
            background: rgba(0, 0, 0, 0.24);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 7px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            padding: 6px 8px;
        }

        .sidebar-search-row input:focus {
            outline: none;
            border-color: rgba(233, 84, 32, 0.8);
            box-shadow: 0 0 0 2px rgba(233, 84, 32, 0.18);
        }

        .sidebar-search-row button {
            width: 26px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.76);
            cursor: pointer;
        }

        .file-tree-wrap {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            padding-top: 4px;
        }

        .file-tree {
            padding: 6px 0 12px;
            height: 100%;
        }

        .tree-item {
            border-left: none;
            border-radius: 8px;
            margin: 0 8px 2px;
            padding: 8px 10px;
            gap: 8px;
        }

        .tree-item.selected {
            background: rgba(255, 255, 255, 0.19);
            border-left: none;
        }

        .tree-item.highlighted {
            background: rgba(233, 84, 32, 0.28);
            color: rgba(255, 255, 255, 0.95);
            border-left: none;
        }

        .toolbar {
            background: rgba(45, 47, 56, 0.96);
            border-radius: 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 0;
            padding: 10px 14px;
            gap: 8px;
        }

        .toolbar-btn {
            padding: 7px 10px;
            border-radius: 8px;
            font-size: 12px;
            transform: none !important;
            box-shadow: none !important;
        }

        .toolbar-btn.api-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.18);
        }

        .toolbar-btn.api-btn:hover {
            background: rgba(233, 84, 32, 0.72);
            border-color: rgba(233, 84, 32, 0.84);
        }

        .breadcrumb {
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .content-area {
            gap: 18px;
            padding: 16px;
            align-items: stretch;
        }

        .preview-panel {
            background: rgba(30, 31, 38, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .preview-header {
            background: rgba(45, 47, 56, 0.96);
        }

        .preview-body {
            background: rgba(30, 31, 38, 0.92);
        }

        .preview-content {
            background: transparent;
            padding: 12px;
        }

        .terminal-panel {
            width: 52%;
            min-width: 420px;
            max-width: 920px;
            background: rgba(35, 35, 39, 0.96);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            box-shadow: 0 26px 46px rgba(0, 0, 0, 0.42);
        }

        .terminal-header {
            padding: 10px 12px;
            background: rgba(36, 37, 43, 0.98);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terminal-title {
            flex: 1;
            text-align: center;
            color: rgba(255, 255, 255, 0.95);
            font-size: 18px;
            font-weight: 700;
        }

        .sync-badge {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: rgba(255, 255, 255, 0.78);
        }

        .terminal-output {
            background: #300a24;
            color: #f5f5f5;
            font-size: 15px;
            line-height: 1.45;
            padding: 10px 12px;
        }

        .terminal-line {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            margin-bottom: 10px;
        }

        .terminal-line-header {
            display: none;
        }

        .terminal-line .command {
            display: block;
            color: #8ae234;
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 3px;
            font-family: 'Ubuntu Mono', monospace;
        }

        .terminal-line .result {
            padding-left: 0;
            border-left: none;
            color: rgba(245, 245, 245, 0.9);
            font-size: 14px;
        }

        .terminal-line .result.error {
            color: #ff9ea4;
        }

        .terminal-line .bash-output {
            background: transparent;
            color: rgba(245, 245, 245, 0.94);
            border-radius: 0;
            padding: 0;
            max-height: none;
        }

        .terminal-line .bash-output.error {
            background: transparent;
            color: #ff9ea4;
        }

        .terminal-input {
            background: #300a24;
            border-top: 1px solid rgba(255, 255, 255, 0.16);
            padding: 10px 12px 12px;
        }

        .input-wrapper {
            background: rgba(0, 0, 0, 0.16);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 3px 6px;
        }

        .input-prefix {
            color: #8ae234;
            font-weight: 700;
        }

        .terminal-input input {
            color: #f6f6f6;
            font-size: 14px;
        }

        .terminal-input button {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 7px;
            font-size: 12px;
            padding: 8px 12px;
        }

        .terminal-input button:hover {
            transform: none;
            box-shadow: none;
            background: rgba(233, 84, 32, 0.74);
            border-color: rgba(233, 84, 32, 0.86);
        }

        .status-bar {
            background: rgba(33, 35, 43, 0.92);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .folder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(112px, 1fr));
            gap: 14px 16px;
            margin-top: 8px;
        }

        .folder-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            border-radius: 10px;
            padding: 10px 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .folder-grid-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .folder-grid-item .icon {
            font-size: 38px;
            line-height: 1;
        }

        .folder-grid-item .name {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.88);
            text-align: center;
            word-break: break-word;
        }

        /* Unity-style desktop + folder browser */
        body {
            font-family: 'Ubuntu', sans-serif;
            background: linear-gradient(145deg, #4b1938 0%, #8d2e39 52%, #cb6135 100%);
        }

        body::before {
            background:
                radial-gradient(circle at 16% 12%, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.02) 32%, transparent 58%),
                radial-gradient(circle at 74% 88%, rgba(255, 255, 255, 0.1) 0%, transparent 44%),
                linear-gradient(125deg, rgba(0, 0, 0, 0.2) 0%, transparent 35%, rgba(0, 0, 0, 0.16) 100%);
        }

        .ubuntu-topbar {
            background: rgba(17, 17, 17, 0.88);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        }

        .ubuntu-dock {
            background: linear-gradient(180deg, rgba(43, 27, 38, 0.9) 0%, rgba(28, 19, 29, 0.9) 100%);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 16px;
            width: 62px;
            top: calc(var(--ubuntu-topbar-height) + 10px);
        }

        .ubuntu-dock-icon {
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.09);
        }

        .ubuntu-dock-icon.active {
            box-shadow: inset 4px 0 0 rgba(255, 255, 255, 0.86), 0 10px 18px rgba(0, 0, 0, 0.32);
        }

        .container {
            margin-top: var(--ubuntu-topbar-height);
            margin-left: var(--ubuntu-dock-width);
            height: calc(100vh - var(--ubuntu-topbar-height));
            padding: 16px;
            gap: 14px;
        }

        .sidebar,
        .preview-panel,
        .terminal-panel {
            background: rgba(28, 24, 40, 0.84);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 16px;
            box-shadow: 0 22px 42px rgba(0, 0, 0, 0.36);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .toolbar,
        .terminal-header,
        .sidebar-header {
            background: rgba(58, 58, 68, 0.7);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        }

        .file-tree-hidden {
            display: none;
        }

        .desktop-file-browser {
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 8px 8px 10px;
            overflow: hidden;
        }

        .desktop-browser-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .desktop-browser-head .location {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 700;
            max-width: 170px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .desktop-browser-head .actions {
            display: inline-flex;
            gap: 6px;
        }

        .desktop-browser-head .actions button {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
        }

        .desktop-browser-head .actions button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .desktop-browser-grid {
            flex: 1;
            overflow: auto;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(86px, 1fr));
            gap: 10px;
            align-content: start;
            padding: 4px 2px 8px;
        }

        .desktop-browser-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-height: 86px;
            border-radius: 10px;
            border: 1px solid transparent;
            background: transparent;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            padding: 8px 4px;
        }

        .desktop-browser-item:hover {
            background: rgba(255, 255, 255, 0.11);
            border-color: rgba(255, 255, 255, 0.18);
        }

        .desktop-browser-item .item-icon {
            font-size: 30px;
            line-height: 1;
        }

        .desktop-browser-item .item-name {
            font-size: 11px;
            text-align: center;
            word-break: break-word;
        }

        .desktop-empty {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            padding: 8px 4px;
        }

        .unity-home {
            width: 100%;
            padding: 12px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .unity-dash-window {
            width: min(940px, 100%);
            min-height: 420px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(43, 10, 32, 0.66);
            box-shadow: 0 18px 36px rgba(0, 0, 0, 0.4);
            padding: 14px 14px 18px;
        }

        .unity-dash-search-row {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.38);
            border: 1px solid rgba(255, 255, 255, 0.22);
            border-radius: 9px;
            padding: 7px 11px;
        }

        .unity-dash-search-row .search-icon {
            color: rgba(255, 255, 255, 0.85);
        }

        .unity-dash-search-row input {
            flex: 1;
            border: 0;
            outline: 0;
            background: transparent;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
        }

        .unity-dash-search-row .filter-text {
            color: rgba(255, 255, 255, 0.72);
            font-size: 12px;
        }

        .unity-sections {
            display: grid;
            grid-template-columns: 1fr;
            gap: 14px;
            margin-top: 14px;
        }

        .unity-section-block {
            background: rgba(0, 0, 0, 0.24);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 10px;
            padding: 12px;
        }

        .unity-section-title {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
        }

        .unity-app-grid,
        .unity-file-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(104px, 1fr));
            gap: 10px;
        }

        .unity-app-tile,
        .unity-file-tile {
            border-radius: 9px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.92);
            min-height: 90px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 8px 6px;
        }

        .unity-app-tile span,
        .unity-file-tile .tile-icon {
            font-size: 30px;
            line-height: 1;
        }

        .unity-app-tile small,
        .unity-file-tile .tile-label {
            font-size: 11px;
            text-align: center;
            word-break: break-word;
        }

        .unity-app-tile:hover,
        .unity-file-tile:hover {
            background: rgba(255, 255, 255, 0.14);
            transform: translateY(-1px);
        }

        .unity-empty-note {
            color: rgba(255, 255, 255, 0.62);
            font-size: 12px;
            padding: 10px 4px;
        }

        .toolbar-btn.api-btn,
        #btnReturnMetadata {
            display: none;
        }

        #pageInput {
            display: none;
        }

        .app-file-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 10px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            font-size: 13px;
            color: rgba(255, 255, 255, 0.92);
        }

        .app-file-header .app-name {
            font-weight: 700;
        }

        .app-file-body {
            background: rgba(10, 10, 14, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 10px;
            min-height: 420px;
            overflow: auto;
            padding: 12px;
        }

        .app-file-body pre {
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 13px;
            line-height: 1.55;
            color: rgba(245, 245, 245, 0.94);
            font-family: 'Ubuntu Mono', monospace;
        }

        .app-file-body iframe {
            width: 100%;
            min-height: 66vh;
            border: 0;
            border-radius: 8px;
            background: #fff;
        }

        .app-file-body img {
            max-width: 100%;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }

        .spreadsheet-table {
            border-collapse: collapse;
            width: 100%;
            background: rgba(255, 255, 255, 0.96);
            color: #1f2937;
            font-size: 12px;
        }

        .spreadsheet-table td,
        .spreadsheet-table th {
            border: 1px solid #d1d5db;
            padding: 5px 6px;
            text-align: left;
            vertical-align: top;
        }

        .spreadsheet-table thead td {
            background: #f3f4f6;
            font-weight: 700;
        }

        .sheet-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .sheet-toolbar input {
            flex: 1;
            min-width: 220px;
            border: 1px solid #d3d8e2;
            border-radius: 8px;
            padding: 7px 10px;
            font-size: 12px;
            color: #1f2937;
            background: #ffffff;
        }

        .sheet-toolbar .sheet-stats {
            font-size: 12px;
            color: #4b5563;
            white-space: nowrap;
        }

        .sheet-table-wrap {
            border: 1px solid #d5dbe6;
            border-radius: 10px;
            overflow: auto;
            background: #ffffff;
            max-height: 68vh;
        }

        .spreadsheet-table.sheet-table {
            min-width: max-content;
        }

        .spreadsheet-table.sheet-table thead th {
            position: sticky;
            top: 0;
            z-index: 3;
            background: #eef2f8;
        }

        .spreadsheet-table.sheet-table .sheet-rownum {
            position: sticky;
            left: 0;
            z-index: 2;
            background: #f5f7fc;
            color: #374151;
            text-align: right;
            min-width: 42px;
            font-weight: 700;
        }

        .spreadsheet-table.sheet-table tbody tr.header-row td {
            background: #f8fafc;
            font-weight: 600;
        }

        .audio-viewer {
            background: linear-gradient(160deg, #f8fafc 0%, #eef2ff 100%);
            border: 1px solid #d9dfec;
            border-radius: 12px;
            padding: 14px;
        }

        .audio-head {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .audio-art {
            width: 58px;
            height: 58px;
            border-radius: 12px;
            background: linear-gradient(135deg, #fb923c, #f43f5e);
            color: #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: 700;
        }

        .audio-meta .title {
            font-size: 14px;
            font-weight: 700;
            color: #1f2937;
            line-height: 1.3;
            word-break: break-word;
        }

        .audio-meta .sub {
            font-size: 12px;
            color: #6b7280;
            margin-top: 2px;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .audio-controls button {
            border: 1px solid #d0d7e4;
            background: #ffffff;
            color: #1f2937;
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .audio-time {
            font-size: 12px;
            color: #4b5563;
            min-width: 44px;
            text-align: center;
        }

        .audio-range {
            flex: 1;
            accent-color: #f97316;
        }

        .mail-viewer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mail-headers {
            border: 1px solid #d8dde8;
            border-radius: 10px;
            background: #f8fafc;
            overflow: hidden;
        }

        .mail-header-row {
            display: grid;
            grid-template-columns: 96px 1fr;
            gap: 10px;
            padding: 8px 10px;
            border-bottom: 1px solid #e6ebf5;
            font-size: 12px;
        }

        .mail-header-row:last-child {
            border-bottom: 0;
        }

        .mail-header-row .label {
            color: #4b5563;
            font-weight: 700;
        }

        .mail-header-row .value {
            color: #111827;
            word-break: break-word;
            line-height: 1.45;
        }

        .mail-body-wrap {
            border: 1px solid #d8dde8;
            border-radius: 10px;
            background: #ffffff;
            min-height: 56vh;
            overflow: hidden;
        }

        .mail-body-frame {
            width: 100%;
            min-height: 56vh;
            border: 0;
            background: #ffffff;
        }

        .mail-body-text {
            margin: 0;
            padding: 12px;
            font-size: 13px;
            line-height: 1.55;
            color: #111827;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: 'Ubuntu Mono', monospace;
        }

        .viewer-note {
            margin-top: 8px;
            font-size: 12px;
            color: #6b7280;
        }

        /* GNOME Files style overrides */
        .container {
            margin-top: var(--ubuntu-topbar-height);
            margin-left: var(--ubuntu-dock-width);
            height: calc(100vh - var(--ubuntu-topbar-height));
            padding: 0;
            gap: 0;
            align-items: stretch;
        }

        .sidebar {
            width: 300px;
            background: #f3f3f4;
            border: 1px solid #d8d8da;
            border-radius: 12px;
            color: #1f1f24;
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.18);
        }

        .sidebar.sidebar-collapsed {
            width: 0 !important;
            min-width: 0 !important;
            border: 0 !important;
            margin: 0 !important;
            opacity: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .sidebar.sidebar-collapsed .resize-handle {
            display: none;
        }

        .sidebar-header {
            background: #ececef;
            color: #202229;
        }

        .nautilus-titlebar {
            color: #1f1f24;
        }

        .nautilus-pathbar {
            background: #ffffff;
            color: #2b2d35;
            border: 1px solid #d7d7da;
        }

        .places-list {
            border-bottom: 1px solid #d9d9de;
            color: #2b2d35;
        }

        .place-item {
            color: #2d2f36;
        }

        .place-item.active {
            background: #dfe1e6;
            color: #1f232b;
        }

        .place-item.muted {
            color: #585d68;
        }

        .sidebar-section-title {
            color: #4c515d;
            border-top: 1px solid #dbdde3;
            border-bottom: 1px solid #dbdde3;
        }

        .sidebar-search-row {
            background: #f3f3f4;
        }

        .sidebar-search-row input {
            background: #ffffff;
            color: #2a2d35;
            border: 1px solid #ccd0d7;
        }

        .sidebar-search-row button {
            color: #6a6f79;
            border: 1px solid #ccd0d7;
            background: #ffffff;
        }

        .desktop-file-browser {
            padding: 8px;
            background: #f3f3f4;
        }

        .desktop-browser-head .location {
            color: #4b505b;
        }

        .desktop-browser-head .actions button {
            background: #ffffff;
            border: 1px solid #d0d4dc;
            color: #3b3f48;
        }

        .sidebar-folder-list {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .sidebar-folder-item {
            border: 1px solid transparent;
            border-radius: 8px;
            background: transparent;
            color: #2c2f38;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 8px;
            cursor: pointer;
            text-align: left;
        }

        .sidebar-folder-item:hover {
            background: #e7e9ee;
        }

        .sidebar-folder-item.active {
            background: #dbe0ea;
            border-color: #c4ccd9;
        }

        .sidebar-folder-item .item-icon {
            width: 18px;
            text-align: center;
        }

        .sidebar-folder-item .item-name {
            font-size: 12px;
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sidebar,
        .toolbar {
            display: none !important;
        }

        .main-content {
            border: 0;
            border-radius: 0;
            overflow: visible;
            background: transparent;
            box-shadow: none;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .breadcrumb {
            background: #ffffff;
            border: 1px solid #d3d7df;
            border-radius: 8px;
            color: #2a2e36;
        }

        .preview-tab {
            background: #f2f3f6;
            border: 1px solid #d2d7e0;
            color: #2f333d;
        }

        .preview-tab:hover {
            background: #e7ebf3;
        }

        .content-area {
            gap: 0;
            position: relative;
            overflow: visible;
            padding: 0;
            background: transparent;
            width: 100%;
            height: 100%;
        }

        .desktop-stage {
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
        }

        .desktop-shortcuts {
            position: absolute;
            top: 18px;
            left: 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .desktop-shortcut {
            width: 92px;
            border: 0;
            border-radius: 10px;
            background: transparent;
            color: #f9fafb;
            padding: 8px 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .desktop-shortcut:hover {
            background: rgba(255, 255, 255, 0.16);
        }

        .desktop-shortcut .icon {
            font-size: 40px;
            line-height: 1;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.45);
        }

        .desktop-shortcut .label {
            font-size: 12px;
            line-height: 1.25;
            text-align: center;
            text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
            word-break: break-word;
        }

        .preview-panel {
            border: 1px solid #d9dce4;
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0 18px 34px rgba(0, 0, 0, 0.32);
            min-width: 420px;
            min-height: 320px;
            max-width: none;
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            resize: both;
            transition: box-shadow 0.2s ease;
            top: 70px;
            left: 90px;
            width: min(980px, calc(100% - 180px));
            height: min(700px, calc(100% - 120px));
        }

        .preview-panel.preview-resized {
            flex: 0 0 auto;
        }

        .file-viewer-window {
            top: 120px;
            left: 260px;
            width: min(860px, calc(100% - 260px));
            height: min(620px, calc(100% - 180px));
        }

        .preview-panel.files-hidden {
            display: none !important;
        }

        .preview-panel.files-hidden .resize-handle {
            display: none;
        }

        .preview-body {
            flex: 1;
            min-height: 0;
            background: #ffffff;
        }

        .nautilus-main-window {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 68vh;
            background: #ffffff;
        }

        .nautilus-main-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-bottom: 1px solid #dde0e7;
            background: #f6f7f9;
        }

        .nautilus-main-toolbar .nav-buttons,
        .nautilus-main-toolbar .view-buttons {
            display: flex;
            gap: 6px;
        }

        .nautilus-main-toolbar button {
            border: 1px solid #d1d6de;
            background: #ffffff;
            color: #343844;
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        .nautilus-main-toolbar button:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .nautilus-main-toolbar .path-display {
            flex: 1;
            border: 1px solid #d4d8e0;
            background: #ffffff;
            border-radius: 8px;
            padding: 6px 10px;
            color: #2d313c;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .nautilus-main-grid {
            flex: 1;
            overflow: auto;
            padding: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(calc(var(--nautilus-icon-size) * 2.5), 1fr));
            gap: 16px 14px;
            align-content: start;
            background: #ffffff;
        }

        .nautilus-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            border: 1px solid transparent;
            border-radius: 10px;
            background: transparent;
            color: #2b303a;
            padding: 8px 6px;
            cursor: pointer;
        }

        .nautilus-grid-item:hover {
            background: #eff3fb;
            border-color: #d4d9e6;
        }

        .nautilus-grid-item .icon {
            font-size: var(--nautilus-icon-size);
            line-height: 1;
        }

        .nautilus-grid-item .name {
            font-size: 12px;
            line-height: 1.25;
            text-align: center;
            word-break: break-word;
        }

        .nautilus-empty-note {
            color: #6a7080;
            font-size: 13px;
            grid-column: 1 / -1;
            padding: 8px 4px;
        }

        .preview-header {
            background: #f6f7f9;
            border-bottom: 1px solid #dde1e8;
            color: #2b303a;
            cursor: move;
            user-select: none;
        }

        .preview-header h2 {
            color: #2c313c;
        }

        .preview-source-badge {
            background: #eaedf4;
            color: #404653;
            border: 1px solid #d0d6e2;
        }

        .terminal-panel {
            width: min(760px, calc(100% - 220px));
            min-width: 360px;
            min-height: 280px;
            max-width: none;
            border: 1px solid #c8ccd8;
            background: #2f0a28;
            border-radius: 10px;
            box-shadow: 0 18px 34px rgba(0, 0, 0, 0.35);
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            resize: both;
            transition: box-shadow 0.2s ease;
            top: 130px;
            left: 420px;
            height: min(520px, calc(100% - 170px));
        }

        .terminal-panel.terminal-hidden {
            display: none !important;
        }

        .terminal-panel.terminal-hidden .resize-handle {
            display: none;
        }

        .terminal-header {
            cursor: move;
            user-select: none;
        }

        .window-action-group {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
        }

        .window-action-btn {
            border: 1px solid #cfd6e2;
            background: #ffffff;
            color: #2f3745;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1;
            padding: 5px 8px;
            cursor: pointer;
        }

        .window-action-btn:hover {
            background: #edf2fb;
        }

        .preview-panel.window-maximized,
        .terminal-panel.window-maximized {
            top: 8px !important;
            left: 8px !important;
            width: calc(100% - 16px) !important;
            height: calc(100% - 16px) !important;
            border-radius: 8px;
            resize: none;
        }

        .preview-panel.window-focused,
        .terminal-panel.window-focused {
            box-shadow: 0 24px 44px rgba(0, 0, 0, 0.45);
        }

        .dock-badge {
            position: absolute;
            right: -3px;
            top: -3px;
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            border-radius: 999px;
            background: #22c55e;
            color: #0b0f18;
            font-size: 10px;
            font-weight: 700;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .dock-window-menu {
            position: fixed;
            min-width: 220px;
            max-width: 300px;
            background: rgba(31, 36, 50, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45);
            padding: 8px;
            z-index: 500;
        }

        .dock-window-menu.hidden {
            display: none;
        }

        .dock-window-menu-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            padding: 4px 6px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.14);
            margin-bottom: 6px;
        }

        .dock-window-item {
            display: block;
            width: 100%;
            text-align: left;
            border: 0;
            background: transparent;
            color: rgba(255, 255, 255, 0.95);
            font-size: 12px;
            border-radius: 8px;
            padding: 7px 8px;
            cursor: pointer;
        }

        .dock-window-item:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .resize-handle {
            display: none !important;
        }

        .status-bar {
            display: none;
        }

        .status-item {
            color: #4a4f5c;
        }

        .app-file-header {
            background: #f7f8fa;
            border: 1px solid #d8dce5;
            color: #2d323d;
        }

        .app-file-body {
            background: #ffffff;
            border: 1px solid #d8dde8;
            color: #222834;
        }

        .app-file-body pre {
            color: #212833;
            font-family: 'Ubuntu Mono', monospace;
        }

        /* Final desktop geometry overrides (must be last) */
        .container {
            position: fixed !important;
            top: var(--ubuntu-topbar-height) !important;
            left: var(--ubuntu-dock-width) !important;
            right: 0 !important;
            bottom: 0 !important;
            width: auto !important;
            height: auto !important;
            margin: 0 !important;
            padding: 0 !important;
            display: block !important;
            overflow: visible !important;
        }

        .main-content {
            position: relative !important;
            width: 100% !important;
            height: 100% !important;
            min-width: 0 !important;
            min-height: 0 !important;
            border: 0 !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background: transparent !important;
            overflow: visible !important;
        }

        .content-area {
            position: relative !important;
            display: block !important;
            width: 100% !important;
            height: 100% !important;
            min-width: 0 !important;
            min-height: 0 !important;
            padding: 0 !important;
            gap: 0 !important;
            overflow: visible !important;
            background: transparent !important;
        }

        .desktop-stage {
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .preview-panel,
        .terminal-panel {
            position: absolute !important;
            margin: 0 !important;
        }

        .preview-panel.window-maximized,
        .terminal-panel.window-maximized {
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            border-radius: 0 !important;
        }

        #dockDynamicApps {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .ubuntu-dock-icon {
            position: relative !important;
            overflow: visible !important;
        }

        /* Keep only one real window control set globally */
        .window-controls,
        .win-dot,
        .dot-close,
        .dot-min,
        .dot-max {
            display: none !important;
        }

        /* Agent interaction overlay */
        .agent-cursor-layer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1200;
        }

        .agent-cursor {
            position: fixed;
            left: 0;
            top: 0;
            transform: translate(-9999px, -9999px);
            opacity: 0;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: transform 260ms cubic-bezier(0.2, 0.75, 0.25, 1), opacity 180ms ease;
            will-change: transform;
        }

        .agent-cursor.visible {
            opacity: 1;
        }

        .agent-cursor-arrow {
            width: 16px;
            height: 22px;
            background: #ffffff;
            border: 1px solid rgba(17, 24, 39, 0.9);
            clip-path: polygon(0 0, 0 100%, 40% 78%, 58% 100%, 73% 92%, 58% 69%, 100% 69%);
            transform: rotate(-18deg);
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.42);
        }

        .agent-cursor-label {
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(17, 24, 39, 0.88);
            color: #f9fafb;
            font-size: 11px;
            line-height: 1.2;
            white-space: nowrap;
            max-width: 260px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: none;
        }

        .agent-cursor-label.has-text {
            display: inline-block;
        }

        .agent-ripple {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 999px;
            border: 2px solid rgba(255, 255, 255, 0.92);
            box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.5);
            transform: translate(-50%, -50%) scale(0.8);
            animation: agent-ripple-pop 460ms ease-out forwards;
            pointer-events: none;
        }

        .agent-ripple.double {
            animation-duration: 520ms;
            border-color: rgba(34, 197, 94, 0.95);
        }

        @keyframes agent-ripple-pop {
            0% {
                opacity: 0.95;
                transform: translate(-50%, -50%) scale(0.75);
                box-shadow: 0 0 0 0 rgba(249, 115, 22, 0.55);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(3.3);
                box-shadow: 0 0 0 18px rgba(249, 115, 22, 0);
            }
        }

        .agent-action-banner {
            position: fixed;
            top: calc(var(--ubuntu-topbar-height) + 12px);
            right: 18px;
            z-index: 1201;
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(17, 24, 39, 0.86);
            color: #f9fafb;
            font-size: 12px;
            line-height: 1.3;
            pointer-events: none;
            opacity: 0;
            transform: translateY(-8px);
            transition: opacity 180ms ease, transform 180ms ease;
            max-width: min(42vw, 520px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-action-banner.show {
            opacity: 1;
            transform: translateY(0);
        }

        .viewer-mini-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .viewer-tool-btn {
            border: 1px solid #d0d7e4;
            background: #ffffff;
            color: #1f2937;
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
        }

        .viewer-tool-btn:hover {
            background: #f3f6fb;
            box-shadow: 0 4px 10px rgba(15, 23, 42, 0.14);
        }

        .viewer-tool-btn.control-pressed {
            transform: scale(0.96);
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.22);
        }

        .tree-item.control-pressed,
        .sidebar-folder-item.control-pressed,
        .nautilus-grid-item.control-pressed,
        .desktop-shortcut.control-pressed {
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.28);
            border-radius: 10px;
        }

        .viewer-tool-label {
            font-size: 12px;
            color: #4b5563;
            min-width: 54px;
            text-align: center;
        }

        .viewer-scroll-wrap {
            overflow: auto;
            max-height: 70vh;
            border: 1px solid #d8dde8;
            border-radius: 10px;
            background: #ffffff;
            padding: 8px;
        }

        .media-effect {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(17, 24, 39, 0.84);
            color: #f9fafb;
            font-size: 11px;
            border: 1px solid rgba(255, 255, 255, 0.16);
            opacity: 0;
            transform: translateY(-6px);
            pointer-events: none;
            animation: media-effect-pop 620ms ease-out forwards;
        }

        .auto-read-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.26);
            background: rgba(17, 24, 39, 0.52);
            color: #e5e7eb;
            font-size: 11px;
            line-height: 1;
        }

        .auto-read-indicator::before {
            content: '';
            width: 7px;
            height: 7px;
            border-radius: 999px;
            background: #9ca3af;
        }

        .auto-read-indicator.running::before {
            background: #22c55e;
            box-shadow: 0 0 0 5px rgba(34, 197, 94, 0.25);
        }

        .auto-read-indicator.manual::before {
            background: #f59e0b;
            box-shadow: 0 0 0 5px rgba(245, 158, 11, 0.2);
        }

        .metadata-sheet {
            background: #f8fafc;
            color: #111827;
            border: 1px solid #d6dbe6;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.12);
        }

        .metadata-sheet-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 14px;
            background: linear-gradient(180deg, #eef2f9 0%, #e5ebf5 100%);
            border-bottom: 1px solid #d6dbe6;
            font-size: 12px;
            color: #334155;
            font-weight: 600;
        }

        .metadata-sheet-body {
            display: grid;
            grid-template-columns: minmax(140px, 220px) 1fr;
        }

        .metadata-row {
            display: contents;
        }

        .metadata-label,
        .metadata-value {
            padding: 10px 14px;
            border-bottom: 1px solid #e3e8f1;
            font-size: 13px;
            line-height: 1.45;
        }

        .metadata-label {
            background: #f3f6fb;
            color: #334155;
            font-weight: 600;
            border-right: 1px solid #e3e8f1;
        }

        .metadata-value {
            color: #0f172a;
            word-break: break-word;
        }

        .nautilus-tree-shell {
            margin-top: 12px;
            border-radius: 10px;
            border: 1px solid #d6dde9;
            background: #f8fafd;
            overflow: hidden;
        }

        .nautilus-tree-shell-head {
            padding: 8px 10px;
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            border-bottom: 1px solid #dce3ef;
            background: #eef3fa;
        }

        .nautilus-tree-shell pre {
            margin: 0;
            padding: 10px 12px;
            font-family: 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.42;
            color: #1f2937;
            background: #fdfefe;
            max-height: 68vh;
            overflow: auto;
            white-space: pre;
        }

        .tree-item.drag-source,
        .nautilus-grid-item.drag-source,
        .sidebar-folder-item.drag-source {
            opacity: 0.54;
        }

        .tree-item.drop-target,
        .nautilus-grid-item.drop-target,
        .sidebar-folder-item.drop-target {
            outline: 2px solid rgba(34, 197, 94, 0.7);
            outline-offset: 2px;
        }

        @keyframes media-effect-pop {
            0% {
                opacity: 0;
                transform: translateY(-6px);
            }
            18% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-8px);
            }
        }

        .replay-context-menu {
            position: fixed;
            min-width: 180px;
            background: rgba(28, 30, 39, 0.96);
            border: 1px solid rgba(148, 163, 184, 0.35);
            border-radius: 10px;
            box-shadow: 0 20px 44px rgba(2, 6, 23, 0.52);
            padding: 6px;
            z-index: 2300;
            animation: replay-dialog-pop 0.16s ease-out;
        }

        .replay-context-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            border: 0;
            background: transparent;
            color: #e2e8f0;
            font-size: 12px;
            font-weight: 500;
            padding: 7px 9px;
            border-radius: 7px;
            text-align: left;
            cursor: default;
        }

        .replay-context-item.selected {
            background: rgba(99, 102, 241, 0.45);
            color: #ffffff;
        }

        .replay-drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2350;
            background: rgba(99, 102, 241, 0.92);
            color: #fff;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.01em;
            padding: 6px 10px;
            box-shadow: 0 14px 28px rgba(15, 23, 42, 0.42);
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .replay-inline-dialog {
            position: fixed;
            left: 50%;
            top: 18%;
            transform: translateX(-50%);
            z-index: 2280;
            min-width: 320px;
            max-width: min(88vw, 640px);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(20, 25, 34, 0.95);
            box-shadow: 0 24px 56px rgba(0, 0, 0, 0.5);
            padding: 14px 16px;
            animation: replay-dialog-pop 0.18s ease-out;
        }

        .replay-inline-dialog.error {
            border-color: rgba(239, 68, 68, 0.7);
        }

        .replay-inline-dialog.success {
            border-color: rgba(34, 197, 94, 0.72);
        }

        .replay-inline-dialog .title {
            font-size: 13px;
            font-weight: 700;
            margin-bottom: 6px;
            color: #f8fafc;
        }

        .replay-inline-dialog .body {
            font-size: 12px;
            line-height: 1.45;
            color: rgba(226, 232, 240, 0.92);
            white-space: pre-wrap;
            word-break: break-word;
        }

        .replay-typing-overlay {
            margin-top: 10px;
            font-family: 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #a5b4fc;
            opacity: 0.95;
        }

        @keyframes replay-dialog-pop {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-8px);
            }
            100% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .terminal-panel {
                width: 320px;
            }
        }

        @media (max-width: 980px) {
            .ubuntu-dock {
                display: none;
            }

            .container {
                margin-left: 0;
                padding: 10px;
            }
        }
    </style>
</head>
<body data-dataset="{{ dataset_name }}">
    <div class="ubuntu-topbar">
        <div class="ubuntu-topbar-left">
            <span>Activities</span>
            <span>{{ dataset_name }}</span>
        </div>
        <div class="ubuntu-topbar-center" id="ubuntuClock">--:--</div>
        <div class="ubuntu-topbar-right">
            <span class="auto-read-indicator idle" id="autoReadIndicator">Auto Read: Agent only</span>
            <span>{{ dataset_user }}</span>
            <span>&#x2699;</span>
        </div>
    </div>

    <div class="ubuntu-dock">
        <div class="ubuntu-dock-icon active" id="dockFilesBtn" title="Files" onclick="handleDockFilesClick(event)">&#x1F4C1;</div>
        <div id="dockDynamicApps"></div>
        <div class="ubuntu-dock-icon" id="dockTerminalBtn" title="Terminal" onclick="handleDockTerminalClick(event)">&#x1F5A5;</div>
    </div>

    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="nautilus-titlebar">
                    <div class="window-controls">
                        <span class="win-dot dot-close"></span>
                        <span class="win-dot dot-min"></span>
                        <span class="win-dot dot-max"></span>
                    </div>
                    <div class="nautilus-title">Files</div>
                    <div class="nautilus-actions">&#x1F50D;</div>
                </div>
                <div class="nautilus-pathbar">&#x2302; Home</div>
            </div>
            <div class="places-list">
                <div class="place-item active">&#x1F3E0; Home</div>
                <div class="place-item">&#x1F551; Recent</div>
                <div class="place-item">&#x2606; Starred</div>
                <div class="place-item">&#x1F5A7; Network</div>
                <div class="place-item">&#x1F5D1; Trash</div>
                <div class="place-sep"></div>
                <div class="place-item muted">{{ dataset_name }}</div>
                <div class="place-item muted">{{ dataset_user }}</div>
            </div>
            <div class="sidebar-section-title">Dataset Files</div>
            <div class="sidebar-search-row">
                <input id="sidebarQuickSearch" type="text" placeholder="Search files..." oninput="filterTreeByKeyword(this.value)">
                <button type="button" onclick="document.getElementById('sidebarQuickSearch').value=''; filterTreeByKeyword('');">&#x2715;</button>
            </div>
            <div class="file-tree-wrap">
                <div class="file-tree file-tree-hidden" id="fileTree">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <span>Loading files...</span>
                    </div>
                </div>
                <div class="desktop-file-browser" id="desktopFileBrowser">
                    <div class="loading">
                        <div class="loading-spinner"></div>
                        <span>Loading folders...</span>
                    </div>
                </div>
            </div>
            <!-- Resize handle for sidebar -->
            <div class="resize-handle resize-handle-right" id="sidebarResizeHandle"></div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Toolbar -->
            <div class="toolbar">
                <button class="toolbar-btn api-btn" id="btnReturnTxt" onclick="callAPI('return_txt')" title="Get Gold Text JSON">
                    &#x1F4DC; return_txt
                </button>
                <button class="toolbar-btn api-btn" id="btnReturnImg" onclick="callAPI('return_img')" title="Convert to Image">
                    &#x1F5BC; return_img
                </button>
                <button class="toolbar-btn api-btn" onclick="callAPI('return_ori')" title="Get Original File">
                    &#x1F4CE; return_ori
                </button>
                <button class="toolbar-btn" id="btnReturnMetadata" onclick="callAPI('return_metadata')" title="Get File Metadata">
                    &#x2139; return_metadata
                </button>
                <button class="toolbar-btn" onclick="createFolderPrompt()" title="Create new folder (virtual)">
                    &#x1F4C1; New Folder
                </button>
                <button class="toolbar-btn" onclick="createFilePrompt()" title="Create new file (virtual)">
                    &#x1F4C4; New File
                </button>
                <button class="toolbar-btn" onclick="renameSelectedItemPrompt()" title="Rename selected file/folder">
                    &#x270E; Rename
                </button>
                <button class="toolbar-btn" onclick="deleteSelectedItemPrompt()" title="Delete selected file/folder (virtual)">
                    &#x1F5D1; Delete
                </button>
                <input id="pageInput" type="number" min="1" placeholder="Page" style="width: 70px; margin-left: 8px; background: transparent; border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 8px; padding: 6px 8px; font-size: 12px;">
                <div class="breadcrumb">
                    <span class="breadcrumb-icon">&#x1F4C1;</span>
                    <span id="currentPath">Select a file to view</span>
                    <button class="preview-tab" id="filesToggleBtn" onclick="toggleFilesWindow()" style="margin-left: 10px;">Hide Files</button>
                    <button class="preview-tab" onclick="resizeFilesWindow(-70)" style="margin-left: 10px;">W-</button>
                    <button class="preview-tab" onclick="resizeFilesWindow(70)" style="margin-left: 10px;">W+</button>
                    <button class="preview-tab" id="sidebarToggleBtn" onclick="toggleSidebarPanel()" style="margin-left: 10px;">Hide Sidebar</button>
                    <button class="preview-tab" onclick="resizeSidebarPanel(-40)" style="margin-left: 10px;">F-</button>
                    <button class="preview-tab" onclick="resizeSidebarPanel(40)" style="margin-left: 10px;">F+</button>
                    <button class="preview-tab" onclick="openMainFolder(getParentPath(mainFolderPath))" style="margin-left: 10px;">Up</button>
                    <button class="preview-tab" onclick="goHome()" style="margin-left: 10px;">Home</button>
                    <button class="preview-tab" id="terminalToggleBtn" onclick="toggleTerminalPanel()" style="margin-left: 10px;">Show Terminal</button>
                    <button class="preview-tab" onclick="resizeTerminalPanel(-70)" style="margin-left: 10px;">T-</button>
                    <button class="preview-tab" onclick="resizeTerminalPanel(70)" style="margin-left: 10px;">T+</button>
                </div>
            </div>

            <!-- Content Area -->
            <div class="content-area">
                <div class="desktop-stage" id="desktopStage">
                    <div class="desktop-shortcuts">
                        <button class="desktop-shortcut" type="button" title="Home"
                            ondragover="onFolderDragOver('directory', event)"
                            ondragleave="onFolderDragLeave(event)"
                            ondrop="onFolderDrop('', 'directory', event)"
                            onclick="openDesktopHome()">
                            <span class="icon">&#x1F4C1;</span>
                            <span class="label">Home</span>
                        </button>
                        <button class="desktop-shortcut" type="button" title="Trash" onclick="showToast('Trash is empty', 'info')">
                            <span class="icon">&#x1F5D1;</span>
                            <span class="label">Trash</span>
                        </button>
                    </div>
                </div>

                <!-- Preview Panel -->
                <div class="preview-panel" id="previewPanel" data-window-kind="files">
                    <div class="preview-body">
                        <div class="welcome unity-home" id="unityHomeWelcome"></div>
                    </div>
                    <div class="resize-handle resize-handle-right" id="previewResizeHandle"></div>
                </div>

                <!-- File Viewer Window -->
                <div class="preview-panel files-hidden file-viewer-window" id="fileViewerPanel" data-window-kind="viewer">
                    <div class="preview-body">
                        <div class="preview-content">Select a file to open</div>
                    </div>
                </div>

                <!-- Terminal Panel -->
                <div class="terminal-panel terminal-hidden" id="terminalPanel" data-window-kind="terminal">
                    <!-- Resize handle for terminal -->
                    <div class="resize-handle resize-handle-left" id="terminalResizeHandle"></div>
                    <div class="terminal-header" id="terminalWindowTopbar">
                        <div class="window-controls">
                            <span class="win-dot dot-close"></span>
                            <span class="win-dot dot-min"></span>
                            <span class="win-dot dot-max"></span>
                        </div>
                        <h3 class="terminal-title">hippocamp_user@hippocamp:~</h3>
                        <span class="sync-badge">Terminal</span>
                        <div class="window-action-group">
                            <button class="window-action-btn" type="button" title="Minimize" onclick="minimizeAppWindow('terminal')">&#x2212;</button>
                            <button class="window-action-btn" type="button" title="Maximize / Restore" onclick="toggleMaximizeWindow('terminal')">&#x2610;</button>
                            <button class="window-action-btn" type="button" title="Close" onclick="closeAppWindow('terminal')">&#x2715;</button>
                        </div>
                    </div>
                    <div class="terminal-output" id="terminalOutput">
                        <!-- Commands will appear here -->
                    </div>
                    <div class="terminal-input">
                        <div class="input-wrapper">
                            <span class="input-prefix">$</span>
                            <input type="text" id="commandInput" placeholder="Enter command..." onkeypress="handleKeyPress(event)">
                            <button id="terminalRunButton" onclick="executeCommand()">Run</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Status Bar -->
            <div class="status-bar">
                <div class="status-item">
                    <span id="fileCount">Files: --</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="connectionStatus">Connecting...</span>
                </div>
            </div>
        </div>
    </div>

    <div class="dock-window-menu hidden" id="dockWindowMenu"></div>
    <div class="agent-cursor-layer" id="agentCursorLayer">
        <div class="agent-cursor" id="agentCursor">
            <div class="agent-cursor-arrow"></div>
            <div class="agent-cursor-label" id="agentCursorLabel"></div>
        </div>
    </div>
    <div class="agent-action-banner" id="agentActionBanner"></div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // State
        let enableReturnTxt = {{ 'true' if enable_return_txt else 'false' }};
        let enableReturnImg = {{ 'true' if enable_return_img else 'false' }};
        let flagsInitialized = {{ 'true' if flags_initialized else 'false' }};
        let warnedSetFlags = false;
        let selectedFile = null;
        let selectedItemPath = '';
        let selectedItemType = 'file';
        let socket = null;
        let fileData = [];
        let currentImagePaths = [];
        let currentImageIndex = 0;
        let commandSequence = 0;
        let seenCommandKeys = new Set();
        let historyPollTimer = null;
        let sidebarCurrentPath = '';
        let mainFolderPath = '';
        let terminalVisible = false;
        let sidebarVisible = false;
        let filesWindowVisible = false;
        let fileViewerVisible = false;
        let folderIconSize = 40;
        let lastHistoryTsMs = 0;
        let previewWindowState = {
            isOpen: false,
            source: '',
            operation: '',
            filePath: '',
            windowKind: 'files',
            autoCloseAfterCommand: null
        };
        let uiBootTsMs = Date.now();
        let windowZCounter = 30;
        let activeDrag = null;
        let activeFileDrag = null;
        let agentHideTimer = null;
        let agentBannerTimer = null;
        let terminalUserCustomized = false;
        let autoReadRunning = false;
        let autoReadPatternLabel = '';
        const dynamicWindowState = {};
        const minimizedViewerWindows = {};
        const viewerAppMetaRegistry = {};
        const viewerAutoRunTokens = {};
        const virtualPathMap = {};
        const AGENT_MOTION_SCALE = 3.1;
        let agentAnimChain = Promise.resolve();
        const recentOperationMarks = new Map();
        let replaySessionState = {
            running: false,
            session_id: 0,
            events_path: '',
            speed: 1,
            events_total: 0,
            events_sent: 0
        };
        let replayLastHandledEventType = '';
        const replayClipboard = { path: '', type: 'file' };
        const windowRuntime = {
            files: { initialized: false, maximized: false, restore: null },
            viewer: { initialized: false, maximized: false, restore: null },
            terminal: { initialized: false, maximized: false, restore: null }
        };
        const minimizedWindows = {
            files: [],
            terminal: []
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            startUbuntuClock();
            initSocket();
            loadFiles();
            initResizeHandles();
            initWindowManager();
            initAgentInteractionLayer();
            refreshFeatureFlags();
            restoreLayoutPreferences();
            setAutoReadIndicator('idle', 'Auto Read: Agent only');
            renderWelcomePanel();
        });

        function sleepMs(ms) {
            return new Promise((resolve) => setTimeout(resolve, Math.max(0, Number(ms) || 0)));
        }

        function agentMs(ms) {
            return Math.max(1, Math.round((Number(ms) || 0) * AGENT_MOTION_SCALE));
        }

        function sleepAgent(ms) {
            return sleepMs(agentMs(ms));
        }

        function queueAgentAnimation(task) {
            const runner = async () => {
                try {
                    await task();
                } catch (e) {
                    console.error('[Replay Animation Error]', e);
                    const msg = (e && e.message) ? e.message : String(e || 'unknown error');
                    showToast(`Replay action failed: ${msg}`, 'error');
                }
            };
            agentAnimChain = agentAnimChain.then(runner, runner);
            return agentAnimChain;
        }

        function setAutoReadIndicator(state = 'idle', text = '') {
            const el = document.getElementById('autoReadIndicator');
            if (!el) return;
            el.classList.remove('idle', 'running', 'manual');
            const safeState = state === 'running' || state === 'manual' ? state : 'idle';
            el.classList.add(safeState);
            if (safeState === 'running') {
                const suffix = text ? ` (${text})` : '';
                el.textContent = `Auto Read: Running${suffix}`;
                return;
            }
            if (safeState === 'manual') {
                el.textContent = text || 'Auto Read: Manual mode';
                return;
            }
            el.textContent = text || 'Auto Read: Agent only';
        }

        function normalizeVirtualPath(path) {
            return String(path || '')
                .trim()
                .replace(/^\/hippocamp\/data\/?/, '')
                .replace(/^data\/?/, '')
                .replace(/^\.\/?/, '')
                .replace(/\/$/, '');
        }

        function buildOperationMarkKey(operation, filePath, source = 'agent') {
            const op = String(operation || '').trim().toLowerCase();
            const cleanPath = normalizeVirtualPath(filePath || '');
            const src = String(source || '').trim().toLowerCase();
            return `${src}|${op}|${cleanPath}`;
        }

        function markOperationHandled(operation, filePath, source = 'agent') {
            const key = buildOperationMarkKey(operation, filePath, source);
            if (!key) return;
            recentOperationMarks.set(key, Date.now());
        }

        function wasOperationHandledRecently(operation, filePath, source = 'agent', windowMs = 2400) {
            const key = buildOperationMarkKey(operation, filePath, source);
            if (!key) return false;
            const ts = recentOperationMarks.get(key);
            if (!ts) return false;
            const alive = Date.now() - ts <= Math.max(200, Number(windowMs) || 2400);
            if (!alive) {
                recentOperationMarks.delete(key);
            }
            return alive;
        }

        function resolveActualPath(path) {
            const normalized = normalizeVirtualPath(path);
            return virtualPathMap[normalized] || normalized;
        }

        function rebuildVirtualPathMap(nodes = fileData) {
            Object.keys(virtualPathMap).forEach((k) => delete virtualPathMap[k]);
            const walk = (items) => {
                (items || []).forEach((item) => {
                    const p = normalizeVirtualPath(item.path || item.name || '');
                    if (!p) return;
                    virtualPathMap[p] = p;
                    if (item.type === 'directory') {
                        walk(item.children || []);
                    }
                });
            };
            walk(nodes);
        }

        async function recordUiTmpOp(action, payload = {}) {
            try {
                await apiFetch('/api/ui_ops', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, payload })
                });
            } catch (e) {}
        }

        function getAgentCursor() {
            return document.getElementById('agentCursor');
        }

        function getAgentCursorLabel() {
            return document.getElementById('agentCursorLabel');
        }

        function setAgentCursorLabel(text = '') {
            const label = getAgentCursorLabel();
            if (!label) return;
            const clean = String(text || '').trim();
            label.textContent = clean;
            label.classList.toggle('has-text', !!clean);
        }

        function showAgentActionBanner(text, ttl = 1100) {
            const banner = document.getElementById('agentActionBanner');
            if (!banner) return;
            banner.textContent = String(text || '');
            banner.classList.add('show');
            if (agentBannerTimer) clearTimeout(agentBannerTimer);
            agentBannerTimer = setTimeout(() => {
                banner.classList.remove('show');
            }, Math.max(200, ttl));
        }

        function showAgentCursorAt(x, y, label = '') {
            const cursor = getAgentCursor();
            if (!cursor) return;
            setAgentCursorLabel(label);
            cursor.style.transitionDuration = '0ms';
            cursor.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
            cursor.classList.add('visible');
            if (agentHideTimer) clearTimeout(agentHideTimer);
        }

        function hideAgentCursorLater(delay = 700) {
            const cursor = getAgentCursor();
            if (!cursor) return;
            if (agentHideTimer) clearTimeout(agentHideTimer);
            agentHideTimer = setTimeout(() => {
                cursor.classList.remove('visible');
                setAgentCursorLabel('');
            }, Math.max(120, delay));
        }

        async function moveAgentCursorTo(x, y, options = {}) {
            const cursor = getAgentCursor();
            if (!cursor) return;
            const baseDuration = Math.max(140, Number(options.duration) || 340);
            const duration = agentMs(baseDuration);
            if (options.label !== undefined) {
                setAgentCursorLabel(options.label);
            }
            cursor.style.transitionDuration = `${duration}ms`;
            cursor.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
            cursor.classList.add('visible');
            if (agentHideTimer) clearTimeout(agentHideTimer);
            await sleepMs(duration + 40);
        }

        function emitAgentRippleAt(x, y, doubleClick = false) {
            const layer = document.getElementById('agentCursorLayer');
            if (!layer) return;
            const ripple = document.createElement('div');
            ripple.className = `agent-ripple${doubleClick ? ' double' : ''}`;
            ripple.style.left = `${Math.round(x)}px`;
            ripple.style.top = `${Math.round(y)}px`;
            layer.appendChild(ripple);
            setTimeout(() => ripple.remove(), 700);
        }

        function getElementCenterPoint(el) {
            if (!el) return null;
            const r = el.getBoundingClientRect();
            if (!r || !r.width || !r.height) return null;
            return {
                x: r.left + Math.min(r.width - 8, Math.max(10, r.width * 0.55)),
                y: r.top + Math.min(r.height - 8, Math.max(10, r.height * 0.52))
            };
        }

        async function animateCursorToElement(el, options = {}) {
            if (!el || typeof el.getBoundingClientRect !== 'function') return;
            const point = getElementCenterPoint(el);
            if (!point) return;
            await moveAgentCursorTo(point.x, point.y, {
                duration: options.duration || 520,
                label: options.label || ''
            });
            if (options.click) {
                emitAgentRippleAt(point.x, point.y, !!options.doubleClick);
                el.classList.add('control-pressed');
                setTimeout(() => el.classList.remove('control-pressed'), 220);
                await sleepAgent(220);
                if (options.doubleClick) {
                    emitAgentRippleAt(point.x + 2, point.y + 2, true);
                    await sleepAgent(230);
                }
            }
        }

        function pulseControlEffect(triggerEl, label = '') {
            if (!triggerEl) return;
            const point = getElementCenterPoint(triggerEl);
            if (point) {
                showAgentCursorAt(point.x, point.y, label);
                emitAgentRippleAt(point.x, point.y, false);
                hideAgentCursorLater(480);
            }
            triggerEl.classList.add('control-pressed');
            setTimeout(() => triggerEl.classList.remove('control-pressed'), 220);
        }

        function showMediaEffect(target, text) {
            const root = target?.closest('.app-file-body') || target?.closest('.preview-content') || target;
            if (!root || !root.appendChild) return;
            const bubble = document.createElement('div');
            bubble.className = 'media-effect';
            bubble.textContent = String(text || 'Action');
            root.style.position = root.style.position || 'relative';
            root.appendChild(bubble);
            setTimeout(() => bubble.remove(), 700);
        }

        function cssEscapeValue(value) {
            if (window.CSS && typeof window.CSS.escape === 'function') {
                return window.CSS.escape(String(value));
            }
            return String(value).replace(/["\\]/g, '\\$&');
        }

        function initAgentInteractionLayer() {
            document.addEventListener('pointerdown', (e) => {
                if (e.button !== 0) return;
                const x = e.clientX;
                const y = e.clientY;
                emitAgentRippleAt(x, y, false);
                showAgentCursorAt(x + 6, y + 4, '');
                hideAgentCursorLater(360);
            }, true);

            let lastMoveTs = 0;
            document.addEventListener('pointermove', (e) => {
                const now = Date.now();
                if (now - lastMoveTs < 42) return;
                lastMoveTs = now;
                if (autoReadRunning) return;
                showAgentCursorAt(e.clientX + 4, e.clientY + 4, '');
                hideAgentCursorLater(180);
            }, true);
        }

        function startUbuntuClock() {
            const clockEl = document.getElementById('ubuntuClock');
            if (!clockEl) return;
            const renderClock = () => {
                const now = new Date();
                const options = {
                    weekday: 'short',
                    hour: '2-digit',
                    minute: '2-digit'
                };
                clockEl.textContent = now.toLocaleString(undefined, options);
            };
            renderClock();
            setInterval(renderClock, 60000);
        }

        function getAppWindow(type) {
            if (type === 'files') return document.getElementById('previewPanel');
            if (type === 'viewer') return document.getElementById('fileViewerPanel');
            if (type === 'terminal') return document.getElementById('terminalPanel');
            return null;
        }

        function getAppIcon(type) {
            if (type === 'files' || type === 'viewer') return document.getElementById('dockFilesBtn');
            if (type === 'terminal') return document.getElementById('dockTerminalBtn');
            return null;
        }

        function getWindowAreaRect() {
            const area = document.querySelector('.content-area');
            if (area) {
                const rect = area.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    return rect;
                }
            }
            const topbar = document.querySelector('.ubuntu-topbar');
            const topbarHeight = topbar ? topbar.offsetHeight : 0;
            const dock = document.querySelector('.ubuntu-dock');
            const dockWidth = dock ? dock.offsetWidth : 0;
            return {
                left: dockWidth,
                top: topbarHeight,
                width: Math.max(320, window.innerWidth - dockWidth),
                height: Math.max(240, window.innerHeight - topbarHeight)
            };
        }

        function ensureWindowGeometry(type) {
            const panel = getAppWindow(type);
            const state = windowRuntime[type];
            if (!panel || !state || state.initialized) return;
            const area = getWindowAreaRect();
            if (type === 'files') {
                panel.style.left = `${Math.max(18, Math.round(area.width * 0.08))}px`;
                panel.style.top = `${Math.max(16, Math.round(area.height * 0.08))}px`;
                panel.style.width = `${Math.min(980, Math.max(620, Math.round(area.width * 0.62)))}px`;
                panel.style.height = `${Math.min(720, Math.max(430, Math.round(area.height * 0.72)))}px`;
            } else if (type === 'viewer') {
                panel.style.left = `${Math.max(40, Math.round(area.width * 0.22))}px`;
                panel.style.top = `${Math.max(44, Math.round(area.height * 0.14))}px`;
                panel.style.width = `${Math.min(860, Math.max(520, Math.round(area.width * 0.52)))}px`;
                panel.style.height = `${Math.min(640, Math.max(360, Math.round(area.height * 0.64)))}px`;
            } else {
                panel.style.left = `${Math.max(36, Math.round(area.width * 0.3))}px`;
                panel.style.top = `${Math.max(40, Math.round(area.height * 0.16))}px`;
                panel.style.width = `${Math.min(860, Math.max(500, Math.round(area.width * 0.5)))}px`;
                panel.style.height = `${Math.min(560, Math.max(320, Math.round(area.height * 0.58)))}px`;
            }
            state.initialized = true;
        }

        function applyAgentTerminalLayout(force = false) {
            if (!terminalVisible && !force) return;
            if (terminalUserCustomized && !force) return;
            const panel = getAppWindow('terminal');
            if (!panel) return;
            const area = getWindowAreaRect();
            const width = Math.max(320, Math.min(520, Math.round(area.width * 0.25)));
            const height = Math.max(320, Math.min(area.height - 10, Math.round(area.height * 0.82)));
            panel.classList.remove('window-maximized');
            windowRuntime.terminal.maximized = false;
            panel.style.width = `${width}px`;
            panel.style.height = `${height}px`;
            panel.style.left = `${Math.max(8, area.width - width - 8)}px`;
            panel.style.top = `${Math.max(10, Math.round(area.height * 0.1))}px`;
            panel.style.flex = `0 0 ${width}px`;
        }

        function enforceAgentSingleActiveWindow(kind = 'viewer') {
            const target = String(kind || '').toLowerCase();
            if (target === 'files') {
                setFilesWindowVisible(true);
                setFileViewerVisible(false);
                focusAppWindow('files');
                return;
            }
            if (target === 'viewer') {
                setFileViewerVisible(true);
                setFilesWindowVisible(false);
                focusAppWindow('viewer');
            }
        }

        function focusWindowElement(panel) {
            if (!panel) return;
            document.querySelectorAll('[data-window-kind]').forEach((el) => {
                el.classList.remove('window-focused');
            });
            panel.style.zIndex = String(++windowZCounter);
            panel.classList.add('window-focused');
        }

        function focusAppWindow(type) {
            focusWindowElement(getAppWindow(type));
        }

        function getFilesWindowTitle() {
            const title = document.querySelector('#previewPanel .preview-header h2');
            if (title && title.textContent.trim()) return title.textContent.trim();
            if (previewWindowState.filePath) return previewWindowState.filePath.split('/').pop();
            return 'Home';
        }

        function getViewerWindowTitle() {
            const title = document.querySelector('#fileViewerPanel .preview-header h2');
            if (title && title.textContent.trim()) return title.textContent.trim();
            if (selectedFile) return selectedFile.split('/').pop();
            return 'File';
        }

        function getVisibleDynamicViewerPanels() {
            return Array.from(document.querySelectorAll('[data-window-kind="dynamic-viewer"]'))
                .filter((panel) => !panel.classList.contains('files-hidden'));
        }

        function getVisibleDynamicViewerPanelsByApp(appType) {
            return getVisibleDynamicViewerPanels().filter((panel) => {
                const state = dynamicWindowState[panel.id] || {};
                return String(state.appType || 'generic') === String(appType || 'generic');
            });
        }

        function sanitizeDockAppType(appType) {
            const raw = String(appType || 'generic').toLowerCase();
            const clean = raw.replace(/[^a-z0-9_-]/g, '-');
            return clean || 'generic';
        }

        function normalizeViewerAppMeta(meta) {
            const type = sanitizeDockAppType(meta?.type || 'generic');
            return {
                type,
                name: String(meta?.name || 'Viewer'),
                icon: String(meta?.icon || '&#x1F4C4;')
            };
        }

        function setDockBadge(icon, count) {
            if (!icon) return;
            let badge = icon.querySelector('.dock-badge');
            if (!count || count <= 0) {
                if (badge) badge.remove();
                return;
            }
            if (!badge) {
                badge = document.createElement('span');
                badge.className = 'dock-badge';
                icon.appendChild(badge);
            }
            badge.textContent = String(count);
        }

        function pruneDynamicViewerState() {
            Object.keys(dynamicWindowState).forEach((windowId) => {
                if (!document.getElementById(windowId)) {
                    delete dynamicWindowState[windowId];
                }
            });
            Object.keys(minimizedViewerWindows).forEach((appType) => {
                const entries = (minimizedViewerWindows[appType] || []).filter((entry) => !!document.getElementById(entry.windowId || ''));
                if (entries.length) {
                    minimizedViewerWindows[appType] = entries;
                } else {
                    delete minimizedViewerWindows[appType];
                }
            });
        }

        function getViewerAppUsage() {
            const usage = {};
            Object.entries(dynamicWindowState).forEach(([windowId, state]) => {
                const panel = document.getElementById(windowId);
                if (!panel) return;
                const appType = sanitizeDockAppType(state.appType || 'generic');
                const meta = normalizeViewerAppMeta(state.appMeta || viewerAppMetaRegistry[appType] || {
                    type: appType,
                    name: state.appName || 'Viewer',
                    icon: '&#x1F4C4;'
                });
                viewerAppMetaRegistry[appType] = meta;
                if (!usage[appType]) {
                    usage[appType] = { meta, open: 0, minimized: 0 };
                }
                if (!panel.classList.contains('files-hidden')) {
                    usage[appType].open += 1;
                }
            });

            Object.entries(minimizedViewerWindows).forEach(([appTypeKey, entries]) => {
                const appType = sanitizeDockAppType(appTypeKey);
                const meta = normalizeViewerAppMeta(viewerAppMetaRegistry[appType] || {
                    type: appType,
                    name: 'Viewer',
                    icon: '&#x1F4C4;'
                });
                if (!usage[appType]) {
                    usage[appType] = { meta, open: 0, minimized: 0 };
                }
                usage[appType].minimized += (entries || []).length;
            });
            return usage;
        }

        function ensureViewerDockIcon(appType, meta) {
            const container = document.getElementById('dockDynamicApps');
            if (!container) return null;
            const safeType = sanitizeDockAppType(appType);
            let icon = container.querySelector(`.dock-app-icon[data-app-type="${safeType}"]`);
            if (!icon) {
                icon = document.createElement('div');
                icon.className = 'ubuntu-dock-icon dock-app-icon';
                icon.dataset.appType = safeType;
                icon.addEventListener('click', (event) => handleDockViewerClick(safeType, event));
                container.appendChild(icon);
            }
            icon.innerHTML = meta.icon || '&#x1F4C4;';
            icon.title = meta.name || 'Viewer';
            return icon;
        }

        function focusDynamicWindow(windowId) {
            const panel = document.getElementById(windowId || '');
            if (!panel || panel.classList.contains('files-hidden')) return;
            hideDockWindowMenu();
            focusWindowElement(panel);
        }

        function showViewerDockMenu(appType, anchor) {
            const safeType = sanitizeDockAppType(appType);
            const menu = document.getElementById('dockWindowMenu');
            if (!menu || !anchor) return;

            const visiblePanels = getVisibleDynamicViewerPanelsByApp(safeType)
                .sort((a, b) => parseInt(b.style.zIndex || '0', 10) - parseInt(a.style.zIndex || '0', 10));
            const minimizedEntries = minimizedViewerWindows[safeType] || [];
            if (!visiblePanels.length && !minimizedEntries.length) {
                hideDockWindowMenu();
                return;
            }

            const appMeta = normalizeViewerAppMeta(viewerAppMetaRegistry[safeType] || { type: safeType, name: 'Viewer', icon: '&#x1F4C4;' });
            const openButtons = visiblePanels.map((panel) => {
                const title = panel.querySelector('.preview-header h2')?.textContent?.trim() || dynamicWindowState[panel.id]?.title || 'File';
                return `<button type="button" class="dock-window-item" onclick="focusDynamicWindow('${panel.id}')">&#x25CF; ${escapeHtml(title)}</button>`;
            });
            const minimizedButtons = minimizedEntries.map((entry) => `
                <button type="button" class="dock-window-item" onclick="restoreMinimizedViewerWindow('${safeType}', '${entry.id}')">&#x21B6; ${escapeHtml(entry.title || 'File')}</button>
            `);

            menu.innerHTML = `
                <div class="dock-window-menu-title">${appMeta.icon} ${escapeHtml(appMeta.name)}</div>
                ${openButtons.join('')}
                ${minimizedButtons.join('')}
            `;
            const rect = anchor.getBoundingClientRect();
            menu.style.left = `${Math.min(window.innerWidth - 320, rect.right + 8)}px`;
            menu.style.top = `${Math.max(64, rect.top)}px`;
            menu.classList.remove('hidden');
        }

        function handleDockViewerClick(appType, event) {
            event?.stopPropagation();
            pruneDynamicViewerState();
            const safeType = sanitizeDockAppType(appType);
            const icon = document.querySelector(`.dock-app-icon[data-app-type="${safeType}"]`);
            if (!icon) return;
            const visiblePanels = getVisibleDynamicViewerPanelsByApp(safeType);
            const minimizedEntries = minimizedViewerWindows[safeType] || [];

            if (minimizedEntries.length || visiblePanels.length > 1) {
                showViewerDockMenu(safeType, icon);
                return;
            }
            hideDockWindowMenu();
            if (visiblePanels.length === 1) {
                focusWindowElement(visiblePanels[0]);
            }
        }

        function restoreMinimizedViewerWindow(appType, id) {
            const safeType = sanitizeDockAppType(appType);
            const list = minimizedViewerWindows[safeType] || [];
            const idx = list.findIndex((item) => item.id === id);
            if (idx < 0) return;
            const entry = list.splice(idx, 1)[0];
            if (!list.length) {
                delete minimizedViewerWindows[safeType];
            }
            const panel = document.getElementById(entry.windowId || '');
            if (panel) {
                panel.classList.remove('files-hidden');
                focusWindowElement(panel);
            }
            hideDockWindowMenu();
            updateDockBadges();
        }

        function updateViewerDockIcons() {
            pruneDynamicViewerState();
            const usage = getViewerAppUsage();
            const container = document.getElementById('dockDynamicApps');
            if (!container) return;
            const preferredOrder = [
                'document-viewer', 'image-viewer', 'text-editor',
                'writer', 'calc', 'impress', 'mail', 'calendar',
                'music', 'videos', 'generic'
            ];

            Object.entries(usage)
                .sort(([a], [b]) => {
                    const ia = preferredOrder.indexOf(a);
                    const ib = preferredOrder.indexOf(b);
                    if (ia >= 0 && ib >= 0) return ia - ib;
                    if (ia >= 0) return -1;
                    if (ib >= 0) return 1;
                    return a.localeCompare(b);
                })
                .forEach(([appType, info]) => {
                    const icon = ensureViewerDockIcon(appType, info.meta);
                    if (!icon) return;
                    icon.classList.toggle('active', info.open > 0 || info.minimized > 0);
                    icon.title = `${info.meta.name} (${info.open + info.minimized})`;
                    setDockBadge(icon, info.minimized);
                    container.appendChild(icon);
                });

            container.querySelectorAll('.dock-app-icon').forEach((icon) => {
                const appType = sanitizeDockAppType(icon.dataset.appType || '');
                if (!usage[appType]) {
                    icon.remove();
                }
            });
        }

        function updateDockBadges() {
            setDockBadge(getAppIcon('files'), (minimizedWindows.files || []).length);
            setDockBadge(getAppIcon('terminal'), (minimizedWindows.terminal || []).length);

            const filesIcon = getAppIcon('files');
            if (filesIcon) {
                filesIcon.classList.toggle('active', filesWindowVisible || fileViewerVisible || (minimizedWindows.files || []).length > 0);
            }
            const terminalIcon = getAppIcon('terminal');
            if (terminalIcon) {
                terminalIcon.classList.toggle('active', terminalVisible || (minimizedWindows.terminal || []).length > 0);
            }
            updateViewerDockIcons();
        }

        function hideDockWindowMenu() {
            const menu = document.getElementById('dockWindowMenu');
            if (!menu) return;
            menu.classList.add('hidden');
            menu.innerHTML = '';
        }

        function showDockWindowMenu(type, anchor) {
            const entries = minimizedWindows[type] || [];
            if (!entries.length) {
                hideDockWindowMenu();
                return;
            }
            const menu = document.getElementById('dockWindowMenu');
            if (!menu || !anchor) return;
            const title = type === 'files' ? 'Minimized Files' : 'Minimized Terminals';
            menu.innerHTML = `
                <div class="dock-window-menu-title">${escapeHtml(title)}</div>
                ${entries.map((entry) => `
                    <button type="button" class="dock-window-item" onclick="restoreMinimizedWindow('${type}', '${entry.id}')">${escapeHtml(entry.title || 'Window')}</button>
                `).join('')}
            `;
            const rect = anchor.getBoundingClientRect();
            menu.style.left = `${Math.min(window.innerWidth - 320, rect.right + 8)}px`;
            menu.style.top = `${Math.max(64, rect.top)}px`;
            menu.classList.remove('hidden');
        }

        function restoreMinimizedWindow(type, id) {
            const list = minimizedWindows[type] || [];
            const idx = list.findIndex((item) => item.id === id);
            if (idx < 0) return;
            const entry = list.splice(idx, 1)[0];
            hideDockWindowMenu();
            if (type === 'files') {
                if (entry.kind === 'dynamic') {
                    const panel = document.getElementById(entry.windowId || '');
                    if (panel) {
                        panel.classList.remove('files-hidden');
                        focusWindowElement(panel);
                    }
                    updateDockBadges();
                    return;
                }
                if (entry.kind === 'viewer') {
                    const panel = getAppWindow('viewer');
                    if (panel && entry && entry.html) {
                        panel.innerHTML = entry.html;
                    }
                    if (entry && entry.previewState) {
                        previewWindowState = entry.previewState;
                    }
                    if (entry && entry.selectedFile) {
                        setSelectedItem(entry.selectedFile, 'file');
                    }
                    setFileViewerVisible(true);
                    focusAppWindow('viewer');
                } else {
                    const panel = getAppWindow('files');
                    if (panel && entry && entry.html) {
                        panel.innerHTML = entry.html;
                    }
                    if (entry && entry.previewState) {
                        previewWindowState = entry.previewState;
                    }
                    if (entry && entry.selectedFile) {
                        setSelectedItem(entry.selectedFile, 'file');
                    }
                    if (entry && entry.mainFolderPath !== undefined) {
                        mainFolderPath = entry.mainFolderPath;
                    }
                    setFilesWindowVisible(true);
                    focusAppWindow('files');
                }
            } else {
                setTerminalVisible(true);
                focusAppWindow('terminal');
            }
            updateDockBadges();
        }

        function minimizeAppWindow(type) {
            if (type === 'files') {
                const panel = getAppWindow('files');
                if (panel && filesWindowVisible) {
                    minimizedWindows.files.unshift({
                        id: `f-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
                        kind: 'files',
                        title: getFilesWindowTitle(),
                        html: panel.innerHTML,
                        previewState: { ...previewWindowState },
                        selectedFile: selectedFile || '',
                        mainFolderPath: mainFolderPath || ''
                        });
                    minimizedWindows.files = minimizedWindows.files.slice(0, 16);
                }
                setFilesWindowVisible(false);
            } else if (type === 'viewer') {
                const panel = getAppWindow('viewer');
                if (panel && fileViewerVisible) {
                    minimizedWindows.files.unshift({
                        id: `v-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
                        kind: 'viewer',
                        title: getViewerWindowTitle(),
                        html: panel.innerHTML,
                        previewState: { ...previewWindowState },
                        selectedFile: selectedFile || ''
                    });
                    minimizedWindows.files = minimizedWindows.files.slice(0, 16);
                }
                setFileViewerVisible(false);
            } else {
                if (terminalVisible) {
                    minimizedWindows.terminal = [{
                        id: `t-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
                        title: 'Terminal'
                    }];
                }
                setTerminalVisible(false);
            }
            updateDockBadges();
        }

        function closeAppWindow(type) {
            if (type === 'files') {
                closePreviewWindow(false);
                return;
            }
            if (type === 'viewer') {
                closeFileViewerWindow(false);
                return;
            }
            setTerminalVisible(false);
        }

        function toggleMaximizeWindow(type) {
            const panel = getAppWindow(type);
            const state = windowRuntime[type];
            if (!panel || !state) return;
            if (type === 'terminal') {
                terminalUserCustomized = true;
            }
            ensureWindowGeometry(type);
            if (!state.maximized) {
                const rect = panel.getBoundingClientRect();
                const area = getWindowAreaRect();
                state.restore = {
                    left: panel.style.left || `${Math.round(rect.left - area.left)}px`,
                    top: panel.style.top || `${Math.round(rect.top - area.top)}px`,
                    width: panel.style.width || `${Math.round(rect.width)}px`,
                    height: panel.style.height || `${Math.round(rect.height)}px`
                };
                panel.classList.add('window-maximized');
                state.maximized = true;
            } else {
                panel.classList.remove('window-maximized');
                if (state.restore) {
                    panel.style.left = state.restore.left;
                    panel.style.top = state.restore.top;
                    panel.style.width = state.restore.width;
                    panel.style.height = state.restore.height;
                }
                state.maximized = false;
            }
            focusAppWindow(type);
        }

        function handleDockFilesClick(event) {
            event?.stopPropagation();
            const icon = getAppIcon('files');
            if (!filesWindowVisible && !fileViewerVisible && minimizedWindows.files.length) {
                showDockWindowMenu('files', icon);
                return;
            }
            hideDockWindowMenu();
            if (fileViewerVisible) {
                focusAppWindow('viewer');
                return;
            }
            if (filesWindowVisible) {
                focusAppWindow('files');
                return;
            }
            openDesktopHome();
        }

        function handleDockTerminalClick(event) {
            event?.stopPropagation();
            const icon = getAppIcon('terminal');
            if (!terminalVisible && minimizedWindows.terminal.length) {
                showDockWindowMenu('terminal', icon);
                return;
            }
            hideDockWindowMenu();
            if (terminalVisible) {
                focusAppWindow('terminal');
                return;
            }
            setTerminalVisible(true);
            focusAppWindow('terminal');
        }

        function initWindowManager() {
            const filesPanel = getAppWindow('files');
            const viewerPanel = getAppWindow('viewer');
            const terminalPanel = getAppWindow('terminal');
            if (filesPanel) {
                filesPanel.addEventListener('mousedown', () => focusAppWindow('files'));
            }
            if (viewerPanel) {
                viewerPanel.addEventListener('mousedown', () => focusAppWindow('viewer'));
            }
            if (terminalPanel) {
                terminalPanel.addEventListener('mousedown', (e) => {
                    if (e?.isTrusted) {
                        terminalUserCustomized = true;
                    }
                    focusAppWindow('terminal');
                });
            }

            document.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (e.target.closest('.window-action-btn')) return;
                const header = e.target.closest('.preview-header, #terminalWindowTopbar');
                if (!header) return;
                const panel = header.closest('[data-window-kind]');
                const area = getWindowAreaRect();
                if (!panel) return;
                if (panel.classList.contains('files-hidden') || panel.classList.contains('terminal-hidden')) return;
                const isDynamic = panel.dataset.windowKind === 'dynamic-viewer';
                const type = isDynamic ? 'dynamic-viewer' : (panel.dataset.windowKind || '');
                if (type === 'files' && !filesWindowVisible) return;
                if (type === 'viewer' && !fileViewerVisible) return;
                if (type === 'terminal' && !terminalVisible) return;
                if (!isDynamic && windowRuntime[type]?.maximized) return;
                if (isDynamic && dynamicWindowState[panel.id]?.maximized) return;
                if (type === 'terminal' && e.isTrusted) {
                    terminalUserCustomized = true;
                }

                const rect = panel.getBoundingClientRect();
                const startLeft = parseInt(panel.style.left || `${Math.round(rect.left - area.left)}`, 10);
                const startTop = parseInt(panel.style.top || `${Math.round(rect.top - area.top)}`, 10);
                activeDrag = {
                    panelId: panel.id,
                    isDynamic,
                    area,
                    startMouseX: e.clientX,
                    startMouseY: e.clientY,
                    startLeft: Number.isFinite(startLeft) ? startLeft : 0,
                    startTop: Number.isFinite(startTop) ? startTop : 0
                };
                focusWindowElement(panel);
                document.body.style.userSelect = 'none';
                document.body.style.cursor = 'move';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!activeDrag) return;
                const panel = document.getElementById(activeDrag.panelId);
                if (!panel) return;
                const area = activeDrag.area;
                const width = panel.offsetWidth;
                const height = panel.offsetHeight;
                const dx = e.clientX - activeDrag.startMouseX;
                const dy = e.clientY - activeDrag.startMouseY;
                const nextLeftRaw = activeDrag.startLeft + dx;
                const nextTopRaw = activeDrag.startTop + dy;
                const minLeft = Math.min(0, -width + 48);
                const maxLeft = area.width - 48;
                const minTop = 0;
                const maxTop = area.height - 36;
                const nextLeft = Math.max(minLeft, Math.min(maxLeft, nextLeftRaw));
                const nextTop = Math.max(minTop, Math.min(maxTop, nextTopRaw));
                panel.style.left = `${Math.round(nextLeft)}px`;
                panel.style.top = `${Math.round(nextTop)}px`;
            });

            document.addEventListener('mouseup', () => {
                if (!activeDrag) return;
                activeDrag = null;
                document.body.style.userSelect = '';
                document.body.style.cursor = '';
            });

            document.addEventListener('click', (e) => {
                const menu = document.getElementById('dockWindowMenu');
                const onMenu = e.target.closest('#dockWindowMenu');
                const onDock = e.target.closest('.ubuntu-dock-icon');
                if (menu && !onMenu && !onDock) {
                    hideDockWindowMenu();
                }
            });

            document.addEventListener('dragend', () => {
                clearDropTargetMarks();
                activeFileDrag = null;
            });
        }

        function setPreviewWindowLifecycle(operation, source, filePath) {
            const tracked = ['return_txt', 'return_img', 'return_ori', 'return_metadata', 'list_files'];
            if (!tracked.includes(operation)) {
                return;
            }

            const fromSource = source || 'api';
            const manualWindow = fromSource === 'webui' || fromSource === 'terminal';
            const windowKind = operation === 'list_files' ? 'files' : 'viewer';
            previewWindowState = {
                isOpen: true,
                source: fromSource,
                operation,
                filePath: filePath || '',
                windowKind,
                autoCloseAfterCommand: manualWindow ? null : commandSequence + 1
            };
        }

        function maybeAutoClosePreviewWindow() {
            if (!previewWindowState.isOpen) return;
            if (previewWindowState.autoCloseAfterCommand === null) return;
            if (commandSequence < previewWindowState.autoCloseAfterCommand) return;
            if (previewWindowState.windowKind === 'viewer') {
                closeFileViewerWindow(true);
            } else {
                closePreviewWindow(true);
            }
        }

        function closePreviewWindow(fromAuto = false) {
            if (!previewWindowState.isOpen) {
                renderWelcomePanel();
                return;
            }
            previewWindowState = {
                isOpen: false,
                source: '',
                operation: '',
                filePath: '',
                windowKind: 'files',
                autoCloseAfterCommand: null
            };
            renderWelcomePanel();
            if (!fromAuto) {
                showToast('Window closed', 'info');
            }
        }

        function renderPreviewHeader(title, operation, source, windowKind = 'files', handlers = null) {
            const minimizeFn = handlers?.minimize || (windowKind === 'viewer' ? `minimizeAppWindow('viewer')` : `minimizeAppWindow('files')`);
            const maximizeFn = handlers?.maximize || (windowKind === 'viewer' ? `toggleMaximizeWindow('viewer')` : `toggleMaximizeWindow('files')`);
            const closeFn = handlers?.close || (windowKind === 'viewer' ? `closeFileViewerWindow(false)` : `closePreviewWindow(false)`);
            return `
                <div class="preview-header">
                    <h2>${escapeHtml(title || 'Result')}</h2>
                    <div class="preview-header-actions">
                        <div class="window-action-group">
                            <button class="window-action-btn" type="button" title="Minimize" onclick="${minimizeFn}">&#x2212;</button>
                            <button class="window-action-btn" type="button" title="Maximize / Restore" onclick="${maximizeFn}">&#x2610;</button>
                            <button class="window-action-btn" type="button" title="Close" onclick="${closeFn}">&#x2715;</button>
                        </div>
                    </div>
                </div>
            `;
        }

        function setButtonState(btnId, enabled, reason) {
            const btn = document.getElementById(btnId);
            if (!btn) return;
            btn.disabled = !enabled;
            btn.title = reason || '';
            btn.style.opacity = enabled ? '1' : '0.5';
            btn.style.cursor = enabled ? 'pointer' : 'not-allowed';
        }

        function setAllToolbarButtonsEnabled(enabled) {
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                btn.disabled = !enabled;
                btn.style.opacity = enabled ? '1' : '0.5';
                btn.style.cursor = enabled ? 'pointer' : 'not-allowed';
            });
        }

        function refreshFeatureFlags() {
            apiFetch('/api/feature_flags')
                .then(r => r.json())
                .then(data => {
                    flagsInitialized = !!data.initialized;
                    enableReturnTxt = flagsInitialized ? !!data.enable_return_txt : true;
                    enableReturnImg = flagsInitialized ? !!data.enable_return_img : true;

                    if (!flagsInitialized && !warnedSetFlags) {
                        warnedSetFlags = true;
                    }

                    setAllToolbarButtonsEnabled(true);
                    setButtonState('btnReturnTxt', enableReturnTxt, enableReturnTxt ? '' : 'return_txt is disabled by feature flags');
                    setButtonState('btnReturnImg', enableReturnImg, enableReturnImg ? '' : 'return_img is disabled by feature flags');
                })
                .catch(() => {
                    // If flags cannot be fetched, keep buttons enabled (fail-open).
                    setAllToolbarButtonsEnabled(true);
                    setButtonState('btnReturnTxt', true, '');
                    setButtonState('btnReturnImg', true, '');
                });
        }

        // Initialize resize handles for panels
        function initResizeHandles() {
            // Old split-pane resize is intentionally disabled.
            // Windows now use native resize handles (bottom-right corner).
            return;
            const sidebar = document.getElementById('sidebar');
            const preview = document.getElementById('previewPanel');
            const terminal = document.getElementById('terminalPanel');
            const contentArea = document.querySelector('.content-area');

            const sidebarHandle = document.getElementById('sidebarResizeHandle');
            const previewHandle = document.getElementById('previewResizeHandle');
            const terminalHandle = document.getElementById('terminalResizeHandle');

            let isResizing = false;
            let currentKind = '';
            let currentHandle = null;
            let startX = 0;
            let startWidth = 0;
            let isLeftHandle = false;

            function getContentWidth() {
                const width = contentArea ? contentArea.clientWidth : window.innerWidth;
                return Math.max(780, width || 780);
            }

            function getResizeBounds(kind) {
                const areaWidth = getContentWidth();
                if (kind === 'sidebar') {
                    return { min: 220, max: 620 };
                }
                if (kind === 'terminal') {
                    return { min: 320, max: Math.max(560, Math.floor(areaWidth * 0.74)) };
                }
                const maxForFiles = terminalVisible
                    ? Math.max(420, areaWidth - 360)
                    : Math.max(520, areaWidth - 40);
                return { min: 380, max: maxForFiles };
            }

            function clampWidth(kind, width) {
                const bounds = getResizeBounds(kind);
                return Math.max(bounds.min, Math.min(bounds.max, width));
            }

            function applyWidth(kind, width) {
                const next = clampWidth(kind, width);
                if (kind === 'sidebar') {
                    sidebar.style.width = `${next}px`;
                } else if (kind === 'terminal') {
                    terminal.style.width = `${next}px`;
                    terminal.style.flex = `0 0 ${next}px`;
                } else if (kind === 'files') {
                    applyPreviewWidth(next, true);
                }
            }

            function startResize(e, kind, handle, panel, leftHandle = false) {
                if (!panel || !handle) return;
                if (panel.classList.contains('sidebar-collapsed') || panel.classList.contains('terminal-hidden') || panel.classList.contains('files-hidden')) {
                    return;
                }
                isResizing = true;
                currentKind = kind;
                currentHandle = handle;
                isLeftHandle = leftHandle;
                startX = e.clientX;
                startWidth = panel.offsetWidth || parseInt(getComputedStyle(panel).width, 10) || 0;
                currentHandle.classList.add('active');
                document.body.style.cursor = 'ew-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            }

            function doResize(e) {
                if (!isResizing || !currentKind) return;
                const diff = e.clientX - startX;
                const rawWidth = isLeftHandle ? startWidth - diff : startWidth + diff;
                applyWidth(currentKind, rawWidth);
            }

            function stopResize() {
                if (!isResizing) return;
                isResizing = false;
                if (currentHandle) {
                    currentHandle.classList.remove('active');
                }
                document.body.style.cursor = '';
                document.body.style.userSelect = '';

                try {
                    if (currentKind === 'sidebar') {
                        localStorage.setItem('hippocamp_sidebar_width', sidebar.style.width);
                    } else if (currentKind === 'terminal') {
                        localStorage.setItem('hippocamp_terminal_width', terminal.style.width);
                    } else if (currentKind === 'files') {
                        localStorage.setItem('hippocamp_files_width', preview.style.width);
                    }
                } catch (e) {}

                currentKind = '';
                currentHandle = null;
            }

            sidebarHandle?.addEventListener('mousedown', (e) => startResize(e, 'sidebar', sidebarHandle, sidebar, false));
            previewHandle?.addEventListener('mousedown', (e) => startResize(e, 'files', previewHandle, preview, false));
            terminalHandle?.addEventListener('mousedown', (e) => startResize(e, 'terminal', terminalHandle, terminal, true));

            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);

            const savedSidebarWidth = localStorage.getItem('hippocamp_sidebar_width');
            const savedTerminalWidth = localStorage.getItem('hippocamp_terminal_width');
            const savedFilesWidth = localStorage.getItem('hippocamp_files_width');

            if (savedSidebarWidth) {
                const width = parseInt(savedSidebarWidth, 10);
                if (Number.isFinite(width)) applyWidth('sidebar', width);
            }
            if (savedTerminalWidth) {
                const width = parseInt(savedTerminalWidth, 10);
                if (Number.isFinite(width)) applyWidth('terminal', width);
            }
            if (savedFilesWidth) {
                const width = parseInt(savedFilesWidth, 10);
                if (Number.isFinite(width)) applyWidth('files', width);
            }

            window.addEventListener('resize', () => {
                if (sidebar && sidebarVisible) {
                    const sw = parseInt(getComputedStyle(sidebar).width, 10);
                    if (Number.isFinite(sw)) applyWidth('sidebar', sw);
                }
                if (terminal && terminalVisible && !terminal.classList.contains('terminal-hidden')) {
                    const tw = parseInt(getComputedStyle(terminal).width, 10);
                    if (Number.isFinite(tw)) applyWidth('terminal', tw);
                }
                if (preview && filesWindowVisible && !preview.classList.contains('files-hidden') && preview.classList.contains('preview-resized')) {
                    const pw = parseInt(getComputedStyle(preview).width, 10);
                    if (Number.isFinite(pw)) applyWidth('files', pw);
                }
            });
        }

        // WebSocket
        function initSocket() {
            startHistoryPolling();

            if (typeof io !== 'function') {
                updateConnectionStatus('polling');
                return;
            }

            socket = io({
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionAttempts: Infinity,
                reconnectionDelay: 1000,
                timeout: 10000
            });

            socket.on('connect', () => {
                updateConnectionStatus('connected');
            });

            socket.on('disconnect', () => {
                updateConnectionStatus('polling');
            });

            socket.on('connect_error', () => {
                updateConnectionStatus('polling');
            });

            socket.on('connected', (data) => {
                console.log('Connected to HippoCamp:', data);
                if (data.history) {
                    data.history.forEach(entry => addTerminalEntry(entry));
                }
                fetch('/api/replay/status', { cache: 'no-store' })
                    .then((resp) => resp.json())
                    .then((payload) => {
                        if (payload && payload.success && payload.state) {
                            handleReplayState(payload.state);
                        }
                    })
                    .catch(() => {});
            });

            socket.on('command_executed', (entry) => {
                addTerminalEntry(entry);
                const output = document.getElementById('terminalOutput');
                output.scrollTop = output.scrollHeight;
                if (entry && entry.command && entry.command.startsWith('set_flags')) {
                    refreshFeatureFlags();
                }
            });

            // Handle file operations from any source (agent, API, terminal)
            socket.on('file_operation', (data) => {
                console.log('[File Operation]', data);
                handleFileOperation(data);
            });

            socket.on('replay_state', (state) => {
                handleReplayState(state || {});
            });

            socket.on('replay_event', (packet) => {
                queueAgentAnimation(async () => {
                    await handleReplayEvent(packet || {});
                });
            });
        }

        function buildEntryKey(entry) {
            const ts = entry?.ts_ms || entry?.timestamp || '';
            return `${ts}|${entry?.source || ''}|${entry?.command || ''}`;
        }

        async function pollHistoryOnce() {
            try {
                const resp = await fetch('/api/history', { cache: 'no-store' });
                if (!resp.ok) return;
                const data = await resp.json();
                if (!data || !data.success || !Array.isArray(data.history)) return;

                if (!socket || !socket.connected) {
                    updateConnectionStatus('polling');
                }

                data.history.forEach((entry) => {
                    if (entry && entry.ts_ms && entry.ts_ms > lastHistoryTsMs) {
                        lastHistoryTsMs = entry.ts_ms;
                    }
                    addTerminalEntry(entry);
                });
            } catch (e) {
                if (!socket || !socket.connected) {
                    updateConnectionStatus('disconnected');
                }
            }
        }

        function startHistoryPolling() {
            if (historyPollTimer) return;
            pollHistoryOnce();
            historyPollTimer = setInterval(pollHistoryOnce, 1500);
        }

        // Handle file operations and update UI accordingly
        async function handleFileOperation(data) {
            const { operation, file_path, source } = data;
            const sourceTag = source || 'api';
            if (sourceTag === 'agent' && wasOperationHandledRecently(operation, file_path, sourceTag, 1200)) {
                return;
            }
            if (sourceTag === 'agent') {
                applyAgentTerminalLayout(false);
                if (operation === 'list_files' || operation === 'change_dir') {
                    enforceAgentSingleActiveWindow('files');
                } else {
                    enforceAgentSingleActiveWindow('viewer');
                }
            }
            markOperationHandled(operation, file_path, sourceTag);

            // Show operation indicator
            showOperationIndicator(operation, file_path, sourceTag);
            runOperationCursorAnimation(operation, file_path, sourceTag);

            // Select file in tree
            if (file_path && operation !== 'list_files') {
                selectFileByPath(file_path);
            }

            if (operation === 'list_files' && isGlobPattern(String(file_path || ''))) {
                const pattern = normalizeDatasetPath(file_path || '');
                try {
                    const resp = await apiFetch(`/api/files/list?pattern=${encodeURIComponent(pattern)}`);
                    const treeData = await resp.json();
                    if (treeData.success) {
                        updatePreviewFromOperation({
                            operation: 'list_files',
                            file_path: pattern,
                            flat_files: treeData.files || [],
                            source: sourceTag,
                            success: true
                        });
                    } else {
                        updatePreviewFromOperation({
                            operation: 'list_files',
                            file_path: pattern,
                            source: sourceTag,
                            success: false,
                            error: treeData.error || (pattern ? `: ${pattern}` : '')
                        });
                    }
                } catch (e) {
                    updatePreviewFromOperation({
                        operation: 'list_files',
                        file_path: pattern,
                        source: sourceTag,
                        success: false,
                        error: pattern ? `: ${pattern}` : ''
                    });
                }
                return;
            }

            // Update preview panel based on operation
            updatePreviewFromOperation({ ...data, source: sourceTag });
        }

        // Show a visual indicator for operations
        function showOperationIndicator(operation, filePath, source) {
            const fileName = filePath ? filePath.split('/').pop() : '';
            const sourceTag = source || 'api';
            const sourceColors = {
                'agent': 'var(--accent-pink)',
                'terminal': 'var(--accent-green)',
                'webui': 'var(--accent-primary)',
                'api': 'var(--accent-cyan)'
            };
            const color = sourceColors[sourceTag] || 'var(--accent-primary)';

            // Flash effect on terminal panel
            const terminalHeader = document.querySelector('.terminal-header');
            if (terminalHeader) {
                terminalHeader.style.boxShadow = `inset 0 0 20px ${color}`;
                setTimeout(() => {
                    terminalHeader.style.boxShadow = '';
                }, 500);
            }

            showToast(`${sourceTag}: ${operation} ${fileName}`, 'success');
        }

        async function animateAgentFolderDrilldown(targetPath, withFile = true) {
            const cleanTarget = normalizeVirtualPath(targetPath);
            const homeShortcut = document.querySelector('.desktop-shortcut[title="Home"]');
            if (homeShortcut) {
                enforceAgentSingleActiveWindow('files');
                await animateCursorToElement(homeShortcut, { label: 'Open Home', click: true, doubleClick: true });
                openDesktopHome();
                await sleepAgent(420);
            }
            if (!cleanTarget) return '';
            const parts = cleanTarget.split('/').filter(Boolean);
            const filePart = withFile ? (parts.pop() || '') : '';
            let current = '';

            for (const part of parts) {
                current = current ? `${current}/${part}` : part;
                let dirEl = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(current)}"]`);
                if (!dirEl) {
                    expandFolderByPath(current);
                    await sleepAgent(340);
                    dirEl = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(current)}"]`);
                }
                if (!dirEl) continue;
                await animateCursorToElement(dirEl, { label: `Open ${part}`, click: true });
                if (!dirEl.classList.contains('open')) {
                    dirEl.click();
                }
                const children = dirEl.nextElementSibling;
                if (children && children.classList.contains('tree-children')) {
                    children.classList.add('expanded');
                }
                openSidebarFolder(current, false);
                await sleepAgent(320);
            }
            return filePart ? `${current ? `${current}/` : ''}${filePart}` : cleanTarget;
        }

        function runOperationCursorAnimation(operation, filePath, source) {
            const sourceTag = String(source || 'api');
            if (sourceTag !== 'agent') {
                return;
            }
            if (String(operation || '').toLowerCase() === 'return_metadata') {
                return;
            }
            queueAgentAnimation(async () => {
                const fileName = String(filePath || '').split('/').pop() || '';
                showAgentActionBanner(`${sourceTag}: ${operation}${fileName ? `  ${fileName}` : ''}`, 2200);

                if (operation === 'list_files') {
                    enforceAgentSingleActiveWindow('files');
                    if (isGlobPattern(String(filePath || ''))) {
                        const homeShortcut = document.querySelector('.desktop-shortcut[title="Home"]');
                        if (homeShortcut) {
                            await animateCursorToElement(homeShortcut, { label: 'Open Home', click: true, doubleClick: true });
                            openDesktopHome();
                        }
                    } else {
                        await animateAgentFolderDrilldown(filePath, false);
                    }
                    hideAgentCursorLater(agentMs(980));
                    return;
                }

                if (!filePath) return;
                enforceAgentSingleActiveWindow('files');
                const cleanPath = await animateAgentFolderDrilldown(filePath, true);
                const selector = `.tree-item.file[data-path="${cssEscapeValue(cleanPath)}"]`;
                let fileEl = document.querySelector(selector);
                if (!fileEl) {
                    selectFileByPath(cleanPath);
                    await sleepAgent(340);
                    fileEl = document.querySelector(selector);
                }
                if (fileEl) {
                    await animateCursorToElement(fileEl, { label: `Open ${fileName || 'file'}`, click: true, doubleClick: true });
                    await sleepAgent(320);
                    hideAgentCursorLater(agentMs(960));
                    enforceAgentSingleActiveWindow('viewer');
                }
            });
        }

        function replayRand(minMs = 200, maxMs = 500) {
            const min = Number(minMs) || 0;
            const max = Number(maxMs) || min;
            return Math.round(min + Math.random() * Math.max(0, max - min));
        }

        async function replaySleep(minMs = 200, maxMs = 500) {
            await sleepAgent(replayRand(minMs, maxMs));
        }

        async function replayHumanType(targetEl, text, opts = {}) {
            if (!targetEl) return;
            const min = Number(opts.min) || 60;
            const max = Number(opts.max) || 110;
            const pauseEvery = Number(opts.pauseEvery) || 12;
            const pauseMin = Number(opts.pauseMin) || 200;
            const pauseMax = Number(opts.pauseMax) || 400;
            const raw = String(text || '');
            targetEl.value = '';
            targetEl.dispatchEvent(new Event('input', { bubbles: true }));
            for (let i = 0; i < raw.length; i += 1) {
                targetEl.value += raw[i];
                targetEl.dispatchEvent(new Event('input', { bubbles: true }));
                await sleepAgent(replayRand(min, max));
                if ((i + 1) % pauseEvery === 0) {
                    await sleepAgent(replayRand(pauseMin, pauseMax));
                }
            }
        }

        function replayNormalizeTrigger(trigger = '') {
            return String(trigger || '').trim().toLowerCase();
        }

        function replayFileName(path = '') {
            const clean = normalizeVirtualPath(path || '');
            if (!clean) return '';
            const parts = clean.split('/');
            return parts[parts.length - 1] || clean;
        }

        function replayHasFileExt(path = '') {
            const name = replayFileName(path || '');
            return /\.[A-Za-z0-9]{1,12}$/.test(name);
        }

        function replayResolveExistingFilePath(path = '') {
            const requested = normalizeVirtualPath(path || '');
            if (!requested) return '';
            const exact = findNodeRecord(requested);
            if (exact && exact.node?.type === 'file') {
                return requested;
            }

            const base = replayFileName(requested);
            if (!base) return requested;

            const allFiles = listAllVirtualFilePaths(fileData, '', []);
            const sameName = allFiles.filter((p) => (p.split('/').pop() || '') === base);
            if (!sameName.length) {
                return requested;
            }

            const requestedParent = getParentPath(requested);
            if (requestedParent) {
                const inParent = sameName.find((p) => getParentPath(p) === requestedParent);
                if (inParent) return inParent;
            }
            return sameName[0];
        }

        function replayResolveTargetPath(sourcePath = '', targetRaw = '', mode = 'move') {
            const src = normalizeVirtualPath(sourcePath || '');
            const target = normalizeReplayPath(targetRaw || '');
            const srcName = replayFileName(src);
            if (!src || !target) {
                return {
                    source: src,
                    rawTarget: target,
                    targetPath: target,
                    targetDirectory: getParentPath(target),
                    isDirectoryTarget: false
                };
            }

            const targetRef = findNodeRecord(target);
            const targetExistsAsDir = !!(targetRef && targetRef.node?.type === 'directory');
            const targetHasExt = replayHasFileExt(target);
            const sourceHasExt = replayHasFileExt(src);
            const cleanMode = String(mode || 'move').toLowerCase();
            const treatAsDirectory = targetExistsAsDir
                || (!targetHasExt && sourceHasExt && (cleanMode === 'move' || cleanMode === 'copy'));

            if (treatAsDirectory) {
                const targetPath = target ? `${target}/${srcName}` : srcName;
                return {
                    source: src,
                    rawTarget: target,
                    targetPath,
                    targetDirectory: target,
                    isDirectoryTarget: true
                };
            }

            return {
                source: src,
                rawTarget: target,
                targetPath: target,
                targetDirectory: getParentPath(target),
                isDirectoryTarget: false
            };
        }

        function handleReplayState(state = {}) {
            const prevRunning = !!replaySessionState.running;
            replaySessionState = Object.assign({}, replaySessionState, state || {});
            const running = !!replaySessionState.running;
            const sent = Number(replaySessionState.events_sent || 0);
            const total = Number(replaySessionState.events_total || 0);
            if (running) {
                if (!prevRunning) {
                    replayLastHandledEventType = '';
                }
                setAutoReadIndicator('running', `Replay ${sent}/${total}`);
                if (!prevRunning) {
                    showToast(`Replay started (${total} events)`, 'info');
                }
                return;
            }
            replayLastHandledEventType = '';
            setAutoReadIndicator('idle', 'Auto Read: Agent only');
            if (prevRunning) {
                if (replaySessionState.error) {
                    showToast(`Replay stopped: ${replaySessionState.error}`, 'error');
                } else {
                    showToast('Replay completed', 'success');
                }
            }
        }

        function normalizeReplayPath(rawPath = '') {
            let path = String(rawPath || '').trim();
            if (!path) return '';
            path = path.replace(/\\/g, '/').replace(/^['"]|['"]$/g, '');
            path = path.replace(/^\/hippocamp\/data\/?/, '').replace(/^data\/?/, '').replace(/^\.\/+/, '');
            const marker = 'pilot/sandbox/';
            const markerIdx = path.indexOf(marker);
            if (markerIdx >= 0) {
                path = path.slice(markerIdx + marker.length);
            }
            const parts = path.split('/').filter(Boolean);
            if (parts.length > 1 && /^p\d+_.+_T-\d+$/i.test(parts[0])) {
                parts.shift();
            }
            const dataset = String(document.body?.dataset?.dataset || '').trim();
            if (dataset && parts.length > 1 && parts[0] === dataset) {
                parts.shift();
            }
            return normalizeVirtualPath(parts.join('/'));
        }

        function listAllVirtualFilePaths(nodes = fileData, prefix = '', collector = []) {
            (nodes || []).forEach((item) => {
                const itemPath = normalizeVirtualPath(item.path || (prefix ? `${prefix}/${item.name}` : item.name || ''));
                if (!itemPath) return;
                if (item.type === 'file') {
                    collector.push(itemPath);
                    return;
                }
                listAllVirtualFilePaths(item.children || [], itemPath, collector);
            });
            return collector;
        }

        function listAllVirtualDirectoryPaths(nodes = fileData, prefix = '', collector = []) {
            (nodes || []).forEach((item) => {
                const itemPath = normalizeVirtualPath(item.path || (prefix ? `${prefix}/${item.name}` : item.name || ''));
                if (!itemPath || item.type !== 'directory') return;
                collector.push(itemPath);
                listAllVirtualDirectoryPaths(item.children || [], itemPath, collector);
            });
            return collector;
        }

        function replayGlobToRegExp(pattern = '') {
            const raw = String(pattern || '').trim();
            if (!raw) return null;
            const escaped = raw.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            const withGroups = escaped.replace(/\\\{([^}]+)\\\}/g, (_, group) => {
                const opts = String(group || '')
                    .split(',')
                    .map((part) => part.trim())
                    .filter(Boolean)
                    .map((part) => part.replace(/[.+^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '.*').replace(/\?/g, '.'));
                return opts.length ? `(${opts.join('|')})` : '';
            });
            const finalExpr = withGroups.replace(/\*/g, '.*').replace(/\?/g, '.');
            try {
                return new RegExp(`^${finalExpr}$`, 'i');
            } catch (e) {
                return null;
            }
        }

        function replayFindMatchingFiles(searchType = 'glob', query = '') {
            const files = listAllVirtualFilePaths(fileData, '', []);
            const cleanQuery = String(query || '').trim();
            if (!cleanQuery) return [];
            if (String(searchType || '').toLowerCase() === 'glob') {
                const re = replayGlobToRegExp(cleanQuery);
                if (!re) return [];
                return files.filter((path) => {
                    const base = path.split('/').pop() || path;
                    return re.test(path) || re.test(base);
                });
            }
            const needle = cleanQuery.toLowerCase();
            return files.filter((path) => path.toLowerCase().includes(needle));
        }

        function replayHighlightPaths(paths = []) {
            document.querySelectorAll('.tree-item.highlighted').forEach((el) => el.classList.remove('highlighted'));
            (paths || []).slice(0, 22).forEach((path) => {
                const clean = normalizeVirtualPath(path);
                if (!clean) return;
                const fileEl = document.querySelector(`.tree-item.file[data-path="${cssEscapeValue(clean)}"]`);
                if (fileEl) fileEl.classList.add('highlighted');
            });
        }

        async function replayEnsureTreeReady() {
            if (!Array.isArray(fileData) || !fileData.length) {
                await loadFiles();
                await sleepAgent(120);
            }
        }

        function ensureVirtualDirectoryPath(dirPath = '') {
            const clean = normalizeVirtualPath(dirPath || '');
            if (!clean) return true;
            const parts = clean.split('/').filter(Boolean);
            let current = '';
            for (const part of parts) {
                current = current ? `${current}/${part}` : part;
                const existing = findNodeRecord(current);
                if (existing && existing.node?.type === 'directory') continue;
                const parent = getParentPath(current);
                const created = createVirtualItem('directory', parent, part);
                if (!created.success) return false;
            }
            return true;
        }

        function replaySetPathAlias(aliasPath, sourcePath) {
            const alias = normalizeVirtualPath(aliasPath || '');
            if (!alias) return;
            const source = normalizeVirtualPath(sourcePath || alias);
            virtualPathMap[alias] = resolveActualPath(source) || source || alias;
        }

        function moveVirtualItemToPath(srcPath, destPath) {
            const src = normalizeVirtualPath(srcPath);
            const dest = normalizeVirtualPath(destPath);
            if (!src || !dest) return { success: false, error: 'Invalid source/destination path.' };
            const targetDir = getParentPath(dest);
            ensureVirtualDirectoryPath(targetDir);
            const moved = moveVirtualItem(src, targetDir);
            if (!moved.success) return moved;
            const expectedName = dest.split('/').pop() || '';
            const movedName = moved.path.split('/').pop() || '';
            if (expectedName && movedName !== expectedName) {
                const renamed = renameVirtualItem(moved.path, expectedName);
                if (!renamed.success) return renamed;
                replaySetPathAlias(renamed.path, src);
                return renamed;
            }
            replaySetPathAlias(moved.path, src);
            return moved;
        }

        function cloneVirtualNode(node, nextPath) {
            if (!node) return null;
            if (node.type === 'directory') {
                return {
                    type: 'directory',
                    name: nextPath.split('/').pop() || node.name,
                    path: nextPath,
                    children: (node.children || []).map((child) => {
                        const childPath = `${nextPath}/${child.name}`;
                        return cloneVirtualNode(child, childPath);
                    }).filter(Boolean)
                };
            }
            const name = nextPath.split('/').pop() || node.name;
            return {
                type: 'file',
                name,
                path: nextPath,
                ext: name.includes('.') ? name.split('.').pop().toLowerCase() : ''
            };
        }

        function copyVirtualItemToPath(sourcePath, destPath) {
            const source = normalizeVirtualPath(sourcePath || '');
            const dest = normalizeVirtualPath(destPath || '');
            if (!source || !dest) return { success: false, error: 'Invalid source/destination path.' };
            const srcRef = findNodeRecord(source);
            if (!srcRef) return { success: false, error: `Cannot find source: ${source}` };
            if (findNodeRecord(dest)) return { success: false, error: `Target already exists: ${dest}` };
            const targetDir = getParentPath(dest);
            ensureVirtualDirectoryPath(targetDir);
            const targetRef = targetDir ? findNodeRecord(targetDir) : null;
            const targetChildren = targetRef?.node?.children || fileData;
            const clone = cloneVirtualNode(srcRef.node, dest);
            if (!clone) return { success: false, error: 'Clone failed.' };
            targetChildren.push(clone);
            replaySetPathAlias(dest, source);
            refreshExplorerViews(dest);
            recordUiTmpOp('copy', { from: source, to: dest });
            return { success: true, path: dest };
        }

        async function replayShowContextMenu(targetEl, labels = [], pickIndex = 0, actionLabel = 'Context menu', dwellRange = [700, 1200]) {
            const fallback = {
                left: window.innerWidth * 0.5 - 80,
                top: window.innerHeight * 0.35,
                width: 160,
                height: 32
            };
            const rect = targetEl?.getBoundingClientRect ? targetEl.getBoundingClientRect() : fallback;
            const x = Math.max(24, Math.min(window.innerWidth - 24, rect.left + Math.max(18, rect.width * 0.55)));
            const y = Math.max(24, Math.min(window.innerHeight - 24, rect.top + Math.max(12, rect.height * 0.56)));
            await moveAgentCursorTo(x, y, { duration: replayRand(300, 850), label: actionLabel });
            await replaySleep(180, 320);
            emitAgentRippleAt(x, y, false);

            const menu = document.createElement('div');
            menu.className = 'replay-context-menu';
            menu.style.left = `${Math.min(window.innerWidth - 210, Math.max(12, x + 10))}px`;
            menu.style.top = `${Math.min(window.innerHeight - 200, Math.max(12, y + 8))}px`;
            menu.innerHTML = (labels || []).map((label, idx) => (
                `<button type="button" class="replay-context-item${idx === pickIndex ? ' selected' : ''}" data-idx="${idx}">${escapeHtml(String(label || 'Action'))}</button>`
            )).join('');
            document.body.appendChild(menu);
            await replaySleep(dwellRange[0], dwellRange[1]);

            const picked = menu.querySelector(`.replay-context-item[data-idx="${Math.max(0, pickIndex)}"]`);
            if (picked) {
                await animateCursorToElement(picked, {
                    label: String(labels[pickIndex] || 'Select'),
                    click: true,
                    duration: replayRand(320, 640)
                });
                await replaySleep(250, 420);
            }
            menu.remove();
            await replaySleep(250, 420);
        }

        async function replayAnimateDrag(sourceEl, targetEl, caption = 'Drag') {
            if (!sourceEl || !targetEl) return;
            const from = getElementCenterPoint(sourceEl);
            const to = getElementCenterPoint(targetEl);
            if (!from || !to) return;

            const ghost = document.createElement('div');
            ghost.className = 'replay-drag-ghost';
            ghost.textContent = caption;
            ghost.style.left = `${from.x}px`;
            ghost.style.top = `${from.y}px`;
            document.body.appendChild(ghost);

            sourceEl.classList.add('drag-source');
            targetEl.classList.add('drop-target');
            await moveAgentCursorTo(from.x, from.y, { duration: replayRand(340, 720), label: 'Pick up' });
            await replaySleep(220, 420);
            emitAgentRippleAt(from.x, from.y, false);

            const steps = 12;
            for (let i = 1; i <= steps; i += 1) {
                const t = i / steps;
                const x = from.x + (to.x - from.x) * t;
                const y = from.y + (to.y - from.y) * t;
                ghost.style.left = `${x}px`;
                ghost.style.top = `${y}px`;
                await moveAgentCursorTo(x, y, {
                    duration: replayRand(320, 820) / steps + 40,
                    label: i === steps ? 'Drop' : 'Dragging'
                });
            }
            emitAgentRippleAt(to.x, to.y, false);
            await replaySleep(250, 450);

            ghost.remove();
            sourceEl.classList.remove('drag-source');
            targetEl.classList.remove('drop-target');
        }

        async function replayShowDialog(kind = 'info', title = '', body = '', holdMs = 820) {
            const dialog = document.createElement('div');
            const mode = kind === 'error' ? 'error' : (kind === 'success' ? 'success' : '');
            dialog.className = `replay-inline-dialog ${mode}`.trim();
            dialog.innerHTML = `
                <div class="title">${escapeHtml(String(title || 'Replay event'))}</div>
                <div class="body">${escapeHtml(String(body || ''))}</div>
            `;
            document.body.appendChild(dialog);
            await sleepAgent(Math.max(holdMs, kind === 'error' ? replayRand(1500, 2200) : replayRand(1000, 1600)));
            dialog.remove();
        }

        function replayPanelRectInArea(panel, area) {
            const rect = panel.getBoundingClientRect();
            const left = Number.parseFloat(panel.style.left);
            const top = Number.parseFloat(panel.style.top);
            const width = Number.parseFloat(panel.style.width);
            const height = Number.parseFloat(panel.style.height);
            return {
                left: Number.isFinite(left) ? left : Math.max(0, rect.left - area.left),
                top: Number.isFinite(top) ? top : Math.max(0, rect.top - area.top),
                width: Number.isFinite(width) ? width : Math.max(360, rect.width),
                height: Number.isFinite(height) ? height : Math.max(260, rect.height)
            };
        }

        async function replayDragWindowToRect(panel, targetRect, label = 'Arrange window') {
            if (!panel || !targetRect) return;
            const area = getWindowAreaRect();
            const header = panel.querySelector('.preview-header, #terminalWindowTopbar') || panel;
            const startPoint = getElementCenterPoint(header) || getElementCenterPoint(panel);
            const from = replayPanelRectInArea(panel, area);
            const to = {
                left: Math.max(0, Number(targetRect.left || 0)),
                top: Math.max(0, Number(targetRect.top || 0)),
                width: Math.max(420, Number(targetRect.width || from.width)),
                height: Math.max(300, Number(targetRect.height || from.height))
            };
            panel.classList.remove('window-maximized');

            if (startPoint) {
                await moveAgentCursorTo(startPoint.x, startPoint.y, {
                    duration: replayRand(320, 760),
                    label
                });
                emitAgentRippleAt(startPoint.x, startPoint.y, false);
                await replaySleep(180, 340);
            }

            const endPoint = {
                x: area.left + to.left + Math.min(120, Math.max(52, to.width * 0.35)),
                y: area.top + to.top + 18
            };
            const origin = startPoint || endPoint;
            const steps = 10;
            for (let i = 1; i <= steps; i += 1) {
                const t = i / steps;
                panel.style.left = `${Math.round(from.left + (to.left - from.left) * t)}px`;
                panel.style.top = `${Math.round(from.top + (to.top - from.top) * t)}px`;
                panel.style.width = `${Math.round(from.width + (to.width - from.width) * t)}px`;
                panel.style.height = `${Math.round(from.height + (to.height - from.height) * t)}px`;
                await moveAgentCursorTo(
                    origin.x + (endPoint.x - origin.x) * t,
                    origin.y + (endPoint.y - origin.y) * t,
                    {
                        duration: replayRand(220, 500) / steps + 36,
                        label: i === steps ? 'Drop window' : ''
                    }
                );
            }
            await replaySleep(220, 420);
        }

        async function replayArrangeFilesAndViewerSplit() {
            const filesPanel = getAppWindow('files');
            const viewerPanel = getAppWindow('viewer');
            if (!filesPanel || !viewerPanel) return;
            if (filesPanel.classList.contains('files-hidden') || viewerPanel.classList.contains('files-hidden')) return;
            const area = getWindowAreaRect();
            const margin = 14;
            const gap = 14;
            const totalWidth = Math.max(760, area.width - margin * 2);
            const height = Math.max(360, area.height - 30);
            const filesWidth = Math.round(totalWidth * 0.44);
            const viewerWidth = Math.max(460, totalWidth - filesWidth - gap);
            await replayDragWindowToRect(filesPanel, {
                left: margin,
                top: 10,
                width: filesWidth,
                height
            }, 'Move folder window');
            await replayDragWindowToRect(viewerPanel, {
                left: margin + filesWidth + gap,
                top: 10,
                width: viewerWidth,
                height
            }, 'Move file window');
        }

        function replayClearDynamicViewerWindows() {
            Array.from(document.querySelectorAll('[data-window-kind="dynamic-viewer"]')).forEach((panel) => panel.remove());
            Object.keys(dynamicWindowState).forEach((key) => delete dynamicWindowState[key]);
            Object.keys(minimizedViewerWindows).forEach((key) => delete minimizedViewerWindows[key]);
            updateDockBadges();
        }

        function replayFindDynamicViewerByPath(path = '') {
            const clean = normalizeVirtualPath(path || '');
            if (!clean) return null;
            const panels = Array.from(document.querySelectorAll('[data-window-kind="dynamic-viewer"]'))
                .filter((panel) => !panel.classList.contains('files-hidden'));
            return panels.find((panel) => {
                const state = dynamicWindowState[panel.id] || {};
                return normalizeVirtualPath(state.path || '') === clean;
            }) || null;
        }

        async function replayOpenDynamicViewer(path, operation = 'cross_file_reference', opts = {}) {
            const clean = normalizeReplayPath(path || '');
            if (!clean) return null;
            const existing = replayFindDynamicViewerByPath(clean);
            if (existing) {
                focusWindowElement(existing);
                return existing;
            }
            const appMeta = getViewerAppMetaByExt(getFileExtFromPath(clean));
            const windowId = createDynamicViewerWindow(clean, appMeta);
            if (!windowId) return null;
            const panel = document.getElementById(windowId);
            const handlers = {
                minimize: `minimizeDynamicWindow('${windowId}')`,
                maximize: `toggleDynamicWindowMaximize('${windowId}')`,
                close: `closeDynamicWindow('${windowId}')`
            };

            if (opts.openViaExplorer !== false) {
                if (panel) {
                    panel.classList.add('files-hidden');
                }
                const opened = await replayOpenFilePath(clean, operation, `Open ${replayFileName(clean)}`, {
                    keepFilesVisible: true,
                    useQuickSearch: false,
                    openHome: opts.openHome !== false,
                    panelId: windowId,
                    contentId: `previewContent_${windowId}`,
                    floating: true,
                    headerHandlers: handlers
                });
                if (!opened) {
                    if (panel) {
                        closeDynamicWindow(panel.id);
                    }
                    return null;
                }
                if (panel) {
                    panel.classList.remove('files-hidden');
                    focusWindowElement(panel);
                }
            } else {
                await loadFilePreview(clean, {
                    source: 'agent',
                    operation,
                    panelId: windowId,
                    contentId: `previewContent_${windowId}`,
                    windowKind: 'viewer',
                    headerHandlers: handlers,
                    floating: true,
                    skipMetadata: true
                });
            }
            replaySetPathAlias(clean, clean);
            return panel || document.getElementById(windowId);
        }

        async function replayArrangeDualViewerPanels(leftPanel, rightPanel) {
            if (!leftPanel || !rightPanel) return;
            const area = getWindowAreaRect();
            const margin = 14;
            const gap = 14;
            const width = Math.max(440, Math.round((area.width - margin * 2 - gap) / 2));
            const height = Math.max(340, area.height - 26);
            await replayDragWindowToRect(leftPanel, {
                left: margin,
                top: 8,
                width,
                height
            }, 'Place source file');
            await replayDragWindowToRect(rightPanel, {
                left: margin + width + gap,
                top: 8,
                width,
                height
            }, 'Place target file');
        }

        function replayRectsOverlap(a, b) {
            if (!a || !b) return false;
            return a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top;
        }

        function replayVisiblePanels() {
            const panels = [];
            const filesPanel = getAppWindow('files');
            if (filesPanel && filesWindowVisible && !filesPanel.classList.contains('files-hidden')) {
                panels.push(filesPanel);
            }
            const viewerPanel = getAppWindow('viewer');
            if (viewerPanel && fileViewerVisible && !viewerPanel.classList.contains('files-hidden')) {
                panels.push(viewerPanel);
            }
            Array.from(document.querySelectorAll('[data-window-kind="dynamic-viewer"]'))
                .filter((panel) => !panel.classList.contains('files-hidden'))
                .forEach((panel) => panels.push(panel));
            return panels.sort((a, b) => (Number.parseInt(b.style.zIndex || '0', 10) || 0) - (Number.parseInt(a.style.zIndex || '0', 10) || 0));
        }

        async function replayEnsureDesktopShortcutReachable(shortcutEl) {
            if (!shortcutEl) return;
            const targetRect = shortcutEl.getBoundingClientRect();
            const area = getWindowAreaRect();
            let moved = 0;
            for (const panel of replayVisiblePanels()) {
                const rect = panel.getBoundingClientRect();
                if (!replayRectsOverlap(rect, targetRect)) continue;
                const panelRect = replayPanelRectInArea(panel, area);
                const targetLeft = Math.max(20, area.width - panelRect.width - 22 - (moved * 24));
                const targetTop = Math.max(10, 14 + (moved * 28));
                await replayDragWindowToRect(panel, {
                    left: targetLeft,
                    top: targetTop,
                    width: panelRect.width,
                    height: panelRect.height
                }, 'Move window away');
                moved += 1;
                await replaySleep(220, 420);
            }
        }

        async function replayCloseWindowPanel(panel, label = 'Close window') {
            if (!panel || panel.classList.contains('files-hidden')) return;
            const closeBtn = panel.querySelector('.window-action-group .window-action-btn:last-child');
            if (closeBtn) {
                await animateCursorToElement(closeBtn, {
                    label,
                    click: true,
                    duration: replayRand(280, 700)
                });
                await replaySleep(220, 420);
            }
            if (panel.id === 'previewPanel') {
                closePreviewWindow(true);
            } else if (panel.id === 'fileViewerPanel') {
                closeFileViewerWindow(true);
            } else if (panel.dataset.windowKind === 'dynamic-viewer') {
                closeDynamicWindow(panel.id);
            }
        }

        async function replayCloseDynamicViewerWindows() {
            const panels = Array.from(document.querySelectorAll('[data-window-kind="dynamic-viewer"]'))
                .filter((panel) => !panel.classList.contains('files-hidden'))
                .sort((a, b) => (Number.parseInt(b.style.zIndex || '0', 10) || 0) - (Number.parseInt(a.style.zIndex || '0', 10) || 0));
            for (const panel of panels) {
                await replayCloseWindowPanel(panel, 'Close file window');
            }
        }

        async function replayPersistFile(filePath, content, operation = 'overwrite') {
            const clean = normalizeVirtualPath(filePath || '');
            if (!clean) return false;
            try {
                const resp = await apiFetch('/api/replay/write_file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        file_path: clean,
                        content: String(content || ''),
                        operation: String(operation || 'overwrite')
                    })
                });
                const data = await resp.json();
                return !!data.success;
            } catch (e) {
                return false;
            }
        }

        async function replayReadEventContent(event, preferNew = false) {
            const refs = [];
            if (preferNew) {
                if (event?.media_ref_new?.path) refs.push(event.media_ref_new.path);
            }
            if (event?.media_ref?.path) refs.push(event.media_ref.path);
            if (!preferNew && event?.media_ref_new?.path) refs.push(event.media_ref_new.path);
            if (event?.media_ref_old?.path) refs.push(event.media_ref_old.path);
            if (!refs.length) return '';

            const candidates = [];
            refs.forEach((relPath) => {
                const clean = String(relPath || '').trim().replace(/^\.\//, '');
                if (!clean) return;
                candidates.push(clean);
                if (!clean.startsWith('media/')) {
                    candidates.push(`media/${clean}`);
                }
            });

            for (const relPath of candidates) {
                try {
                    const resp = await apiFetch('/api/replay/read_text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            path: String(relPath || ''),
                            events_path: replaySessionState.events_path || '',
                            max_chars: 2200000
                        })
                    });
                    const data = await resp.json();
                    if (data && data.success) {
                        return String(data.content || '');
                    }
                } catch (e) {}
            }
            return '';
        }

        async function replayFocusSearchAndType(query = '') {
            const search = document.getElementById('sidebarQuickSearch');
            if (!search) return;
            await animateCursorToElement(search, { label: 'Quick locate', click: true, duration: replayRand(300, 700) });
            await replaySleep(200, 380);
            search.focus();
            await replayHumanType(search, String(query || ''), {
                min: 60,
                max: 110,
                pauseEvery: 10,
                pauseMin: 220,
                pauseMax: 360
            });
            await replaySleep(300, 700);
        }

        async function replayNavigateToDirectory(dirPath = '', opts = {}) {
            const cleanDir = normalizeVirtualPath(dirPath || '');
            const shouldOpenHome = opts.openHome !== false;
            const filesPanel = getAppWindow('files');
            const filesReady = !!(filesPanel && filesWindowVisible && !filesPanel.classList.contains('files-hidden'));

            if (filesReady) {
                focusAppWindow('files');
                await replaySleep(200, 420);
            } else if (shouldOpenHome) {
                const homeShortcut = document.querySelector('.desktop-shortcut[title="Home"]');
                if (homeShortcut) {
                    await replayEnsureDesktopShortcutReachable(homeShortcut);
                    await animateCursorToElement(homeShortcut, {
                        label: 'Open Home',
                        click: true,
                        doubleClick: true,
                        duration: replayRand(320, 900)
                    });
                    openDesktopHome();
                    await replaySleep(300, 800);
                } else {
                    openMainFolder('');
                    await replaySleep(260, 560);
                }
            } else {
                openMainFolder(mainFolderPath || '');
                await replaySleep(240, 520);
            }
            if (!cleanDir) {
                openSidebarFolder('');
                openMainFolder('');
                await replaySleep(260, 520);
                return '';
            }

            const parts = cleanDir.split('/').filter(Boolean);
            let current = '';
            for (let i = 0; i < parts.length; i += 1) {
                const part = parts[i];
                current = current ? `${current}/${part}` : part;
                let dirEl = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(current)}"]`);
                if (!dirEl) {
                    expandFolderByPath(current);
                    await replaySleep(320, 680);
                    dirEl = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(current)}"]`);
                }
                if (!dirEl) continue;
                await animateCursorToElement(dirEl, {
                    label: `Open ${part}`,
                    click: true,
                    duration: replayRand(300, 860)
                });
                await replaySleep(260, 540);
                if (!dirEl.classList.contains('open')) {
                    dirEl.click();
                    await replaySleep(300, 700);
                }
                const children = dirEl.nextElementSibling;
                if (children && children.classList.contains('tree-children')) {
                    children.classList.add('expanded');
                }
                openSidebarFolder(current, false);
                await replaySleep(250, 500);
            }
            openMainFolder(cleanDir);
            await replaySleep(280, 620);
            return cleanDir;
        }

        async function replayOpenFilePath(filePath, operation = 'file_read', label = 'Open file', opts = {}) {
            const requested = normalizeReplayPath(filePath);
            if (!requested) return '';
            await replayEnsureTreeReady();
            const clean = replayResolveExistingFilePath(requested) || requested;
            const keepFilesVisible = opts.keepFilesVisible === true;
            const useQuickSearch = opts.useQuickSearch === true;
            const openHome = opts.openHome !== false;
            const panelId = opts.panelId || 'fileViewerPanel';
            const contentId = opts.contentId || '';
            const floating = opts.floating === true;
            const headerHandlers = opts.headerHandlers || null;
            const parent = getParentPath(clean);
            const base = replayFileName(clean);
            const shouldOpenHome = openHome || !filesWindowVisible;
            await replayNavigateToDirectory(parent, { openHome: shouldOpenHome });
            focusAppWindow('files');
            const search = document.getElementById('sidebarQuickSearch');
            if (search && search.value && !useQuickSearch) {
                search.value = '';
                search.dispatchEvent(new Event('input', { bubbles: true }));
                await replaySleep(220, 420);
            }
            if (useQuickSearch) {
                await replayFocusSearchAndType(base);
            }
            let effective = normalizeVirtualPath(clean);

            const pickGridFile = () => {
                let el = document.querySelector(`#previewPanel .nautilus-grid-item.file[data-path="${cssEscapeValue(effective)}"]`);
                if (el) return el;
                const gridFiles = Array.from(document.querySelectorAll('#previewPanel .nautilus-grid-item.file'));
                return gridFiles.find((node) => {
                    const p = String(node.dataset.path || '').trim();
                    return p === effective || p.endsWith(`/${base}`) || p === base;
                }) || null;
            };

            let gridFileEl = pickGridFile();
            if (!gridFileEl) {
                openMainFolder(parent || '');
                await replaySleep(260, 520);
                focusAppWindow('files');
                gridFileEl = pickGridFile();
            }
            if (!gridFileEl) {
                showToast(`File not visible in folder window: ${base || requested}`, 'error');
                return '';
            }

            const gridPath = normalizeVirtualPath(gridFileEl.dataset.path || '');
            if (gridPath) {
                effective = gridPath;
            }
            await animateCursorToElement(gridFileEl, {
                label,
                click: true,
                doubleClick: true,
                duration: replayRand(320, 900)
            });
            await replaySleep(250, 450);

            setSelectedItem(effective, 'file');
            if (search && search.value) {
                search.value = '';
                search.dispatchEvent(new Event('input', { bubbles: true }));
                await replaySleep(220, 420);
            }
            replaySetPathAlias(requested, effective);
            replaySetPathAlias(effective, effective);
            await loadFilePreview(effective, {
                source: 'agent',
                operation,
                panelId,
                contentId,
                windowKind: 'viewer',
                skipMetadata: true,
                floating,
                headerHandlers
            });
            if (panelId === 'fileViewerPanel') {
                setFileViewerVisible(true);
                focusAppWindow('viewer');
            }
            return effective;
        }

        async function replaySimulateTyping(contentLength = 120) {
            const container = document.querySelector('#fileViewerPanel .preview-content');
            if (!container) return;
            const overlay = document.createElement('div');
            overlay.className = 'replay-typing-overlay';
            container.appendChild(overlay);
            const units = Math.min(16, Math.max(4, Math.round((Number(contentLength) || 120) / 280)));
            for (let i = 1; i <= units; i += 1) {
                overlay.textContent = `Typing... ${''.repeat(i)}${'.'.repeat(Math.max(0, units - i))}`;
                await sleepAgent(95);
            }
            overlay.textContent = 'Saved.';
            await sleepAgent(150);
            overlay.remove();
        }

        async function replayScrollByReadRange(event = {}) {
            const wrap = document.querySelector('#fileViewerPanel .viewer-scroll-wrap');
            if (!wrap) return;
            const viewRange = Array.isArray(event.view_range) ? event.view_range : [];
            const start = Math.max(1, Number(viewRange[0] || 1));
            const end = Math.max(start, Number(viewRange[1] || start));
            const denominator = Math.max(end, Number(event.content_length || end), 2);
            const ratio = Math.min(0.94, Math.max(0, (start - 1) / denominator));
            const maxTop = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
            const targetTop = Math.round(maxTop * ratio);
            const startTop = Math.max(0, Number(wrap.scrollTop || 0));
            const rect = wrap.getBoundingClientRect();
            const railX = rect.right - 10;
            await moveAgentCursorTo(railX, rect.top + Math.round(rect.height * 0.2), {
                duration: replayRand(340, 900),
                label: 'Drag scrollbar'
            });
            await replaySleep(220, 420);
            const distance = Math.abs(targetTop - startTop);
            const steps = Math.max(8, Math.min(22, Math.round(distance / Math.max(40, wrap.clientHeight / 8))));
            for (let i = 1; i <= steps; i += 1) {
                const t = i / steps;
                const y = rect.top + Math.round((rect.height * 0.2) + (rect.height * 0.66 * t));
                await moveAgentCursorTo(railX, y, {
                    duration: replayRand(120, 260),
                    label: i === steps ? 'Release' : ''
                });
                wrap.scrollTop = Math.round(startTop + (targetTop - startTop) * t);
                await replaySleep(100, 190);
            }
            const prevOutline = wrap.style.boxShadow;
            wrap.style.boxShadow = 'inset 0 0 0 2px rgba(66, 153, 225, 0.65)';
            const holdMs = 600 + Math.min(2200, Math.max(0, end - start) * 24);
            await sleepAgent(holdMs);
            wrap.style.boxShadow = prevOutline;
        }

        async function replayTypeIntoSearch(query = '') {
            const search = document.getElementById('sidebarQuickSearch');
            if (!search) return;
            await animateCursorToElement(search, { label: 'Search files', click: true, duration: replayRand(300, 900) });
            await replaySleep(220, 420);
            search.focus();
            await replayHumanType(search, String(query || '').slice(0, 90), {
                min: 70,
                max: 110,
                pauseEvery: 11,
                pauseMin: 240,
                pauseMax: 380
            });
        }

        async function replayHandleFileSearch(event = {}) {
            await replayEnsureTreeReady();
            const filesPanel = getAppWindow('files');
            if (!filesPanel || !filesWindowVisible || filesPanel.classList.contains('files-hidden')) {
                await replayNavigateToDirectory('', { openHome: true });
            } else {
                focusAppWindow('files');
                await replaySleep(220, 420);
            }

            const searchType = replayNormalizeTrigger(event.search_type || 'glob');
            const query = String(event.query || '').trim();
            const expectedMatches = Math.max(0, Number(event.files_matched || 0));
            const matchedFiles = query ? replayFindMatchingFiles(searchType || 'glob', query) : [];
            const fallbackFiles = listAllVirtualFilePaths(fileData, '', []);
            const filePool = (matchedFiles.length ? matchedFiles : fallbackFiles).filter(Boolean);
            const maxFiles = Math.min(6, Math.max(2, expectedMatches > 0 ? expectedMatches : 3));
            const selectedFiles = filePool.slice(0, maxFiles);

            const dirOrder = [];
            const dirSeen = new Set();
            const appendDir = (dirPath) => {
                const clean = normalizeVirtualPath(dirPath || '');
                if (dirSeen.has(clean)) return;
                dirSeen.add(clean);
                dirOrder.push(clean);
            };

            selectedFiles.forEach((path) => appendDir(getParentPath(path)));
            if (!dirOrder.length) {
                const randomDirs = listAllVirtualDirectoryPaths(fileData, '', []).sort(() => Math.random() - 0.5);
                randomDirs.slice(0, 4).forEach((dirPath) => appendDir(dirPath));
            }
            if (!dirOrder.length) {
                appendDir('');
            }

            const directFilesInDir = (dirPath) => {
                const nodes = getSubtreeByPath(fileData, dirPath || '') || [];
                return nodes
                    .filter((item) => item && item.type === 'file')
                    .map((item) => normalizeVirtualPath(item.path || `${dirPath ? `${dirPath}/` : ''}${item.name || ''}`))
                    .filter(Boolean);
            };

            const nestedFileInDir = (dirPath) => {
                const stack = [...(getSubtreeByPath(fileData, dirPath || '') || [])];
                while (stack.length) {
                    const node = stack.shift();
                    if (!node) continue;
                    if (node.type === 'file') {
                        const p = normalizeVirtualPath(node.path || '');
                        if (p) return p;
                    } else if (node.type === 'directory' && Array.isArray(node.children) && node.children.length) {
                        stack.unshift(...node.children);
                    }
                }
                return '';
            };

            const browseDirs = dirOrder.slice(0, 4);
            for (const dirPath of browseDirs) {
                await replayNavigateToDirectory(dirPath, { openHome: false });
                const grid = document.querySelector('#previewPanel .nautilus-main-grid');
                if (grid) {
                    const passCount = replayRand(1, 2);
                    for (let i = 0; i < passCount; i += 1) {
                        const ratio = Math.min(0.86, 0.22 + i * 0.34);
                        grid.scrollTo({ top: Math.max(0, grid.scrollHeight * ratio), behavior: 'smooth' });
                        await replaySleep(280, 640);
                    }
                }

                let filesToOpen = directFilesInDir(dirPath).slice(0, 2);
                if (!filesToOpen.length) {
                    const nested = nestedFileInDir(dirPath);
                    if (nested) filesToOpen = [nested];
                }

                for (const filePath of filesToOpen) {
                    await replayOpenFilePath(filePath, 'file_read', `Open ${replayFileName(filePath)}`, {
                        keepFilesVisible: true,
                        useQuickSearch: false,
                        openHome: false
                    });
                    await replayScrollByReadRange({
                        view_range: [1, 28],
                        content_length: Math.max(120, Number(event.content_length || 420))
                    });
                    await replaySleep(520, 980);

                    const viewerPanel = getAppWindow('viewer');
                    if (viewerPanel && fileViewerVisible && !viewerPanel.classList.contains('files-hidden')) {
                        await replayCloseWindowPanel(viewerPanel, 'Close file');
                        await replaySleep(420, 780);
                    }

                    focusAppWindow('files');
                    await replaySleep(220, 420);
                }

                const upBtn = document.querySelector('#previewPanel .nautilus-main-toolbar .nav-buttons button:first-child');
                if (upBtn && !upBtn.disabled) {
                    await animateCursorToElement(upBtn, {
                        label: 'Back to parent folder',
                        click: true,
                        duration: replayRand(300, 760)
                    });
                    upBtn.click();
                    await replaySleep(340, 760);
                } else {
                    await replaySleep(260, 520);
                }
            }
        }

        async function replayHandleFileBrowse(event = {}) {
            await replayEnsureTreeReady();
            const dirPath = normalizeReplayPath(event.directory_path || '');
            if (!filesWindowVisible) {
                await replayNavigateToDirectory('', { openHome: true });
            } else {
                focusAppWindow('files');
            }
            await replayNavigateToDirectory(dirPath, { openHome: true });
            openMainFolder(dirPath || '');
            const depth = Math.max(1, Number(event.depth || 1));
            if (depth > 1) {
                const nestedSteps = Math.min(3, depth - 1);
                for (let i = 0; i < nestedSteps; i += 1) {
                    const folderTiles = Array.from(document.querySelectorAll('#previewPanel .nautilus-grid-item.directory'));
                    if (!folderTiles.length) break;
                    const targetTile = folderTiles[Math.min(i, folderTiles.length - 1)];
                    await animateCursorToElement(targetTile, {
                        label: `Browse depth ${i + 2}`,
                        click: true,
                        duration: replayRand(320, 820)
                    });
                    await replaySleep(280, 620);
                    await replaySleep(320, 760);
                }
            }
            const scrollWrap = document.querySelector('#previewPanel .nautilus-main-grid');
            if (scrollWrap) {
                const steps = Math.min(4, depth + 1);
                for (let i = 1; i <= steps; i += 1) {
                    const ratio = Math.min(0.92, (i / (steps + 1)) + 0.08);
                    scrollWrap.scrollTo({ top: Math.max(0, scrollWrap.scrollHeight * ratio), behavior: 'smooth' });
                    await replaySleep(300, 700);
                }
            } else {
                await replaySleep(300, 700);
            }
            await replayShowDialog(
                'info',
                'Browse Directory',
                `Path: ${dirPath || 'Home'}\nDepth: ${depth}\nFiles listed: ${Number(event.files_listed || 0)}`,
                1000
            );
        }

        async function replayHandleDirCreate(event = {}) {
            await replayEnsureTreeReady();
            const target = normalizeReplayPath(event.dir_path || '');
            if (!target) return;
            const depth = Math.max(1, Number(event.depth || target.split('/').length));
            const siblingCount = Math.max(0, Number(event.sibling_count || 0));
            const parts = target.split('/').filter(Boolean);
            let current = '';
            for (let i = 0; i < parts.length; i += 1) {
                current = current ? `${current}/${parts[i]}` : parts[i];
                const exists = findNodeRecord(current);
                if (exists && exists.node?.type === 'directory') continue;
                const parent = getParentPath(current);
                await replayNavigateToDirectory(parent, { openHome: i === 0 });
                const listArea = document.querySelector('#previewPanel .nautilus-main-grid');
                if (listArea && siblingCount > 8) {
                    listArea.scrollTo({ top: Math.max(0, listArea.scrollHeight * 0.25), behavior: 'smooth' });
                    await replaySleep(320, 680);
                }
                const triggerEl = listArea || (parent
                    ? document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(parent)}"]`)
                    : document.querySelector('.desktop-shortcut[title="Home"]'));
                await replayShowContextMenu(triggerEl, ['Open', 'Create Folder', 'Create File', 'Paste'], 1, 'Right click', [900, 1300]);
                const created = createVirtualItem('directory', parent, parts[i]);
                if (!created.success) {
                    showToast(created.error || 'Create folder failed', 'error');
                    return;
                }
                const createdEl = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(created.path)}"]`);
                if (createdEl) {
                    await animateCursorToElement(createdEl, {
                        label: `Open ${parts[i]}`,
                        click: true,
                        doubleClick: i < parts.length - 1,
                        duration: replayRand(320, 860)
                    });
                    await replaySleep(280, 620);
                } else {
                    await replaySleep(300, 620);
                }
            }
            await replayShowDialog(
                'success',
                'Folder Created',
                `Path: ${target}\nDepth: ${depth}\nSiblings: ${siblingCount}`,
                1200
            );
            showToast(`Folder created: ${target}`, 'success');
            await replaySleep(1000, 1600);
        }

        async function replayHandleFileWrite(event = {}) {
            await replayEnsureTreeReady();
            const target = normalizeReplayPath(event.file_path || '');
            if (!target) return;
            const parent = getParentPath(target);
            const baseName = replayFileName(target);
            const operation = String(event.operation || 'overwrite').toLowerCase();
            ensureVirtualDirectoryPath(parent);
            await replayNavigateToDirectory(parent, { openHome: true });
            let exists = !!findNodeRecord(target);
            if (!exists || operation === 'create') {
                const listArea = document.querySelector('#previewPanel .nautilus-main-grid');
                const triggerEl = listArea || (parent
                    ? document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(parent)}"]`)
                    : document.querySelector('.desktop-shortcut[title="Home"]'));
                await replayShowContextMenu(triggerEl, ['Open', 'Create Folder', 'Create File', 'Paste'], 2, 'Right click', [900, 1300]);
                await replayShowDialog('info', 'New File Name', `${baseName}`, 900);
                const created = createVirtualItem('file', parent, baseName);
                if (!created.success && !exists) {
                    showToast(created.error || 'Create file failed', 'error');
                    return;
                }
                const createdEl = document.querySelector(`.tree-item.file[data-path="${cssEscapeValue(target)}"]`);
                if (createdEl) {
                    await animateCursorToElement(createdEl, { label: 'Confirm file', click: true, duration: replayRand(320, 760) });
                    await replaySleep(250, 450);
                }
                await replaySleep(300, 700);
            }
            let content = await replayReadEventContent(event, false);
            if (!content) {
                const targetLen = Math.max(80, Math.min(12000, Number(event.content_length || 120)));
                content = `# ${baseName}\n\nGenerated from replay event.\n`;
                while (content.length < targetLen) {
                    content += `- ${baseName} line ${Math.ceil(content.length / 36)}\n`;
                }
                content = content.slice(0, targetLen);
            }
            await replayOpenFilePath(target, 'file_write', `Open ${baseName}`);
            if (event?.media_ref?.path) {
                await replayShowDialog(
                    'info',
                    'Paste from Media Ref',
                    `Source: ${event.media_ref.path}`,
                    1000
                );
            }
            if (operation === 'overwrite') {
                await replayShowDialog('info', 'Overwrite Mode', 'Ctrl+A  Paste new content', 900);
                await replaySleep(250, 450);
            }
            await replaySimulateTyping(Number(event.content_length || content.length));
            await replayPersistFile(target, content, operation === 'append' ? 'append' : 'overwrite');
            replaySetPathAlias(target, target);
            showToast(`Saved ${baseName}`, 'success');
            await replaySleep(1000, 1400);
        }

        async function replayHandleFileEdit(event = {}) {
            await replayEnsureTreeReady();
            const target = normalizeReplayPath(event.file_path || '');
            if (!target) return;
            if (!findNodeRecord(target)) {
                ensureVirtualDirectoryPath(getParentPath(target));
                createVirtualItem('file', getParentPath(target), target.split('/').pop() || target);
            }
            await replayOpenFilePath(target, 'file_edit', 'Open for edit');
            const diffSummary = String(event.diff_summary || '').trim();
            const keyword = diffSummary ? diffSummary.split(/\s+/).slice(0, 4).join(' ') : replayFileName(target);
            await replayShowDialog('info', 'Find Target Edit Location', `Ctrl+F: ${keyword}`, 1000);
            await replaySleep(300, 600);
            let content = await replayReadEventContent(event, true);
            if (!content) {
                content = `Edited content for ${target}\n\n${event.diff_summary || 'No diff summary available.'}\n`;
            }
            await replayShowDialog(
                'info',
                'Apply Edit',
                `Delete lines: ${Number(event.lines_deleted || 0)}\nAdd lines: ${Number(event.lines_added || 0)}`,
                1200
            );
            const editWrap = document.querySelector('#fileViewerPanel .viewer-scroll-wrap');
            if (editWrap) {
                const prevOutline = editWrap.style.boxShadow;
                editWrap.style.boxShadow = 'inset 0 0 0 2px rgba(229, 62, 62, 0.6)';
                await replaySleep(300, 600);
                editWrap.style.boxShadow = 'inset 0 0 0 2px rgba(56, 161, 105, 0.65)';
                await replaySleep(320, 620);
                editWrap.style.boxShadow = prevOutline;
            }
            await replaySleep(280, 520);
            await replaySimulateTyping(Number((event.lines_added || 0) + (event.lines_deleted || 0)) * 40 || 180);
            await replayPersistFile(target, content, 'overwrite');
            replaySetPathAlias(target, target);
            await replayShowDialog(
                'info',
                'Edit Diff Summary',
                `${event.diff_summary || 'No summary'}\n+${Number(event.lines_added || 0)} / -${Number(event.lines_deleted || 0)}`,
                1300
            );
            showToast('Edit saved', 'success');
            await replaySleep(1000, 1500);
        }

        async function replayHandleFileMove(event = {}) {
            await replayEnsureTreeReady();
            const src = normalizeReplayPath(event.old_path || '');
            const resolved = replayResolveTargetPath(src, event.new_path || '', 'move');
            if (!src || !resolved.targetPath) return;
            ensureVirtualDirectoryPath(resolved.targetDirectory || getParentPath(resolved.targetPath));
            await replayNavigateToDirectory(getParentPath(src), { openHome: true });
            let srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            if (!srcEl) {
                selectFileByPath(src);
                await replaySleep(220, 420);
                srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            }
            if (srcEl) {
                await replayShowContextMenu(srcEl, ['Open', 'Cut', 'Copy', 'Delete'], 1, 'Right click', [800, 1200]);
            }
            await replayNavigateToDirectory(resolved.targetDirectory, { openHome: false });
            const targetEl = resolved.targetDirectory
                ? document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(resolved.targetDirectory)}"]`)
                : document.querySelector('.desktop-shortcut[title="Home"]');
            if (srcEl && targetEl) {
                await replayAnimateDrag(srcEl, targetEl, `Move ${src.split('/').pop()}`);
            } else if (targetEl) {
                await replayShowContextMenu(targetEl, ['Open', 'Paste', 'Create Folder'], 1, 'Right click', [700, 1000]);
            }
            const moved = moveVirtualItemToPath(src, resolved.targetPath);
            if (!moved.success) {
                showToast(moved.error || 'Move failed', 'error');
                return;
            }
            replaySetPathAlias(moved.path, src);
            showToast(`Moved: ${src}  ${moved.path}`, 'success');
            await replayShowDialog(
                'success',
                'Move Complete',
                `Old: ${src}\nNew: ${moved.path}\nTarget dir: ${resolved.targetDirectory || 'Home'}\nDestination depth: ${Number(event.destination_directory_depth || 0)}`,
                1200
            );
            await replaySleep(1000, 1500);
        }

        async function replayHandleFileRename(event = {}) {
            await replayEnsureTreeReady();
            const src = normalizeReplayPath(event.old_path || '');
            const resolved = replayResolveTargetPath(src, event.new_path || '', 'rename');
            if (!src || !resolved.targetPath) return;
            ensureVirtualDirectoryPath(resolved.targetDirectory || getParentPath(resolved.targetPath));
            await replayNavigateToDirectory(getParentPath(src), { openHome: true });
            let srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            if (!srcEl) {
                selectFileByPath(src);
                await replaySleep(220, 420);
                srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            }
            if (srcEl) {
                await animateCursorToElement(srcEl, { label: 'Select item', click: true, duration: replayRand(320, 780) });
                await replaySleep(600, 900);
                await animateCursorToElement(srcEl, { label: 'Rename', click: true, duration: replayRand(320, 780) });
                await replaySleep(250, 500);
            } else {
                const fallback = document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(getParentPath(src))}"]`)
                    || document.querySelector('.desktop-shortcut[title="Home"]');
                await replayShowContextMenu(fallback, ['Open', 'Rename', 'Copy', 'Delete'], 1, 'Right click', [900, 1300]);
            }
            let result;
            if (resolved.isDirectoryTarget) {
                await replayNavigateToDirectory(resolved.targetDirectory, { openHome: false });
                const destDirEl = resolved.targetDirectory
                    ? document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(resolved.targetDirectory)}"]`)
                    : document.querySelector('.desktop-shortcut[title="Home"]');
                if (srcEl && destDirEl) {
                    await replayAnimateDrag(srcEl, destDirEl, `Move ${replayFileName(src)}`);
                }
                result = moveVirtualItemToPath(src, resolved.targetPath);
            } else if (getParentPath(src) === getParentPath(resolved.targetPath)) {
                result = renameVirtualItem(src, replayFileName(resolved.targetPath));
            } else {
                result = moveVirtualItemToPath(src, resolved.targetPath);
            }
            if (!result.success) {
                showToast(result.error || 'Rename failed', 'error');
                return;
            }
            replaySetPathAlias(result.path, src);
            showToast(`Renamed: ${src}  ${result.path}`, 'success');
            await replayShowDialog(
                'info',
                'Naming Pattern Change',
                `${event.naming_pattern_change || 'Name updated'}`,
                1200
            );
            await replaySleep(800, 1200);
        }

        async function replayHandleFileCopy(event = {}) {
            await replayEnsureTreeReady();
            const src = normalizeReplayPath(event.source_path || '');
            const resolved = replayResolveTargetPath(src, event.dest_path || '', 'copy');
            if (!src || !resolved.targetPath) return;
            ensureVirtualDirectoryPath(resolved.targetDirectory || getParentPath(resolved.targetPath));
            await replayNavigateToDirectory(getParentPath(src), { openHome: true });
            let srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            if (!srcEl) {
                selectFileByPath(src);
                await replaySleep(220, 420);
                srcEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(src)}"]`);
            }
            await replayShowContextMenu(srcEl, ['Open', 'Copy', 'Rename', 'Delete'], 1, 'Right click', [800, 1200]);
            replayClipboard.path = src;
            replayClipboard.type = findNodeRecord(src)?.node?.type || 'file';

            await replayNavigateToDirectory(resolved.targetDirectory, { openHome: true });
            const destEl = resolved.targetDirectory
                ? document.querySelector(`.tree-item.directory[data-path="${cssEscapeValue(resolved.targetDirectory)}"]`)
                : document.querySelector('.desktop-shortcut[title="Home"]');
            await replayShowContextMenu(destEl, ['Open', 'Paste', 'New Folder'], 1, 'Right click', [800, 1200]);

            const copied = copyVirtualItemToPath(replayClipboard.path, resolved.targetPath);
            if (!copied.success) {
                showToast(copied.error || 'Copy failed', 'error');
                return;
            }
            if (event.is_backup) {
                const backupName = copied.path.split('/').pop() || '';
                if (!/_backup/i.test(backupName)) {
                    const dated = `${backupName.replace(/(\.[^.]*)?$/, '')}_backup_${new Date().toISOString().slice(0,10).replace(/-/g,'')}${backupName.match(/(\.[^.]*)$/)?.[1] || ''}`;
                    const renamed = renameVirtualItem(copied.path, dated);
                    if (renamed.success) {
                        copied.path = renamed.path;
                    }
                }
            }
            replaySetPathAlias(copied.path, src);
            showToast(`Copied: ${src}  ${copied.path}`, 'success');
            await replaySleep(1000, 1500);
        }

        async function replayHandleFileDelete(event = {}) {
            await replayEnsureTreeReady();
            const target = normalizeReplayPath(event.file_path || '');
            if (!target) return;
            await replayNavigateToDirectory(getParentPath(target), { openHome: true });
            const targetEl = document.querySelector(`.tree-item[data-path="${cssEscapeValue(target)}"]`);
            const temporary = !!event.was_temporary;
            const age = Number(event.file_age_ms || 0);
            if (temporary || age < 60000) {
                if (targetEl) {
                    await animateCursorToElement(targetEl, { label: 'Select', click: true, duration: replayRand(320, 760) });
                    await replaySleep(220, 400);
                    await replayShowDialog('info', 'Delete', 'Press Delete key', 900);
                }
            } else {
                await replayShowContextMenu(targetEl, ['Open', 'Rename', 'Copy', 'Delete'], 3, 'Right click', [900, 1400]);
            }
            const deleted = deleteVirtualItem(target);
            if (!deleted.success) {
                showToast(deleted.error || 'Delete failed', 'error');
                return;
            }
            showToast(`Deleted: ${target}`, 'success');
            await replaySleep(1000, 1600);
        }

        async function replayHandleFileRead(event = {}) {
            const target = normalizeReplayPath(event.file_path || '');
            if (!target) return;
            await replayCloseDynamicViewerWindows();
            await replayOpenFilePath(target, 'file_read', `Open ${target.split('/').pop() || 'file'}`);
            const viewCount = Math.max(1, Number(event.view_count || 1));
            for (let i = 0; i < viewCount; i += 1) {
                await replayScrollByReadRange(event);
                if (i < viewCount - 1) {
                    const wrap = document.querySelector('#fileViewerPanel .viewer-scroll-wrap');
                    if (wrap) {
                        const ratio = Math.min(0.92, 0.2 + (i + 1) * 0.22);
                        wrap.scrollTo({ top: Math.max(0, wrap.scrollHeight * ratio), behavior: 'smooth' });
                    }
                    await replaySleep(300, 600);
                }
            }
            await replaySleep(700, 1200);
        }

        async function replayHandleContextSwitch(event = {}) {
            const fromFile = normalizeReplayPath(event.from_file || '');
            const toFile = normalizeReplayPath(event.to_file || '');
            const trigger = replayNormalizeTrigger(event.trigger || 'tab_click');
            const switchCount = Math.max(1, Number(event.switch_count || 1));
            if (fromFile) {
                await replayOpenFilePath(fromFile, 'context_switch', `Open ${replayFileName(fromFile)}`, {
                    keepFilesVisible: true,
                    useQuickSearch: false,
                    openHome: true
                });
                await replayArrangeFilesAndViewerSplit();
            }
            const sequence = [];
            if (toFile) {
                for (let i = 0; i < switchCount; i += 1) {
                    sequence.push(i % 2 === 0 ? toFile : (fromFile || toFile));
                }
            }
            for (let i = 0; i < switchCount; i += 1) {
                const filesHeader = document.querySelector('#previewPanel .preview-header h2');
                if (filesHeader) {
                    await animateCursorToElement(filesHeader, {
                        label: 'Back to folder window',
                        click: true,
                        duration: replayRand(300, 760)
                    });
                }
                await replaySleep(260, 520);

                const nextFile = sequence[i] || toFile || fromFile;
                if (nextFile) {
                    if (fromFile && normalizeVirtualPath(nextFile) === normalizeVirtualPath(fromFile)) {
                        const viewerPanel = getAppWindow('viewer');
                        const focusEl = viewerPanel?.querySelector('.preview-header h2') || viewerPanel;
                        if (focusEl) {
                            await animateCursorToElement(focusEl, {
                                label: `Focus ${replayFileName(fromFile)}`,
                                click: true,
                                duration: replayRand(300, 740)
                            });
                            await replaySleep(260, 520);
                        }
                    } else {
                        let altPanel = replayFindDynamicViewerByPath(nextFile);
                        if (!altPanel) {
                            altPanel = await replayOpenDynamicViewer(nextFile, 'context_switch', {
                                openViaExplorer: true,
                                openHome: false
                            });
                        } else {
                            const altHead = altPanel.querySelector('.preview-header h2') || altPanel;
                            await animateCursorToElement(altHead, {
                                label: `Focus ${replayFileName(nextFile)}`,
                                click: true,
                                duration: replayRand(300, 740)
                            });
                            await replaySleep(260, 520);
                        }
                        const sourcePanel = getAppWindow('viewer');
                        if (sourcePanel && altPanel) {
                            await replayArrangeDualViewerPanels(sourcePanel, altPanel);
                        }
                    }
                }
                if (!toFile) {
                    await replayArrangeFilesAndViewerSplit();
                }

                if (trigger.includes('search')) {
                    await replayTypeIntoSearch(replayFileName(toFile || nextFile));
                } else if (trigger.includes('error')) {
                    await replayShowDialog('error', 'Jump from Error', 'Open problem item and navigate', 1100);
                } else if (trigger.includes('definition') || trigger.includes('reference')) {
                    await replayShowDialog('info', 'Go to Definition', 'Ctrl+Click reference symbol', 900);
                }
                if (i < switchCount - 1) {
                    await replaySleep(250, 500);
                }
            }
            await replaySleep(700, 1200);
        }

        async function replayHandleCrossFileReference(event = {}) {
            const source = normalizeReplayPath(event.source_file || '');
            const target = normalizeReplayPath(event.target_file || '');
            if (!source || !target) return;
            await replayOpenFilePath(source, 'cross_file_reference', `Open ${replayFileName(source)}`, {
                keepFilesVisible: true,
                useQuickSearch: false,
                openHome: true
            });
            await replayArrangeFilesAndViewerSplit();

            const filesHeader = document.querySelector('#previewPanel .preview-header h2');
            if (filesHeader) {
                await animateCursorToElement(filesHeader, {
                    label: 'Back to folder window',
                    click: true,
                    duration: replayRand(300, 760)
                });
                await replaySleep(260, 520);
            }

            const leftPanel = getAppWindow('viewer');
            let rightPanel = replayFindDynamicViewerByPath(target);
            if (!rightPanel) {
                rightPanel = await replayOpenDynamicViewer(target, 'cross_file_reference', {
                    openViaExplorer: true,
                    openHome: false
                });
            } else {
                const rightHead = rightPanel.querySelector('.preview-header h2') || rightPanel;
                await animateCursorToElement(rightHead, {
                    label: `Focus ${replayFileName(target)}`,
                    click: true,
                    duration: replayRand(300, 740)
                });
                await replaySleep(260, 520);
            }
            if (!leftPanel || !rightPanel) return;
            await replayArrangeDualViewerPanels(leftPanel, rightPanel);

            const leftWrap = leftPanel.querySelector('.viewer-scroll-wrap');
            const rightWrap = rightPanel.querySelector('.viewer-scroll-wrap');
            const leftFocus = leftPanel.querySelector('.preview-content') || leftPanel;
            const rightFocus = rightPanel.querySelector('.preview-content') || rightPanel;
            const leftPoint = getElementCenterPoint(leftFocus);
            const rightPoint = getElementCenterPoint(rightFocus);
            const passes = 4;
            for (let i = 0; i < passes; i += 1) {
                if (leftPoint) {
                    await moveAgentCursorTo(leftPoint.x + replayRand(-18, 16), leftPoint.y + replayRand(-42, 40), {
                        duration: replayRand(460, 980),
                        label: 'Read source'
                    });
                    if (leftWrap) {
                        leftWrap.scrollBy({ top: replayRand(35, 95), behavior: 'smooth' });
                    }
                    await replaySleep(520, 980);
                }
                if (rightPoint) {
                    await moveAgentCursorTo(rightPoint.x + replayRand(-18, 16), rightPoint.y + replayRand(-42, 40), {
                        duration: replayRand(520, 1020),
                        label: 'Compare target'
                    });
                    if (rightWrap) {
                        rightWrap.scrollBy({ top: replayRand(28, 90), behavior: 'smooth' });
                    }
                    await replaySleep(560, 1040);
                }
            }
            await replaySleep(700, 1200);
        }

        async function replayHandleErrorEncounter(event = {}) {
            const severity = replayNormalizeTrigger(event.severity || 'error');
            const prefix = severity.includes('warn')
                ? ''
                : (severity.includes('info') ? '' : '');
            await replayShowDialog(
                'error',
                `${prefix} ${event.error_type || 'unknown'}`,
                `Severity: ${event.severity || 'n/a'}\nContext: ${event.context || ''}`,
                1600
            );
        }

        async function replayHandleErrorResponse(event = {}) {
            const strategy = replayNormalizeTrigger(event.strategy || 'rethink');
            const latency = Math.max(120, Number(event.latency_ms || 400));
            if (strategy === 'retry') {
                await replayShowDialog('info', 'Error Response', 'Click Retry', 1100);
                await replaySleep(260, 520);
                await replayShowDialog('info', 'Retrying...', `Waiting ${latency} ms`, Math.min(2600, latency));
                showToast('Retry complete', 'success');
                await replaySleep(1000, 1400);
                return;
            }
            if (strategy === 'skip') {
                await replayShowDialog('info', 'Error Response', 'Click Skip and continue', 1200);
                await replayShowDialog('success', 'Skipped', `Latency: ${latency} ms`, Math.min(2200, latency + 500));
                await replaySleep(1000, 1300);
                return;
            }
            await replayShowDialog('info', 'Error Response', 'Rethink and change approach', 1400);
            await replaySleep(260, 520);
            await replayShowDialog('info', 'Applying New Plan', `Latency: ${latency} ms`, Math.min(2800, latency + 700));
            showToast('New strategy applied', 'success');
            await replaySleep(1000, 1400);
        }

        async function handleReplayEvent(packet = {}) {
            const event = packet.event || {};
            const eventType = String(event.event_type || '').trim();
            if (!eventType) return;
            const prevType = replayLastHandledEventType;
            replayLastHandledEventType = eventType;
            if (packet.events_path) {
                replaySessionState.events_path = String(packet.events_path);
            }
            await replayEnsureTreeReady();
            const index = Number(packet.index || 0) + 1;
            const total = Number(packet.total || replaySessionState.events_total || 0);
            showAgentActionBanner(`[${index}/${total}] ${eventType}`, 1800);

            if (eventType === 'file_search') {
                if (prevType === 'file_search') {
                    await replaySleep(120, 220);
                    return;
                }
                await replayHandleFileSearch(event);
            }
            else if (eventType === 'file_browse') await replayHandleFileBrowse(event);
            else if (eventType === 'dir_create') await replayHandleDirCreate(event);
            else if (eventType === 'file_write') await replayHandleFileWrite(event);
            else if (eventType === 'file_edit') await replayHandleFileEdit(event);
            else if (eventType === 'file_move') await replayHandleFileMove(event);
            else if (eventType === 'file_rename') await replayHandleFileRename(event);
            else if (eventType === 'file_copy') await replayHandleFileCopy(event);
            else if (eventType === 'file_delete') await replayHandleFileDelete(event);
            else if (eventType === 'file_read') await replayHandleFileRead(event);
            else if (eventType === 'context_switch') await replayHandleContextSwitch(event);
            else if (eventType === 'cross_file_reference') await replayHandleCrossFileReference(event);
            else if (eventType === 'error_encounter') await replayHandleErrorEncounter(event);
            else if (eventType === 'error_response') await replayHandleErrorResponse(event);
            hideAgentCursorLater(agentMs(760));
        }

        function formatMetadataDisplay(meta, fallbackPath = '') {
            const safeMeta = meta || {};
            const locationText = String(safeMeta.location || '').trim();
            const hasLatLon = safeMeta.latitude !== null && safeMeta.latitude !== undefined
                && safeMeta.longitude !== null && safeMeta.longitude !== undefined;
            const creationLocation = locationText || (hasLatLon ? `${safeMeta.latitude}, ${safeMeta.longitude}` : 'N/A');

            const baseRows = [
                ['ID', safeMeta.id || 'N/A'],
                ['File Path', safeMeta.file_path || fallbackPath || 'N/A'],
                ['File Type', safeMeta.file_type || 'N/A'],
                ['File Modality', safeMeta.file_modality || 'N/A'],
                ['Creation Time', safeMeta.creation_date || 'N/A'],
                ['Modification Time', safeMeta.modification_date || 'N/A'],
                ['Creation Location', creationLocation]
            ];

            if (hasLatLon) {
                baseRows.push(['Latitude', safeMeta.latitude]);
                baseRows.push(['Longitude', safeMeta.longitude]);
            }

            return baseRows;
        }

        function renderMetadataCards(meta, fallbackPath = '') {
            const rows = formatMetadataDisplay(meta, fallbackPath);
            const filePath = String(meta?.file_path || fallbackPath || 'N/A');
            return `
                <div class="metadata-sheet">
                    <div class="metadata-sheet-head">
                        <span>Properties</span>
                        <span>${escapeHtml(filePath.split('/').pop() || 'File')}</span>
                    </div>
                    <div class="metadata-sheet-body">
                        ${rows.map(([label, value]) => `
                            <div class="metadata-row">
                                <div class="metadata-label">${escapeHtml(String(label))}</div>
                                <div class="metadata-value">${escapeHtml(String(value ?? 'N/A'))}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Update preview panel from file operation
        function updatePreviewFromOperation(data) {
            const { operation, file_path } = data;
            const source = data.source || 'api';
            const fileName = file_path ? file_path.split('/').pop() : '';
            const isFolderOp = operation === 'list_files' || operation === 'change_dir';
            const panel = document.getElementById(isFolderOp ? 'previewPanel' : 'fileViewerPanel');
            if (source === 'agent') {
                enforceAgentSingleActiveWindow(isFolderOp ? 'files' : 'viewer');
            }
            if (isFolderOp) {
                if (!filesWindowVisible) {
                    setFilesWindowVisible(true);
                }
            } else {
                if (!fileViewerVisible) {
                    setFileViewerVisible(true);
                }
            }
            setPreviewWindowLifecycle(operation, source, file_path);
            const panelKind = isFolderOp ? 'files' : 'viewer';

            // Create preview header if needed
            const createPreviewLayout = () => {
                panel.innerHTML = `
                    ${renderPreviewHeader(fileName || operation, operation, source, panelKind)}
                    <div class="preview-body">
                        <div class="preview-content" id="previewContent"></div>
                    </div>
                `;
                return document.getElementById('previewContent');
            };

            let content = document.getElementById('previewContent');
            if (!content || !panel.querySelector('.preview-header')) {
                content = createPreviewLayout();
            } else {
                const header = panel.querySelector('.preview-header');
                if (header) {
                    header.outerHTML = renderPreviewHeader(fileName || operation, operation, source, panelKind);
                }
                content = document.getElementById('previewContent');
            }

            if (!data.success) {
                const errorMsg = data.error || 'Operation failed';
                content.innerHTML = `
                    <h3 style="color: var(--accent-red); margin-bottom: 12px;">&#x2717; ${operation}</h3>
                    <p style="color: var(--text-secondary);">${escapeHtml(errorMsg)}</p>
                `;
                return;
            }

            // Update content based on operation type
            if (operation === 'return_txt') {
                if (file_path) {
                    const cleanPath = file_path
                        .replace(/^\/hippocamp\/data\/?/, '')
                        .replace(/^data\/?/, '')
                        .replace(/\/$/, '');
                    const ext = cleanPath.includes('.') ? cleanPath.split('.').pop().toLowerCase() : '';
                    setSelectedItem(cleanPath, 'file');
                    selectFileByPath(cleanPath);
                    loadFilePreview(cleanPath, {
                        source,
                        operation: 'return_txt',
                        headerOperation: `return_txt  ${getAppNameByExt(ext)}`,
                        panelId: 'fileViewerPanel',
                        windowKind: 'viewer'
                    });
                    return;
                }
                const displayText = data.data_preview ? escapeHtml(data.data_preview) : formatJSON(data.data || {});
                content.innerHTML = buildPreviewAppFrame('Text Editor', fileName || 'Result', `<pre>${displayText}</pre>`);
            } else if (operation === 'return_img') {
                if (file_path) {
                    const cleanPath = file_path
                        .replace(/^\/hippocamp\/data\/?/, '')
                        .replace(/^data\/?/, '')
                        .replace(/\/$/, '');
                    const ext = cleanPath.includes('.') ? cleanPath.split('.').pop().toLowerCase() : '';
                    setSelectedItem(cleanPath, 'file');
                    selectFileByPath(cleanPath);
                    loadFilePreview(cleanPath, {
                        source,
                        operation: 'return_img',
                        headerOperation: `return_img  ${getAppNameByExt(ext)}`,
                        panelId: 'fileViewerPanel',
                        windowKind: 'viewer'
                    });
                    return;
                }
                const rawPaths = data.image_paths && data.image_paths.length ? data.image_paths : [data.image_path];
                const paths = normalizeImagePaths(rawPaths);
                if (paths.length) {
                    content.innerHTML = buildPreviewAppFrame('Image Viewer', fileName || 'Image', `
                        <div class="image-controls">
                            <button id="prevImageBtn">&#x25C0;</button>
                            <span id="pageLabel">Page 1 / ${paths.length}</span>
                            <button id="nextImageBtn">&#x25B6;</button>
                            <div style="flex: 1"></div>
                            <button id="zoomOutBtn">-</button>
                            <input id="imageZoomRange" type="range" min="0.5" max="3" step="0.1" value="1">
                            <button id="zoomInBtn">+</button>
                            <span id="zoomLabel">100%</span>
                        </div>
                        <div style="overflow: auto;">
                            <img id="pagedImage" class="zoomed-image" src="" alt="Generated image">
                        </div>
                    `);
                    initImageZoom(1);
                    initImagePager(paths);
                } else {
                    content.innerHTML = buildPreviewAppFrame('Image Viewer', fileName || 'Image', `<p>No image preview available.</p>`);
                }
            } else if (operation === 'return_metadata') {
                const meta = data.metadata || {};
                const entries = Object.entries(meta);
                content.innerHTML = buildPreviewAppFrame(
                    'Properties',
                    fileName || 'Metadata',
                    entries.length ? renderMetadataCards(meta, file_path || selectedFile || '') : `<p style="color: var(--text-muted);">No metadata available.</p>`
                );
            } else if (operation === 'return_ori' && (data.original_path || data.file_path)) {
                const oriPath = data.original_path || data.file_path;
                const hasPreview = !!data.file_b64_preview;
                const truncated = !!data.truncated;
                const previewText = hasPreview ? escapeHtml(data.file_b64_preview) : '';
                const cleanServePath = (file_path || '')
                    .replace(/^\/hippocamp\/data\/?/, '')
                    .replace(/^data\/?/, '');
                const openPath = cleanServePath ? encodePath(cleanServePath) : '';
                const ext = cleanServePath.includes('.') ? cleanServePath.split('.').pop().toLowerCase() : '';
                const imagePreviewExts = ['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp'];
                const iframePreviewExts = ['pdf', 'txt', 'md', 'json', 'csv', 'log', 'html', 'htm'];

                if (cleanServePath) {
                    setSelectedItem(cleanServePath, 'file');
                    selectFileByPath(cleanServePath);
                    loadFilePreview(cleanServePath, {
                        source,
                        operation: 'return_ori',
                        headerOperation: `return_ori  ${getAppNameByExt(ext)}`,
                        panelId: 'fileViewerPanel',
                        windowKind: 'viewer'
                    });
                    return;
                }

                content.innerHTML = `
                    <h3 style="color: var(--accent-yellow); margin-bottom: 12px;">&#x1F4CE; Original File - ${fileName}</h3>
                    <p style="color: var(--text-secondary); margin-bottom: 10px;">Path: <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px;">${oriPath}</code></p>
                    ${openPath ? `
                        <div style="margin-bottom: 10px; display: flex; gap: 8px; align-items: center;">
                            <button class="toolbar-btn" onclick="openOriginalFile('${openPath}')">Open file</button>
                        </div>
                    ` : ``}
                    ${openPath && imagePreviewExts.includes(ext) ? `
                        <div style="margin-bottom: 12px; overflow: auto; border-radius: 8px;">
                            <img src="/api/serve_file/${openPath}" alt="${escapeHtml(cleanServePath)}">
                        </div>
                    ` : ``}
                    ${openPath && iframePreviewExts.includes(ext) ? `
                        <iframe src="/api/serve_file/${openPath}" style="width: 100%; min-height: 360px; border: 1px solid var(--border-color); border-radius: 8px; background: rgba(0,0,0,0.2); margin-bottom: 10px;"></iframe>
                    ` : ``}
                    ${hasPreview ? `
                        <div style="margin-bottom: 10px; display: flex; gap: 8px; align-items: center;">
                            <button class="toolbar-btn" onclick="openFullReturnOri('${encodePath(file_path || cleanServePath)}')">Open full JSON</button>
                            ${truncated ? `<span style="color: var(--text-muted); font-size: 12px;">Preview truncated</span>` : ``}
                        </div>
                        <pre class="json-viewer">${previewText}</pre>
                    ` : ``}
                `;
            } else if (operation === 'list_files') {
                if (data.flat_files && data.flat_files.length > 0) {
                    const treeText = buildListTreeText(file_path || '', null, data.flat_files || []);
                    renderListTreePanel(file_path || '', treeText, source, data.flat_files.length);
                } else {
                    const subtree = getSubtreeByPath(fileData, file_path || '');
                    const treeText = buildListTreeText(file_path || '', subtree);
                    const countFromTree = countFilesRecursive(subtree || []);
                    renderListTreePanel(file_path || '', treeText, source, countFromTree);
                }
                return;
            } else if (operation === 'view_file' && data.content) {
                // Show file content from cat/head/tail
                content.innerHTML = `
                    <h3 style="color: var(--accent-green); margin-bottom: 16px;">
                        <span style="color: var(--accent-yellow);">$ ${data.bash_command || 'cat'}</span> ${fileName}
                    </h3>
                    <pre style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; overflow: auto; max-height: 60vh; font-family: 'JetBrains Mono', monospace; font-size: 13px; white-space: pre-wrap;">${escapeHtml(data.content)}</pre>
                `;
            } else if (operation === 'change_dir') {
                // Expand the target directory
                expandFolderByPath(file_path || '');
                // Update breadcrumb
                document.getElementById('currentPath').innerHTML = `<span class="path">${file_path || '/'}</span>`;
            } else if (operation === 'file_info') {
                // Show file info from stat/file command
                if (data.content) {
                    content.innerHTML = `
                        <h3 style="color: var(--accent-cyan); margin-bottom: 16px;">&#x2139; File Info - ${fileName}</h3>
                        <pre style="background: rgba(0,0,0,0.3); padding: 16px; border-radius: 10px; font-family: 'JetBrains Mono', monospace; font-size: 13px;">${escapeHtml(data.content)}</pre>
                    `;
                }
            }
        }

        function updateConnectionStatus(state) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('connectionStatus');
            const status = state === true ? 'connected' : (state || 'disconnected');
            if (status === 'connected') {
                dot.classList.remove('disconnected');
                text.textContent = 'Connected';
            } else if (status === 'polling') {
                dot.classList.remove('disconnected');
                text.textContent = 'Polling';
            } else {
                dot.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }

        function getContentAreaWidth() {
            const area = document.querySelector('.content-area');
            return Math.max(780, area ? area.clientWidth : window.innerWidth);
        }

        function applyPreviewWidth(width, isUserSized = false) {
            const panel = document.getElementById('previewPanel');
            if (!panel) return;
            const areaWidth = getContentAreaWidth();
            const minWidth = 380;
            const maxWidth = terminalVisible ? Math.max(420, areaWidth - 360) : Math.max(520, areaWidth - 40);
            const next = Math.max(minWidth, Math.min(maxWidth, Number(width) || minWidth));
            panel.style.width = `${next}px`;
            panel.style.flex = `0 0 ${next}px`;
            panel.classList.add('preview-resized');
            if (isUserSized) {
                panel.dataset.userSized = '1';
            }
        }

        function clearPreviewWidth() {
            const panel = document.getElementById('previewPanel');
            if (!panel) return;
            panel.style.width = '';
            panel.style.flex = '';
            panel.classList.remove('preview-resized');
            delete panel.dataset.userSized;
        }

        function setFileViewerVisible(visible) {
            fileViewerVisible = !!visible;
            const panel = document.getElementById('fileViewerPanel');
            const dockBtn = document.getElementById('dockFilesBtn');
            if (panel) {
                panel.classList.toggle('files-hidden', !fileViewerVisible);
                if (fileViewerVisible) {
                    ensureWindowGeometry('viewer');
                    if (windowRuntime.viewer.maximized) {
                        panel.classList.add('window-maximized');
                    }
                    focusAppWindow('viewer');
                }
            }
            if (dockBtn) {
                dockBtn.classList.toggle('active', filesWindowVisible || fileViewerVisible);
            }
            if (fileViewerVisible) {
                hideDockWindowMenu();
            }
            updateDockBadges();
        }

        function closeFileViewerWindow(fromAuto = false) {
            setFileViewerVisible(false);
            if (previewWindowState.windowKind === 'viewer') {
                previewWindowState = {
                    isOpen: false,
                    source: '',
                    operation: '',
                    filePath: '',
                    windowKind: 'files',
                    autoCloseAfterCommand: null
                };
            }
            if (!fromAuto) {
                showToast('File closed', 'info');
            }
        }

        function setFilesWindowVisible(visible) {
            filesWindowVisible = !!visible;
            const panel = document.getElementById('previewPanel');
            const toggleBtn = document.getElementById('filesToggleBtn');
            const dockBtn = document.getElementById('dockFilesBtn');

            if (panel) {
                panel.classList.toggle('files-hidden', !filesWindowVisible);
                if (filesWindowVisible) {
                    ensureWindowGeometry('files');
                    if (windowRuntime.files.maximized) {
                        panel.classList.add('window-maximized');
                    }
                    focusAppWindow('files');
                }
            }
            if (toggleBtn) {
                toggleBtn.textContent = filesWindowVisible ? 'Hide Files' : 'Show Files';
            }
            if (dockBtn) {
                dockBtn.classList.toggle('active', filesWindowVisible || fileViewerVisible);
            }
            if (filesWindowVisible) {
                hideDockWindowMenu();
            }
            updateDockBadges();
        }

        function toggleFilesWindow() {
            if (filesWindowVisible) {
                minimizeAppWindow('files');
                return;
            }
            openMainFolder(mainFolderPath || '');
        }

        function resizeFilesWindow(delta) {
            const panel = document.getElementById('previewPanel');
            if (!panel) return;
            if (!filesWindowVisible) {
                setFilesWindowVisible(true);
            }
            const current = panel.offsetWidth || parseInt(getComputedStyle(panel).width, 10) || Math.round(getContentAreaWidth() * 0.58);
            const next = current + delta;
            applyPreviewWidth(next, true);
            try {
                localStorage.setItem('hippocamp_files_width', panel.style.width);
            } catch (e) {}
        }

        function setTerminalVisible(visible) {
            terminalVisible = !!visible;
            const panel = document.getElementById('terminalPanel');
            const toggleBtn = document.getElementById('terminalToggleBtn');
            const dockBtn = document.getElementById('dockTerminalBtn');
            if (panel) {
                panel.classList.toggle('terminal-hidden', !terminalVisible);
                if (terminalVisible) {
                    ensureWindowGeometry('terminal');
                    if (windowRuntime.terminal.maximized) {
                        panel.classList.add('window-maximized');
                    }
                    focusAppWindow('terminal');
                }
            }
            if (toggleBtn) {
                toggleBtn.textContent = terminalVisible ? 'Hide Terminal' : 'Show Terminal';
            }
            if (dockBtn) {
                dockBtn.classList.toggle('active', terminalVisible);
            }
            if (terminalVisible) {
                hideDockWindowMenu();
            }
            updateDockBadges();
        }

        function toggleTerminalPanel() {
            if (terminalVisible) {
                minimizeAppWindow('terminal');
            } else {
                setTerminalVisible(true);
            }
        }

        function setSidebarVisible(visible) {
            sidebarVisible = !!visible;
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggleBtn');
            if (sidebar) {
                sidebar.classList.toggle('sidebar-collapsed', !sidebarVisible);
            }
            if (toggleBtn) {
                toggleBtn.textContent = sidebarVisible ? 'Hide Sidebar' : 'Show Sidebar';
            }
            try {
                localStorage.setItem('hippocamp_sidebar_visible', sidebarVisible ? '1' : '0');
            } catch (e) {}
        }

        function toggleSidebarPanel() {
            setSidebarVisible(!sidebarVisible);
        }

        function setFolderIconSize(size) {
            const next = Math.max(28, Math.min(74, Number(size) || 40));
            folderIconSize = next;
            document.documentElement.style.setProperty('--nautilus-icon-size', `${next}px`);
            try {
                localStorage.setItem('hippocamp_icon_size', String(next));
            } catch (e) {}
        }

        function changeFolderIconSize(delta) {
            setFolderIconSize(folderIconSize + delta);
        }

        function resizeTerminalPanel(delta) {
            const panel = document.getElementById('terminalPanel');
            if (!panel) return;
            terminalUserCustomized = true;
            if (!terminalVisible) {
                setTerminalVisible(true);
            }
            const areaWidth = getContentAreaWidth();
            const current = panel.offsetWidth || parseInt(getComputedStyle(panel).width, 10) || Math.round(areaWidth * 0.42);
            const next = Math.max(320, Math.min(Math.max(560, Math.floor(areaWidth * 0.74)), current + delta));
            panel.style.width = `${next}px`;
            panel.style.flex = `0 0 ${next}px`;
            try {
                localStorage.setItem('hippocamp_terminal_width', panel.style.width);
            } catch (e) {}
        }

        function resizeSidebarPanel(delta) {
            const panel = document.getElementById('sidebar');
            if (!panel) return;
            if (!sidebarVisible) {
                setSidebarVisible(true);
            }
            const current = panel.offsetWidth || parseInt(getComputedStyle(panel).width, 10) || 300;
            const next = Math.max(220, Math.min(620, current + delta));
            panel.style.width = `${next}px`;
            try {
                localStorage.setItem('hippocamp_sidebar_width', panel.style.width);
            } catch (e) {}
        }

        function restoreLayoutPreferences() {
            // Desktop-first startup: no pre-opened windows.
            setSidebarVisible(false);
            setFilesWindowVisible(false);
            setFileViewerVisible(false);
            setTerminalVisible(false);
            minimizedWindows.files = [];
            minimizedWindows.terminal = [];
            Object.keys(minimizedViewerWindows).forEach((key) => delete minimizedViewerWindows[key]);
            Object.keys(dynamicWindowState).forEach((key) => delete dynamicWindowState[key]);
            Object.keys(viewerAppMetaRegistry).forEach((key) => delete viewerAppMetaRegistry[key]);
            const dockDynamicApps = document.getElementById('dockDynamicApps');
            if (dockDynamicApps) {
                dockDynamicApps.innerHTML = '';
            }
            updateDockBadges();
            hideDockWindowMenu();
            try {
                const sz = localStorage.getItem('hippocamp_icon_size');
                if (sz) setFolderIconSize(parseInt(sz, 10));
            } catch (e) {
                setFolderIconSize(40);
            }
        }

        // Load files
        async function loadFiles() {
            try {
                const resp = await apiFetch('/api/files?silent=1');
                const data = await resp.json();

                if (data.success) {
                    fileData = data.files;
                    rebuildVirtualPathMap(fileData);
                    renderFileTree(data.files);
                    renderSidebarDesktopBrowser();
                    document.getElementById('fileCount').textContent = `Files: ${data.total}`;
                    if (!selectedFile && !previewWindowState.isOpen) {
                        renderWelcomePanel();
                    }
                }
            } catch (e) {
                console.error('Failed to load files:', e);
            }
        }

        function sortFolderItems(items) {
            return [...(items || [])].sort((a, b) => {
                const aDir = a.type === 'directory' ? 0 : 1;
                const bDir = b.type === 'directory' ? 0 : 1;
                if (aDir !== bDir) return aDir - bDir;
                return String(a.name || '').localeCompare(String(b.name || ''), undefined, { sensitivity: 'base' });
            });
        }

        function buildMainFolderTiles(items) {
            const sorted = sortFolderItems(items);
            if (!sorted.length) {
                return `<div class="nautilus-empty-note">This folder is empty.</div>`;
            }
            return sorted.map((item) => {
                const itemPath = item.path || item.name || '';
                const icon = item.type === 'directory' ? '&#x1F4C1;' : getFileIcon(item.ext || '');
                return `
                    <button class="nautilus-grid-item ${item.type}" draggable="true"
                        data-path="${escapeHtml(itemPath)}"
                        data-item-type="${escapeHtml(item.type || '')}"
                        ondragstart="startFileDrag('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                        ondragover="onFolderDragOver('${item.type}', event)"
                        ondragleave="onFolderDragLeave(event)"
                        ondrop="onFolderDrop('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                        oncontextmenu="openItemContextMenu('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                        onclick="openMainItem('${encodeURIComponent(itemPath)}', '${item.type}')">
                        <span class="icon">${icon}</span>
                        <span class="name">${escapeHtml(item.name || itemPath)}</span>
                    </button>
                `;
            }).join('');
        }

        function buildTreeLines(items, prefix = '', maxLines = 420, collector = []) {
            if (!Array.isArray(items) || collector.length >= maxLines) return collector;
            const sorted = sortFolderItems(items);
            sorted.forEach((item, idx) => {
                if (collector.length >= maxLines) return;
                const isLast = idx === sorted.length - 1;
                const connector = isLast ? ' ' : ' ';
                const suffix = item.type === 'directory' ? '/' : '';
                collector.push(`${prefix}${connector}${item.name || item.path || 'unknown'}${suffix}`);
                if (item.type === 'directory' && item.children?.length) {
                    const nextPrefix = `${prefix}${isLast ? '    ' : '   '}`;
                    buildTreeLines(item.children, nextPrefix, maxLines, collector);
                }
            });
            return collector;
        }

        function flatPathsToTree(paths = []) {
            const root = [];
            const ensureDir = (list, name, path) => {
                let node = list.find((n) => n.type === 'directory' && n.name === name);
                if (!node) {
                    node = { type: 'directory', name, path, children: [] };
                    list.push(node);
                }
                return node;
            };
            (paths || []).forEach((rawPath) => {
                const clean = normalizeVirtualPath(rawPath);
                if (!clean) return;
                const parts = clean.split('/').filter(Boolean);
                let current = root;
                let currentPath = '';
                parts.forEach((part, idx) => {
                    currentPath = currentPath ? `${currentPath}/${part}` : part;
                    const isLeaf = idx === parts.length - 1;
                    if (isLeaf) {
                        current.push({
                            type: 'file',
                            name: part,
                            path: currentPath,
                            ext: part.includes('.') ? part.split('.').pop().toLowerCase() : ''
                        });
                        return;
                    }
                    const dirNode = ensureDir(current, part, currentPath);
                    current = dirNode.children;
                });
            });
            return root;
        }

        function buildListTreeText(path = '', items = null, flatPaths = null) {
            const clean = normalizeVirtualPath(path);
            const rootLabel = clean ? `Home/${clean}` : 'Home';
            const nodes = Array.isArray(items) ? items : (Array.isArray(flatPaths) ? flatPathsToTree(flatPaths) : []);
            const lines = [rootLabel];
            buildTreeLines(nodes, '', 420, lines);
            if (lines.length === 1) {
                lines.push(' (empty)');
            }
            if (lines.length >= 420) {
                lines.push('... (truncated)');
            }
            return lines.join('\n');
        }

        function formatDisplayPath(path) {
            const clean = (path || '').replace(/^\/+/, '').replace(/\/$/, '');
            return clean ? `Home / ${clean}` : 'Home';
        }

        function renderMainFolderView(path = '', itemsOverride = null, labelOverride = '', source = 'webui', operation = 'list_files', options = {}) {
            if (!filesWindowVisible) {
                setFilesWindowVisible(true);
            }
            mainFolderPath = (path || '')
                .replace(/^\/hippocamp\/data\/?/, '')
                .replace(/^data\/?/, '')
                .replace(/\/$/, '');
            const panel = document.getElementById('previewPanel');
            if (!panel) return;
            const items = Array.isArray(itemsOverride) ? itemsOverride : getSubtreeByPath(fileData, mainFolderPath);
            const displayPath = labelOverride || formatDisplayPath(mainFolderPath);
            const manualWindow = source === 'webui' || source === 'terminal';
            previewWindowState = {
                isOpen: true,
                source,
                operation,
                filePath: mainFolderPath,
                windowKind: 'files',
                autoCloseAfterCommand: manualWindow ? null : commandSequence + 1
            };
            const treeText = String(options.treeText || '').trim();
            panel.innerHTML = `
                ${renderPreviewHeader(displayPath, operation, source, 'files')}
                <div class="preview-body">
                    <div class="nautilus-main-window">
                        <div class="nautilus-main-toolbar">
                            <div class="nav-buttons">
                                <button type="button" onclick="openMainFolder(getParentPath(mainFolderPath))" ${mainFolderPath ? '' : 'disabled'}>&#x2191;</button>
                                <button type="button" onclick="openMainFolder('')">&#x2302;</button>
                            </div>
                            <div class="path-display">${escapeHtml(displayPath)}</div>
                            <div class="view-buttons">
                                <button type="button" onclick="changeFolderIconSize(-4)">A-</button>
                                <button type="button" onclick="changeFolderIconSize(4)">A+</button>
                            </div>
                        </div>
                        <div class="nautilus-main-grid">${buildMainFolderTiles(items)}</div>
                        ${treeText ? `
                            <div class="nautilus-tree-shell">
                                <div class="nautilus-tree-shell-head">Tree View</div>
                                <pre>${escapeHtml(treeText)}</pre>
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
            document.getElementById('currentPath').innerHTML = `<span class="path">${escapeHtml(displayPath)}</span>`;
            focusAppWindow('files');
        }

        function renderListTreePanel(query = '', treeText = '', source = 'agent', fileCount = 0) {
            if (!filesWindowVisible) {
                setFilesWindowVisible(true);
            }
            const panel = document.getElementById('previewPanel');
            if (!panel) return;
            const title = query ? `list_files "${query}"` : 'list_files';
            const text = String(treeText || '').trim() || '(no matches)';
            const stats = fileCount > 0 ? `Matches: ${fileCount}` : 'No matches';
            previewWindowState = {
                isOpen: true,
                source,
                operation: 'list_files',
                filePath: normalizeVirtualPath(query || ''),
                windowKind: 'files',
                autoCloseAfterCommand: source === 'agent' ? commandSequence + 1 : null
            };
            panel.innerHTML = `
                ${renderPreviewHeader(title, 'list_files', source, 'files')}
                <div class="preview-body">
                    <div class="nautilus-tree-shell" style="margin: 0;">
                        <div class="nautilus-tree-shell-head">
                            <span>File Tree</span>
                            <span>${escapeHtml(stats)}</span>
                        </div>
                        <pre>${escapeHtml(text)}</pre>
                    </div>
                </div>
            `;
            document.getElementById('currentPath').innerHTML = `<span class="path">${escapeHtml(query ? `Search / ${query}` : 'Home')}</span>`;
            focusAppWindow('files');
            animateListTreePresentation(source);
        }

        function animateListTreePresentation(source = 'agent') {
            const sourceTag = String(source || 'webui').toLowerCase();
            if (sourceTag !== 'agent') return;
            queueAgentAnimation(async () => {
                enforceAgentSingleActiveWindow('files');
                focusAppWindow('files');
                const treeBody = document.querySelector('#previewPanel .nautilus-tree-shell pre');
                if (!treeBody) return;
                const rect = treeBody.getBoundingClientRect();
                if (!rect || !rect.height) return;

                await moveAgentCursorTo(rect.right - 14, rect.top + 26, {
                    duration: 560,
                    label: 'Browse tree'
                });
                emitAgentRippleAt(rect.right - 14, rect.top + 26, false);
                await sleepAgent(280);

                const maxTop = Math.max(0, treeBody.scrollHeight - treeBody.clientHeight);
                const stops = maxTop > 6
                    ? [0, Math.round(maxTop * 0.28), Math.round(maxTop * 0.62), maxTop, Math.round(maxTop * 0.35)]
                    : [0];
                for (const top of stops) {
                    treeBody.scrollTo({ top, behavior: 'smooth' });
                    await sleepAgent(maxTop > 6 ? 520 : 640);
                }
                hideAgentCursorLater(agentMs(920));
            });
        }

        function openMainItem(encodedPath, itemType) {
            const path = decodeURIComponent(encodedPath || '');
            if (!path) return;
            setSelectedItem(path, itemType || 'file');
            if (itemType === 'directory') {
                openSidebarFolder(path, false);
                renderMainFolderView(path);
                return;
            }
            selectFile(path, null);
        }

        function openMainFolder(path = '') {
            openSidebarFolder(path, false);
            renderMainFolderView(path, null, '', 'webui', 'list_files');
        }

        function openDesktopHome() {
            openMainFolder('');
            logUIAction('ui:desktop_open_home');
        }

        function renderWelcomePanel() {
            setFilesWindowVisible(false);
            previewWindowState = {
                isOpen: false,
                source: '',
                operation: '',
                filePath: '',
                windowKind: 'files',
                autoCloseAfterCommand: null
            };
            hideDockWindowMenu();
            document.getElementById('currentPath').innerHTML = `<span class="path">Desktop</span>`;
        }

        function applyImageZoom(scale) {
            document.querySelectorAll('.image-list img, #pagedImage').forEach(img => {
                img.classList.add('zoomed-image');
                img.style.transform = `scale(${scale})`;
            });
            const label = document.getElementById('zoomLabel');
            if (label) {
                label.textContent = `${Math.round(scale * 100)}%`;
            }
        }

        function initImageZoom(defaultScale = 1) {
            const range = document.getElementById('imageZoomRange');
            if (!range) return;
            range.value = defaultScale.toString();
            applyImageZoom(defaultScale);
            range.oninput = (e) => {
                const scale = parseFloat(e.target.value);
                applyImageZoom(scale);
            };
            const zoomIn = document.getElementById('zoomInBtn');
            const zoomOut = document.getElementById('zoomOutBtn');
            if (zoomIn) {
                zoomIn.onclick = () => {
                    const next = Math.min(3, parseFloat(range.value) + 0.1);
                    range.value = next.toString();
                    applyImageZoom(next);
                };
            }
            if (zoomOut) {
                zoomOut.onclick = () => {
                    const next = Math.max(0.5, parseFloat(range.value) - 0.1);
                    range.value = next.toString();
                    applyImageZoom(next);
                };
            }
        }

        function updatePagedImage() {
            const img = document.getElementById('pagedImage');
            const label = document.getElementById('pageLabel');
            const pageInput = document.getElementById('pageInput');
            if (!img || !label || !currentImagePaths.length) return;
            const path = currentImagePaths[currentImageIndex];
            const imgPath = path.startsWith('/') ? path.substring(1) : path;
            img.src = `/api/serve_image/${encodePath(imgPath)}`;
            label.textContent = `Page ${currentImageIndex + 1} / ${currentImagePaths.length}`;
            if (pageInput) {
                pageInput.max = currentImagePaths.length.toString();
                pageInput.value = (currentImageIndex + 1).toString();
            }
        }

        function initImagePager(paths) {
            currentImagePaths = paths;
            currentImageIndex = 0;
            const prevBtn = document.getElementById('prevImageBtn');
            const nextBtn = document.getElementById('nextImageBtn');
            const pageInput = document.getElementById('pageInput');
            if (prevBtn) {
                prevBtn.onclick = () => {
                    currentImageIndex = Math.max(0, currentImageIndex - 1);
                    updatePagedImage();
                };
            }
            if (nextBtn) {
                nextBtn.onclick = () => {
                    currentImageIndex = Math.min(currentImagePaths.length - 1, currentImageIndex + 1);
                    updatePagedImage();
                };
            }
            if (pageInput) {
                pageInput.onchange = () => {
                    const target = Math.max(1, Math.min(currentImagePaths.length, parseInt(pageInput.value || '1', 10)));
                    currentImageIndex = target - 1;
                    updatePagedImage();
                };
            }
            updatePagedImage();
        }

        function toViewerScopeId(contentId) {
            return String(contentId || 'viewer').replace(/[^a-zA-Z0-9_]/g, '_');
        }

        function getViewerScale(sid) {
            const node = document.getElementById(`viewerZoomTarget_${sid}`) || document.getElementById(`viewerImage_${sid}`) || document.getElementById(`viewerFrame_${sid}`);
            const value = node?.dataset?.scale || '1';
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : 1;
        }

        function setViewerScale(sid, scale) {
            const next = Math.max(0.5, Math.min(2.6, Number(scale) || 1));
            const image = document.getElementById(`viewerImage_${sid}`);
            const frame = document.getElementById(`viewerFrame_${sid}`);
            const text = document.getElementById(`viewerText_${sid}`);
            const video = document.getElementById(`videoPlayer_${sid}`);
            const label = document.getElementById(`viewerZoomLabel_${sid}`);

            if (image) {
                image.dataset.scale = String(next);
                image.style.transform = `scale(${next})`;
                image.style.transformOrigin = 'top left';
            }

            if (frame) {
                frame.dataset.scale = String(next);
                frame.style.transform = `scale(${next})`;
                frame.style.transformOrigin = 'top left';
                frame.style.width = `${100 / next}%`;
                frame.style.minHeight = `${Math.max(520, Math.floor(66 * next))}vh`;
            }

            if (text) {
                text.dataset.scale = String(next);
                text.style.fontSize = `${Math.max(12, Math.min(22, 13 * next))}px`;
                text.style.lineHeight = `${Math.max(1.35, Math.min(2.1, 1.45 * (0.8 + next * 0.2))).toFixed(2)}`;
            }

            if (video) {
                video.dataset.scale = String(next);
                video.style.transform = `scale(${next})`;
                video.style.transformOrigin = 'top left';
                video.style.width = `${Math.max(35, 100 / next)}%`;
            }

            if (label) {
                label.textContent = `${Math.round(next * 100)}%`;
            }
        }

        function viewerZoomBy(sid, delta, triggerEl = null) {
            if (triggerEl) {
                pulseControlEffect(triggerEl, delta > 0 ? 'Zoom in' : 'Zoom out');
            }
            setViewerScale(sid, getViewerScale(sid) + Number(delta || 0));
        }

        function viewerScrollBy(sid, delta, triggerEl = null) {
            if (triggerEl) {
                pulseControlEffect(triggerEl, delta > 0 ? 'Scroll down' : 'Scroll up');
            }
            const wrap = document.getElementById(`viewerScroll_${sid}`);
            if (!wrap) return;
            const target = Math.max(0, Math.min(wrap.scrollHeight, wrap.scrollTop + Number(delta || 0)));
            wrap.scrollTo({ top: target, behavior: 'smooth' });
        }

        function stopViewerAutoBrowse(sid) {
            viewerAutoRunTokens[sid] = (viewerAutoRunTokens[sid] || 0) + 1;
            autoReadRunning = false;
            setAutoReadIndicator('idle', 'Auto Read: Agent only');
        }

        function pickAutoReadPattern(mode = 'document') {
            const modeKey = String(mode || 'document').toLowerCase();
            const buckets = {
                text: ['deep_read', 'skim_down', 'jump_sections', 'bounce_back', 'zoom_scan', 'focus_fullscreen'],
                document: ['deep_read', 'skim_down', 'jump_sections', 'bounce_back', 'zoom_scan', 'focus_fullscreen'],
                pdf: ['deep_read', 'skim_down', 'jump_sections', 'bounce_back', 'zoom_scan', 'focus_fullscreen'],
                image: ['zoom_scan', 'jump_sections', 'bounce_back', 'skim_down', 'focus_fullscreen', 'deep_read'],
                sheet: ['jump_sections', 'skim_down', 'zoom_scan', 'bounce_back', 'deep_read', 'focus_fullscreen'],
                mail: ['deep_read', 'skim_down', 'jump_sections', 'bounce_back', 'focus_fullscreen', 'zoom_scan'],
                calendar: ['jump_sections', 'deep_read', 'skim_down', 'bounce_back', 'zoom_scan', 'focus_fullscreen'],
                'office-pages': ['skim_down', 'jump_sections', 'zoom_scan', 'bounce_back', 'deep_read', 'focus_fullscreen']
            };
            const candidates = buckets[modeKey] || buckets.document;
            return candidates[Math.floor(Math.random() * candidates.length)] || 'skim_down';
        }

        function getAutoReadPatternLabel(pattern) {
            const labels = {
                deep_read: 'Deep Read',
                skim_down: 'Skim Scroll',
                jump_sections: 'Section Jump',
                bounce_back: 'Backtrack',
                zoom_scan: 'Zoom Scan',
                focus_fullscreen: 'Focus Fullscreen'
            };
            return labels[pattern] || 'Auto Read';
        }

        async function runViewerAutoReadPattern(sid, mode, token, pattern) {
            const wrap = document.getElementById(`viewerScroll_${sid}`);
            if (!wrap) return;
            const maxScrollable = Math.max(0, wrap.scrollHeight - wrap.clientHeight);
            const area = wrap.getBoundingClientRect();
            const keepViewerFront = () => {
                if (!fileViewerVisible) {
                    setFileViewerVisible(true);
                }
                setFilesWindowVisible(false);
                focusAppWindow('viewer');
            };
            const moveCursor = async (label = 'Reading...', ratio = 0.5) => {
                await moveAgentCursorTo(area.right - 14, area.top + Math.round(area.height * ratio), {
                    duration: 280,
                    label
                });
                emitAgentRippleAt(area.right - 14, area.top + Math.round(area.height * ratio), false);
            };
            const ensureAlive = () => viewerAutoRunTokens[sid] === token;
            const goToRatio = async (ratio, waitMs = 420, label = 'Reading...') => {
                if (!ensureAlive()) return false;
                keepViewerFront();
                const top = Math.max(0, Math.min(maxScrollable, Math.round(maxScrollable * ratio)));
                wrap.scrollTo({ top, behavior: 'smooth' });
                await moveCursor(label, Math.min(0.9, Math.max(0.12, ratio || 0.5)));
                await sleepAgent(waitMs);
                return ensureAlive();
            };
            const zoomStep = async (delta, waitMs = 260) => {
                if (!ensureAlive()) return false;
                viewerZoomBy(sid, delta);
                await sleepAgent(waitMs);
                return ensureAlive();
            };

            if (maxScrollable <= 2) {
                await zoomStep(0.12, 260);
                await zoomStep(-0.06, 280);
                await zoomStep(-0.06, 260);
                return;
            }

            if (pattern === 'deep_read') {
                const steps = [0.0, 0.12, 0.26, 0.41, 0.56, 0.72, 0.86, 1.0];
                for (const ratio of steps) {
                    if (!(await goToRatio(ratio, 520, 'Reading...'))) return;
                }
                await goToRatio(0.0, 360, 'Back to top');
                return;
            }

            if (pattern === 'jump_sections') {
                const steps = [0.0, 0.35, 0.08, 0.62, 0.22, 0.88, 0.48];
                for (const ratio of steps) {
                    if (!(await goToRatio(ratio, 380, 'Section jump'))) return;
                }
                await goToRatio(0.18, 340, 'Review');
                return;
            }

            if (pattern === 'bounce_back') {
                const steps = [0.0, 0.4, 0.78, 0.58, 0.9, 0.68, 1.0, 0.24];
                for (const ratio of steps) {
                    if (!(await goToRatio(ratio, 360, ratio < 0.5 ? 'Backtrack' : 'Browse'))) return;
                }
                await goToRatio(0.0, 320, 'Done');
                return;
            }

            if (pattern === 'zoom_scan') {
                await goToRatio(0.0, 260, 'Zoom');
                if (!(await zoomStep(0.15, 280))) return;
                if (!(await goToRatio(0.28, 380, 'Inspect'))) return;
                if (!(await zoomStep(0.12, 280))) return;
                if (!(await goToRatio(0.64, 420, 'Inspect'))) return;
                if (!(await zoomStep(-0.14, 260))) return;
                if (!(await goToRatio(1.0, 420, 'Skim end'))) return;
                await zoomStep(-0.13, 260);
                await goToRatio(0.06, 280, 'Summary');
                return;
            }

            if (pattern === 'focus_fullscreen') {
                let toggled = false;
                try {
                    if (!windowRuntime.viewer.maximized) {
                        toggleMaximizeWindow('viewer');
                        toggled = true;
                    }
                } catch (e) {}
                await goToRatio(0.0, 320, 'Focus mode');
                const steps = [0.22, 0.48, 0.72, 1.0];
                for (const ratio of steps) {
                    if (!(await goToRatio(ratio, 420, 'Focused read'))) {
                        if (toggled) toggleMaximizeWindow('viewer');
                        return;
                    }
                }
                await goToRatio(0.32, 300, 'Re-check');
                if (toggled) {
                    toggleMaximizeWindow('viewer');
                    await sleepAgent(260);
                }
                return;
            }

            const steps = [0.0, 0.24, 0.48, 0.72, 0.94];
            for (const ratio of steps) {
                if (!(await goToRatio(ratio, 380, 'Skimming'))) return;
            }
            await goToRatio(0.12, 260, 'Done');
        }

        async function viewerAutoBrowse(sid, mode = 'document', triggerEl = null, forcedPattern = '') {
            if (triggerEl) {
                pulseControlEffect(triggerEl, 'Auto browse');
            }
            stopViewerAutoBrowse(sid);
            const token = viewerAutoRunTokens[sid];
            const pattern = forcedPattern || pickAutoReadPattern(mode);
            autoReadRunning = true;
            autoReadPatternLabel = getAutoReadPatternLabel(pattern);
            setAutoReadIndicator('running', autoReadPatternLabel);
            showAgentActionBanner(`Auto read: ${autoReadPatternLabel}`, 1200);
            await runViewerAutoReadPattern(sid, mode, token, pattern);
            if (viewerAutoRunTokens[sid] === token) {
                autoReadRunning = false;
                setAutoReadIndicator('idle', 'Auto Read: Agent only');
                hideAgentCursorLater(280);
            }
        }

        function toggleAudioPlayback(sid, triggerEl = null) {
            const audio = document.getElementById(`audioPlayer_${sid}`);
            if (!audio) return;
            if (triggerEl) {
                pulseControlEffect(triggerEl, audio.paused ? 'Play audio' : 'Pause audio');
            }
            if (audio.paused) {
                audio.play().catch(() => {});
                showMediaEffect(audio, 'Playing');
            } else {
                audio.pause();
                showMediaEffect(audio, 'Paused');
            }
        }

        function toggleVideoPlayback(sid, triggerEl = null) {
            const video = document.getElementById(`videoPlayer_${sid}`);
            if (!video) return;
            if (triggerEl) {
                pulseControlEffect(triggerEl, video.paused ? 'Play video' : 'Pause video');
            }
            if (video.paused) {
                video.play().catch(() => {});
                showMediaEffect(video, 'Playing');
            } else {
                video.pause();
                showMediaEffect(video, 'Paused');
            }
        }

        function initAudioViewerScoped(sid) {
            const audio = document.getElementById(`audioPlayer_${sid}`);
            const seek = document.getElementById(`audioSeek_${sid}`);
            const current = document.getElementById(`audioCurrentTime_${sid}`);
            const total = document.getElementById(`audioTotalTime_${sid}`);
            if (!audio || !seek || !current || !total) return;
            if (audio.dataset.bound === '1') return;
            audio.dataset.bound = '1';

            audio.addEventListener('loadedmetadata', () => {
                seek.max = String(Math.max(0, Math.floor(audio.duration || 0)));
                total.textContent = formatClock(audio.duration);
            });

            audio.addEventListener('timeupdate', () => {
                if (!seek.matches(':active')) {
                    seek.value = String(Math.max(0, Math.floor(audio.currentTime || 0)));
                }
                current.textContent = formatClock(audio.currentTime);
            });

            seek.addEventListener('input', () => {
                audio.currentTime = Number(seek.value || 0);
            });
        }

        function initVideoViewerScoped(sid) {
            const video = document.getElementById(`videoPlayer_${sid}`);
            const seek = document.getElementById(`videoSeek_${sid}`);
            const current = document.getElementById(`videoCurrentTime_${sid}`);
            const total = document.getElementById(`videoTotalTime_${sid}`);
            if (!video || !seek || !current || !total) return;
            if (video.dataset.bound === '1') return;
            video.dataset.bound = '1';

            video.addEventListener('loadedmetadata', () => {
                seek.max = String(Math.max(0, Math.floor(video.duration || 0)));
                total.textContent = formatClock(video.duration);
            });
            video.addEventListener('timeupdate', () => {
                if (!seek.matches(':active')) {
                    seek.value = String(Math.max(0, Math.floor(video.currentTime || 0)));
                }
                current.textContent = formatClock(video.currentTime);
            });
            seek.addEventListener('input', () => {
                video.currentTime = Number(seek.value || 0);
            });
        }

        async function waitForMediaMetadata(media, timeoutMs = 2600) {
            if (!media) return;
            const hasDuration = Number.isFinite(media.duration) && media.duration > 0;
            if (hasDuration) return;
            await Promise.race([
                new Promise((resolve) => {
                    const done = () => resolve();
                    media.addEventListener('loadedmetadata', done, { once: true });
                    media.addEventListener('canplay', done, { once: true });
                }),
                sleepMs(timeoutMs)
            ]);
        }

        function scheduleViewerExperience(sid, ext, source = 'webui', operation = 'preview') {
            const normalizedExt = String(ext || '').toLowerCase();
            const sourceTag = String(source || 'webui').toLowerCase();
            if (sourceTag !== 'agent') {
                setAutoReadIndicator('manual', 'Auto Read: Manual mode');
                return;
            }

            queueAgentAnimation(async () => {
                enforceAgentSingleActiveWindow('viewer');
                focusAppWindow('viewer');
                await sleepAgent(420);
                const autoBrowseBtn = document.getElementById(`viewerAutoBtn_${sid}`);
                const audioBtn = document.getElementById(`audioPlayBtn_${sid}`);
                const videoBtn = document.getElementById(`videoPlayBtn_${sid}`);
                const maximizeBtn = document.querySelector('#fileViewerPanel .preview-header .window-action-group .window-action-btn:nth-child(2)');
                let toggledWindow = false;
                const maybeMaximizeViewer = async () => {
                    if (!maximizeBtn) return;
                    if (windowRuntime.viewer.maximized) return;
                    await animateCursorToElement(maximizeBtn, { label: 'Maximize window', click: true });
                    maximizeBtn.click();
                    toggledWindow = true;
                    await sleepAgent(640);
                };
                const maybeRestoreViewer = async () => {
                    if (!maximizeBtn || !toggledWindow) return;
                    await animateCursorToElement(maximizeBtn, { label: 'Restore window', click: true });
                    maximizeBtn.click();
                    await sleepAgent(520);
                };
                await maybeMaximizeViewer();

                if (audioBtn && AUDIO_FILE_EXTS.has(normalizedExt)) {
                    const behavior = Math.floor(Math.random() * 3);
                    await animateCursorToElement(audioBtn, { label: 'Play audio', click: true });
                    audioBtn.click();
                    const audio = document.getElementById(`audioPlayer_${sid}`);
                    await waitForMediaMetadata(audio);
                    autoReadRunning = true;
                    setAutoReadIndicator('running', 'Audio');
                    const baseMs = Math.min(22000, Math.max(3000, Math.round((Number(audio?.duration) || 8) * 900)));
                    if (behavior === 1 && audio) {
                        await sleepAgent(Math.round(baseMs * 0.36));
                        audio.currentTime = Math.max(0, Math.min((audio.duration || 0) - 1, (audio.duration || 0) * 0.62));
                        showMediaEffect(audio, 'Seek');
                        await sleepAgent(Math.round(baseMs * 0.32));
                    } else if (behavior === 2 && audio) {
                        await sleepAgent(Math.round(baseMs * 0.24));
                        audio.pause();
                        showMediaEffect(audio, 'Pause');
                        await sleepAgent(780);
                        audio.play().catch(() => {});
                        showMediaEffect(audio, 'Resume');
                        await sleepAgent(Math.round(baseMs * 0.38));
                    } else {
                        await sleepAgent(baseMs);
                    }
                    await animateCursorToElement(audioBtn, { label: 'Pause audio', click: true });
                    audioBtn.click();
                    autoReadRunning = false;
                    setAutoReadIndicator('idle', 'Auto Read: Agent only');
                    await maybeRestoreViewer();
                    hideAgentCursorLater(agentMs(340));
                    return;
                }

                if (videoBtn && VIDEO_FILE_EXTS.has(normalizedExt)) {
                    const behavior = Math.floor(Math.random() * 3);
                    await animateCursorToElement(videoBtn, { label: 'Play video', click: true });
                    videoBtn.click();
                    const video = document.getElementById(`videoPlayer_${sid}`);
                    await waitForMediaMetadata(video);
                    autoReadRunning = true;
                    setAutoReadIndicator('running', 'Video');
                    const baseMs = Math.min(28000, Math.max(3200, Math.round((Number(video?.duration) || 10) * 850)));
                    if (behavior === 1 && video) {
                        await sleepAgent(Math.round(baseMs * 0.28));
                        video.currentTime = Math.max(0, Math.min((video.duration || 0) - 1, (video.duration || 0) * 0.58));
                        showMediaEffect(video, 'Skip ahead');
                        await sleepAgent(Math.round(baseMs * 0.38));
                    } else if (behavior === 2 && video) {
                        await sleepAgent(Math.round(baseMs * 0.26));
                        video.playbackRate = 1.35;
                        showMediaEffect(video, '1.35x');
                        await sleepAgent(Math.round(baseMs * 0.22));
                        video.playbackRate = 1;
                        await sleepAgent(Math.round(baseMs * 0.26));
                    } else {
                        await sleepAgent(baseMs);
                    }
                    await animateCursorToElement(videoBtn, { label: 'Pause video', click: true });
                    videoBtn.click();
                    autoReadRunning = false;
                    setAutoReadIndicator('idle', 'Auto Read: Agent only');
                    await maybeRestoreViewer();
                    hideAgentCursorLater(agentMs(340));
                    return;
                }

                if (autoBrowseBtn) {
                    const pattern = pickAutoReadPattern(normalizedExt);
                    await animateCursorToElement(autoBrowseBtn, { label: `Auto: ${getAutoReadPatternLabel(pattern)}`, click: true });
                    await viewerAutoBrowse(sid, normalizedExt || 'document', autoBrowseBtn, pattern);
                    await maybeRestoreViewer();
                    hideAgentCursorLater(agentMs(420));
                    return;
                }
                setAutoReadIndicator('idle', 'Auto Read: Agent only');
            });
        }

        function normalizeImagePaths(paths) {
            const deduped = Array.from(new Set(paths.filter(Boolean)));
            const hasPaged = deduped.some(p => /_(page|slide|sheet)\d+\.(png|jpg|jpeg)$/i.test(p));
            if (!hasPaged) return deduped;
            return deduped.filter(p => /_(page|slide|sheet)\d+\.(png|jpg|jpeg)$/i.test(p));
        }

        function clearTreeSelection() {
            document.querySelectorAll('.tree-item.selected').forEach(el => el.classList.remove('selected'));
        }

        function goHome() {
            previewWindowState = {
                isOpen: false,
                source: '',
                operation: '',
                filePath: '',
                autoCloseAfterCommand: null
            };
            selectedFile = null;
            selectedItemPath = '';
            selectedItemType = 'file';
            mainFolderPath = '';
            openMainFolder('');
            clearTreeSelection();
            document.getElementById('currentPath').innerHTML = `<span class="path">Home</span>`;
        }

        // Render file tree
        function renderFileTree(items, container = null) {
            if (!container) {
                container = document.getElementById('fileTree');
                container.innerHTML = '';
            }

            items.forEach(item => {
                if (item.type === 'directory') {
                    const dirEl = document.createElement('div');
                    dirEl.className = 'tree-item directory';
                    dirEl.innerHTML = `<span class="icon"></span><span class="name">${item.name}</span>`;
                    dirEl.dataset.path = item.path || item.name;
                    dirEl.setAttribute('draggable', 'true');
                    dirEl.ondragstart = (e) => startFileDrag(encodeURIComponent(dirEl.dataset.path || ''), 'directory', e);
                    dirEl.ondragover = (e) => onFolderDragOver('directory', e);
                    dirEl.ondragleave = (e) => onFolderDragLeave(e);
                    dirEl.ondrop = (e) => onFolderDrop(encodeURIComponent(dirEl.dataset.path || ''), 'directory', e);
                    dirEl.oncontextmenu = (e) => openItemContextMenu(encodeURIComponent(dirEl.dataset.path || ''), 'directory', e);
                    dirEl.onclick = (e) => {
                        e.stopPropagation();
                        setSelectedItem(dirEl.dataset.path || '', 'directory');
                        const children = dirEl.nextElementSibling;
                        if (children) {
                            children.classList.toggle('expanded');
                            dirEl.classList.toggle('open');
                            const state = children.classList.contains('expanded') ? 'open' : 'closed';
                            logUIAction(`ui:toggle_dir ${dirEl.dataset.path} ${state}`);
                        }
                    };
                    container.appendChild(dirEl);

                    if (item.children && item.children.length > 0) {
                        const childContainer = document.createElement('div');
                        childContainer.className = 'tree-children';
                        childContainer.dataset.path = item.path || item.name;
                        container.appendChild(childContainer);
                        renderFileTree(item.children, childContainer);
                    }
                } else {
                    const fileEl = document.createElement('div');
                    fileEl.className = 'tree-item file';
                    fileEl.innerHTML = `<span class="icon"></span><span class="name">${item.name}</span>`;
                    fileEl.dataset.path = item.path;
                    fileEl.dataset.ext = item.ext;
                    fileEl.setAttribute('draggable', 'true');
                    fileEl.ondragstart = (e) => startFileDrag(encodeURIComponent(item.path || ''), 'file', e);
                    fileEl.oncontextmenu = (e) => openItemContextMenu(encodeURIComponent(item.path || ''), 'file', e);
                    fileEl.onclick = () => selectFile(item.path, fileEl);
                    container.appendChild(fileEl);
                }
            });
        }

        function setSelectedItem(path, itemType = 'file') {
            selectedItemPath = normalizeVirtualPath(path || '');
            selectedItemType = itemType || 'file';
            if (selectedItemType === 'file') {
                selectedFile = selectedItemPath;
            }
        }

        function clearDropTargetMarks() {
            document.querySelectorAll('.drop-target').forEach((el) => el.classList.remove('drop-target'));
            document.querySelectorAll('.drag-source').forEach((el) => el.classList.remove('drag-source'));
        }

        function findNodeRecord(path) {
            const cleanPath = normalizeVirtualPath(path);
            if (!cleanPath) return null;
            const parts = cleanPath.split('/').filter(Boolean);
            let children = fileData;
            let node = null;
            let parentChildren = null;
            let idx = -1;
            for (const part of parts) {
                idx = (children || []).findIndex((item) => item.name === part);
                if (idx < 0) return null;
                parentChildren = children;
                node = children[idx];
                children = node.children || [];
            }
            if (!node || !parentChildren) return null;
            return {
                node,
                index: idx,
                parentChildren,
                parentPath: getParentPath(cleanPath),
                path: cleanPath
            };
        }

        function refreshNodePathRecursive(node, nextPath) {
            if (!node) return;
            node.path = nextPath;
            if (node.type === 'file') {
                node.ext = node.name.includes('.') ? node.name.split('.').pop().toLowerCase() : '';
                return;
            }
            (node.children || []).forEach((child) => {
                const childPath = nextPath ? `${nextPath}/${child.name}` : child.name;
                refreshNodePathRecursive(child, childPath);
            });
        }

        function remapVirtualPathKeys(oldBase, newBase) {
            const oldPath = normalizeVirtualPath(oldBase);
            const nextPath = normalizeVirtualPath(newBase);
            if (!oldPath || !nextPath || oldPath === nextPath) return;
            const updates = [];
            Object.keys(virtualPathMap).forEach((key) => {
                if (key === oldPath || key.startsWith(`${oldPath}/`)) {
                    const suffix = key.slice(oldPath.length);
                    updates.push([key, `${nextPath}${suffix}`, virtualPathMap[key]]);
                }
            });
            updates.forEach(([oldKey]) => delete virtualPathMap[oldKey]);
            updates.forEach(([, newKey, value]) => {
                virtualPathMap[newKey] = value;
            });

            const updateTrackedPath = (value) => {
                const clean = normalizeVirtualPath(value);
                if (!clean) return value;
                if (clean === oldPath || clean.startsWith(`${oldPath}/`)) {
                    return `${nextPath}${clean.slice(oldPath.length)}`;
                }
                return value;
            };
            selectedFile = updateTrackedPath(selectedFile);
            selectedItemPath = updateTrackedPath(selectedItemPath);
            mainFolderPath = normalizeVirtualPath(updateTrackedPath(mainFolderPath));
            sidebarCurrentPath = normalizeVirtualPath(updateTrackedPath(sidebarCurrentPath));
        }

        function removeVirtualPathKeysUnder(basePath) {
            const clean = normalizeVirtualPath(basePath);
            if (!clean) return;
            Object.keys(virtualPathMap).forEach((key) => {
                if (key === clean || key.startsWith(`${clean}/`)) {
                    delete virtualPathMap[key];
                }
            });
            if (selectedFile && (selectedFile === clean || selectedFile.startsWith(`${clean}/`))) {
                selectedFile = null;
            }
            if (selectedItemPath && (selectedItemPath === clean || selectedItemPath.startsWith(`${clean}/`))) {
                selectedItemPath = '';
                selectedItemType = 'file';
            }
            if (mainFolderPath && (mainFolderPath === clean || mainFolderPath.startsWith(`${clean}/`))) {
                mainFolderPath = getParentPath(clean);
            }
            if (sidebarCurrentPath && (sidebarCurrentPath === clean || sidebarCurrentPath.startsWith(`${clean}/`))) {
                sidebarCurrentPath = getParentPath(clean);
            }
        }

        function getDefaultTargetDirectory() {
            if (selectedItemPath) {
                if (selectedItemType === 'directory') return selectedItemPath;
                return getParentPath(selectedItemPath);
            }
            if (mainFolderPath) return mainFolderPath;
            if (sidebarCurrentPath) return sidebarCurrentPath;
            return '';
        }

        function validateVirtualName(nameRaw) {
            const name = String(nameRaw || '').trim();
            if (!name) return { ok: false, error: 'Name cannot be empty.' };
            if (name === '.' || name === '..') return { ok: false, error: 'Invalid name.' };
            if (/[\\/]/.test(name)) return { ok: false, error: 'Name cannot contain "/" or "\\".' };
            return { ok: true, name };
        }

        function refreshExplorerViews(focusPath = '') {
            const tree = document.getElementById('fileTree');
            if (tree) {
                renderFileTree(fileData, tree);
            }
            renderSidebarDesktopBrowser(document.getElementById('sidebarQuickSearch')?.value || '');
            if (filesWindowVisible) {
                renderMainFolderView(mainFolderPath || '');
            }
            if (focusPath) {
                selectFileByPath(focusPath);
            }
        }

        function moveVirtualItem(srcPath, targetDirPath) {
            const src = findNodeRecord(srcPath);
            if (!src) return { success: false, error: `Cannot find source: ${srcPath}` };
            const targetPath = normalizeVirtualPath(targetDirPath);
            if (src.node.type === 'directory' && targetPath && (targetPath === src.path || targetPath.startsWith(`${src.path}/`))) {
                return { success: false, error: 'Cannot move a folder into itself.' };
            }
            let targetChildren = fileData;
            if (targetPath) {
                const target = findNodeRecord(targetPath);
                if (!target || target.node.type !== 'directory') {
                    return { success: false, error: `Target folder not found: ${targetPath}` };
                }
                targetChildren = target.node.children || [];
                target.node.children = targetChildren;
            }
            const collision = targetChildren.some((item) => String(item.name || '').toLowerCase() === String(src.node.name || '').toLowerCase());
            if (collision) {
                return { success: false, error: `Name exists in target folder: ${src.node.name}` };
            }
            src.parentChildren.splice(src.index, 1);
            targetChildren.push(src.node);
            const oldPath = src.path;
            const nextPath = targetPath ? `${targetPath}/${src.node.name}` : src.node.name;
            refreshNodePathRecursive(src.node, nextPath);
            remapVirtualPathKeys(oldPath, nextPath);
            refreshExplorerViews(nextPath);
            recordUiTmpOp('move', { from: oldPath, to: nextPath });
            return { success: true, path: nextPath };
        }

        function renameVirtualItem(path, newNameRaw) {
            const cleanPath = normalizeVirtualPath(path);
            const checked = validateVirtualName(newNameRaw);
            if (!cleanPath || !checked.ok) {
                return { success: false, error: 'Invalid path or name.' };
            }
            const nextName = checked.name;
            const ref = findNodeRecord(cleanPath);
            if (!ref) return { success: false, error: `Cannot find item: ${cleanPath}` };
            const collision = ref.parentChildren.some((item, idx) => idx !== ref.index && String(item.name || '').toLowerCase() === nextName.toLowerCase());
            if (collision) {
                return { success: false, error: `Name already exists: ${nextName}` };
            }
            const oldPath = ref.path;
            ref.node.name = nextName;
            const nextPath = ref.parentPath ? `${ref.parentPath}/${nextName}` : nextName;
            refreshNodePathRecursive(ref.node, nextPath);
            remapVirtualPathKeys(oldPath, nextPath);
            refreshExplorerViews(nextPath);
            recordUiTmpOp('rename', { from: oldPath, to: nextPath });
            return { success: true, path: nextPath };
        }

        function createVirtualItem(itemType, targetDirPath, nameRaw) {
            const type = itemType === 'directory' ? 'directory' : 'file';
            const checked = validateVirtualName(nameRaw);
            if (!checked.ok) return { success: false, error: checked.error };
            const name = checked.name;
            const targetPath = normalizeVirtualPath(targetDirPath);
            let targetChildren = fileData;
            if (targetPath) {
                const ref = findNodeRecord(targetPath);
                if (!ref || ref.node.type !== 'directory') {
                    return { success: false, error: `Target folder not found: ${targetPath}` };
                }
                targetChildren = ref.node.children || [];
                ref.node.children = targetChildren;
            }
            const collision = targetChildren.some((item) => String(item.name || '').toLowerCase() === name.toLowerCase());
            if (collision) {
                return { success: false, error: `Name already exists: ${name}` };
            }
            const nextPath = targetPath ? `${targetPath}/${name}` : name;
            const node = type === 'directory'
                ? { type: 'directory', name, path: nextPath, children: [] }
                : {
                    type: 'file',
                    name,
                    path: nextPath,
                    ext: name.includes('.') ? name.split('.').pop().toLowerCase() : ''
                };
            targetChildren.push(node);
            virtualPathMap[nextPath] = nextPath;
            refreshExplorerViews(nextPath);
            setSelectedItem(nextPath, type);
            recordUiTmpOp('create', { type, path: nextPath, parent: targetPath || '' });
            return { success: true, path: nextPath, type };
        }

        function deleteVirtualItem(path) {
            const cleanPath = normalizeVirtualPath(path);
            if (!cleanPath) return { success: false, error: 'Invalid path.' };
            const ref = findNodeRecord(cleanPath);
            if (!ref) return { success: false, error: `Cannot find item: ${cleanPath}` };
            ref.parentChildren.splice(ref.index, 1);
            removeVirtualPathKeysUnder(cleanPath);
            refreshExplorerViews(getParentPath(cleanPath));
            recordUiTmpOp('delete', { path: cleanPath, type: ref.node.type || 'file' });
            return { success: true, path: cleanPath };
        }

        function startFileDrag(encodedPath, itemType, event) {
            const path = decodeURIComponent(encodedPath || '');
            if (!path || !event) return;
            const clean = normalizeVirtualPath(path);
            activeFileDrag = { path: clean, type: itemType || 'file' };
            if (event.dataTransfer) {
                event.dataTransfer.setData('text/plain', clean);
                event.dataTransfer.effectAllowed = 'move';
            }
            event.currentTarget?.classList?.add('drag-source');
            setSelectedItem(clean, itemType || 'file');
        }

        function onFolderDragOver(targetType, event) {
            if (!activeFileDrag || targetType !== 'directory') return;
            event.preventDefault();
            event.currentTarget?.classList?.add('drop-target');
            if (event.dataTransfer) {
                event.dataTransfer.dropEffect = 'move';
            }
        }

        function onFolderDragLeave(event) {
            event.currentTarget?.classList?.remove('drop-target');
        }

        function onFolderDrop(encodedTargetPath, targetType, event) {
            event.preventDefault();
            event.currentTarget?.classList?.remove('drop-target');
            if (!activeFileDrag) return;
            const srcPath = activeFileDrag.path;
            const targetPath = normalizeVirtualPath(decodeURIComponent(encodedTargetPath || ''));
            if (!srcPath) {
                clearDropTargetMarks();
                activeFileDrag = null;
                return;
            }
            let targetDir = '';
            if (targetType === 'directory') {
                targetDir = targetPath;
            } else {
                targetDir = getParentPath(targetPath);
            }
            if (srcPath === targetDir || getParentPath(srcPath) === targetDir) {
                clearDropTargetMarks();
                activeFileDrag = null;
                return;
            }
            const moved = moveVirtualItem(srcPath, targetDir);
            if (!moved.success) {
                showToast(moved.error || 'Move failed', 'error');
            } else {
                showToast(`Moved to ${targetDir || 'Home'}`, 'success');
            }
            clearDropTargetMarks();
            activeFileDrag = null;
        }

        function renameSelectedItemPrompt(pathOverride = '', typeOverride = '') {
            const seedPath = normalizeVirtualPath(pathOverride || selectedItemPath || selectedFile || '');
            if (!seedPath) {
                showToast('Select a file/folder first', 'error');
                return;
            }
            const ref = findNodeRecord(seedPath);
            if (!ref) {
                showToast(`Cannot find item: ${seedPath}`, 'error');
                return;
            }
            const oldName = String(ref.node.name || '').trim();
            const nextName = window.prompt('Rename to:', oldName);
            if (nextName === null) return;
            const result = renameVirtualItem(seedPath, nextName);
            if (!result.success) {
                showToast(result.error || 'Rename failed', 'error');
                return;
            }
            setSelectedItem(result.path, typeOverride || ref.node.type || 'file');
            showToast(`Renamed to ${nextName.trim()}`, 'success');
        }

        function createFolderPrompt(targetDirOverride = '') {
            const targetDir = normalizeVirtualPath(targetDirOverride || getDefaultTargetDirectory());
            const nextName = window.prompt(`Create folder in ${targetDir || 'Home'}:`, 'New Folder');
            if (nextName === null) return;
            const created = createVirtualItem('directory', targetDir, nextName);
            if (!created.success) {
                showToast(created.error || 'Create folder failed', 'error');
                return;
            }
            showToast(`Folder created: ${created.path}`, 'success');
        }

        function createFilePrompt(targetDirOverride = '') {
            const targetDir = normalizeVirtualPath(targetDirOverride || getDefaultTargetDirectory());
            const nextName = window.prompt(`Create file in ${targetDir || 'Home'}:`, 'New File.txt');
            if (nextName === null) return;
            const created = createVirtualItem('file', targetDir, nextName);
            if (!created.success) {
                showToast(created.error || 'Create file failed', 'error');
                return;
            }
            showToast(`File created: ${created.path}`, 'success');
        }

        function deleteSelectedItemPrompt(pathOverride = '') {
            const targetPath = normalizeVirtualPath(pathOverride || selectedItemPath || selectedFile || '');
            if (!targetPath) {
                showToast('Select a file/folder first', 'error');
                return;
            }
            const ref = findNodeRecord(targetPath);
            if (!ref) {
                showToast(`Cannot find item: ${targetPath}`, 'error');
                return;
            }
            const kind = ref.node.type === 'directory' ? 'folder' : 'file';
            if (!window.confirm(`Delete ${kind} "${ref.node.name}"? (virtual only)`)) {
                return;
            }
            const deleted = deleteVirtualItem(targetPath);
            if (!deleted.success) {
                showToast(deleted.error || 'Delete failed', 'error');
                return;
            }
            showToast(`Deleted: ${targetPath}`, 'success');
        }

        function openItemContextMenu(encodedPath, itemType, event) {
            event?.preventDefault();
            const path = normalizeVirtualPath(decodeURIComponent(encodedPath || ''));
            if (!path) return;
            setSelectedItem(path, itemType || 'file');
            const action = window.prompt('Action: [o]pen  [n]ew folder  [f]new file  [r]ename  [d]elete', 'r');
            if (action === null) return;
            const op = String(action || '').trim().toLowerCase();
            if (op === 'o') {
                if ((itemType || 'file') === 'directory') {
                    openSidebarFolder(path);
                } else {
                    selectFile(path, null);
                }
                return;
            }
            if (op === 'n') {
                const target = (itemType || 'file') === 'directory' ? path : getParentPath(path);
                createFolderPrompt(target);
                return;
            }
            if (op === 'f') {
                const target = (itemType || 'file') === 'directory' ? path : getParentPath(path);
                createFilePrompt(target);
                return;
            }
            if (op === 'd') {
                deleteSelectedItemPrompt(path);
                return;
            }
            renameSelectedItemPrompt(path, itemType || 'file');
        }

        function getParentPath(path) {
            const clean = (path || '').replace(/\/$/, '');
            if (!clean || !clean.includes('/')) return '';
            return clean.split('/').slice(0, -1).join('/');
        }

        function getSidebarFolderItems(path) {
            return getSubtreeByPath(fileData, path || '') || [];
        }

        function openSidebarFolder(path, renderMain = true) {
            sidebarCurrentPath = (path || '')
                .replace(/^\/hippocamp\/data\/?/, '')
                .replace(/^data\/?/, '')
                .replace(/\/$/, '');
            renderSidebarDesktopBrowser(document.getElementById('sidebarQuickSearch')?.value || '');
            if (renderMain) {
                renderMainFolderView(sidebarCurrentPath);
            }
        }

        function openSidebarFolderUp() {
            openSidebarFolder(getParentPath(sidebarCurrentPath));
        }

        function clickSidebarItem(encodedPath, itemType) {
            const path = decodeURIComponent(encodedPath || '');
            if (!path) return;
            setSelectedItem(path, itemType || 'file');
            if (itemType === 'directory') {
                openSidebarFolder(path);
                logUIAction(`ui:open_folder ${path}`);
                return;
            }
            selectFile(path, null);
        }

        function renderSidebarDesktopBrowser(rawKeyword = '') {
            const browser = document.getElementById('desktopFileBrowser');
            if (!browser) return;

            const keyword = (rawKeyword || '').trim().toLowerCase();
            let items = [];
            let caption = formatDisplayPath(sidebarCurrentPath);

            if (keyword) {
                caption = `Search: ${keyword}`;
                const matched = [];
                const walk = (nodes) => {
                    (nodes || []).forEach((item) => {
                        const name = (item.name || '').toLowerCase();
                        const path = (item.path || '').toLowerCase();
                        if (name.includes(keyword) || path.includes(keyword)) {
                            matched.push(item);
                        }
                        if (item.type === 'directory' && item.children) {
                            walk(item.children);
                        }
                    });
                };
                walk(fileData);
                items = matched.slice(0, 240);
            } else {
                items = getSidebarFolderItems(sidebarCurrentPath);
            }

            const canGoUp = !!sidebarCurrentPath && !keyword;
            browser.innerHTML = `
                <div class="desktop-browser-head">
                    <div class="location">${escapeHtml(caption)}</div>
                    <div class="actions">
                        <button type="button" ${canGoUp ? '' : 'disabled'} onclick="openSidebarFolderUp()">Up</button>
                        <button type="button" onclick="openSidebarFolder('')">Home</button>
                    </div>
                </div>
                <div class="sidebar-folder-list">
                    ${items.length ? sortFolderItems(items).map((item) => {
                        const itemPath = item.path || item.name || '';
                        const icon = item.type === 'directory' ? '&#x1F4C1;' : getFileIcon(item.ext || '');
                        const active = item.type === 'directory' && itemPath === mainFolderPath ? ' active' : '';
                        return `
                            <button class="sidebar-folder-item ${item.type}${active}" draggable="true"
                                ondragstart="startFileDrag('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                                ondragover="onFolderDragOver('${item.type}', event)"
                                ondragleave="onFolderDragLeave(event)"
                                ondrop="onFolderDrop('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                                oncontextmenu="openItemContextMenu('${encodeURIComponent(itemPath)}', '${item.type}', event)"
                                onclick="clickSidebarItem('${encodeURIComponent(itemPath)}', '${item.type}')">
                                <span class="item-icon">${icon}</span>
                                <span class="item-name">${escapeHtml(item.name || itemPath)}</span>
                            </button>
                        `;
                    }).join('') : '<div class="desktop-empty">No files found</div>'}
                </div>
            `;
        }

        function filterTreeByKeyword(rawKeyword) {
            renderSidebarDesktopBrowser(rawKeyword);
            const keyword = (rawKeyword || '').trim().toLowerCase();
            const allItems = document.querySelectorAll('#fileTree .tree-item');
            const allChildren = document.querySelectorAll('#fileTree .tree-children');

            if (!keyword) {
                allItems.forEach((el) => {
                    el.style.display = '';
                });
                allChildren.forEach((el) => {
                    el.style.display = '';
                });
                return;
            }

            allChildren.forEach((el) => {
                el.classList.add('expanded');
                el.style.display = '';
            });

            allItems.forEach((el) => {
                if (el.classList.contains('directory')) {
                    el.style.display = '';
                    return;
                }
                const name = (el.querySelector('.name')?.textContent || '').toLowerCase();
                const path = (el.dataset.path || '').toLowerCase();
                const visible = name.includes(keyword) || path.includes(keyword);
                el.style.display = visible ? '' : 'none';
            });
        }

        // Expand folder by path
        function expandFolderByPath(targetPath) {
            if (!targetPath) return;

            let cleanPath = targetPath
                .replace(/^\/hippocamp\/data\/?/, '')
                .replace(/^data\/?/, '')
                .replace(/^\.?\/?/, '')
                .replace(/\/$/, '');

            if (cleanPath) {
                const dirEl = document.querySelector(`.tree-item.directory[data-path="${cleanPath}"]`);
                if (dirEl) {
                    openSidebarFolder(cleanPath);
                } else {
                    openSidebarFolder(getParentPath(cleanPath));
                }
            } else {
                openSidebarFolder('');
            }

            if (!cleanPath) {
                document.querySelectorAll('.tree-children').forEach((el, idx) => {
                    if (idx < 3) el.classList.add('expanded');
                });
                return;
            }

            // First try exact path match
            const parts = cleanPath.split('/').filter(p => p);
            let currentPath = '';
            let found = false;

            parts.forEach((part, index) => {
                currentPath = currentPath ? currentPath + '/' + part : part;

                const dirEl = document.querySelector(`.tree-item.directory[data-path="${currentPath}"]`);
                if (dirEl) {
                    found = true;
                    dirEl.classList.add('open');
                    const children = dirEl.nextElementSibling;
                    if (children && children.classList.contains('tree-children')) {
                        children.classList.add('expanded');
                    }

                    if (index === parts.length - 1) {
                        document.querySelectorAll('.tree-item.highlighted').forEach(el => el.classList.remove('highlighted'));
                        dirEl.classList.add('highlighted');
                        dirEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            });

            // If not found by exact path, search by folder name (for relative paths)
            if (!found && parts.length > 0) {
                const folderName = parts[parts.length - 1];
                // Find all directories and look for one ending with this name
                const allDirs = document.querySelectorAll('.tree-item.directory');
                for (const dirEl of allDirs) {
                    const dirPath = dirEl.dataset.path || '';
                    // Match if path ends with the folder name
                    if (dirPath === folderName || dirPath.endsWith('/' + folderName)) {
                        // Expand all parent folders first
                        const pathParts = dirPath.split('/');
                        let buildPath = '';
                        pathParts.forEach((p, i) => {
                            buildPath = buildPath ? buildPath + '/' + p : p;
                            const parentDir = document.querySelector(`.tree-item.directory[data-path="${buildPath}"]`);
                            if (parentDir) {
                                parentDir.classList.add('open');
                                const parentChildren = parentDir.nextElementSibling;
                                if (parentChildren && parentChildren.classList.contains('tree-children')) {
                                    parentChildren.classList.add('expanded');
                                }
                            }
                        });

                        // Highlight the target folder
                        document.querySelectorAll('.tree-item.highlighted').forEach(el => el.classList.remove('highlighted'));
                        dirEl.classList.add('highlighted');
                        dirEl.classList.add('open');
                        const children = dirEl.nextElementSibling;
                        if (children && children.classList.contains('tree-children')) {
                            children.classList.add('expanded');
                        }
                        dirEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        break;
                    }
                }
            }
        }

        // Handle shell commands
        function handleShellCommand(command, result) {
            const parts = command.trim().split(/\s+/);
            const cmd = parts[0];
            let targetPath = parts.slice(1).join(' ').replace(/['"]/g, '');

            if (cmd === 'ls' || cmd === 'dir') {
                expandFolderByPath(targetPath || '.');
            } else if (cmd === 'cd') {
                if (targetPath && targetPath !== '-' && !targetPath.startsWith('..')) {
                    expandFolderByPath(targetPath);
                }
            } else if (cmd === 'cat' || cmd === 'head' || cmd === 'tail' || cmd === 'less' || cmd === 'more') {
                if (targetPath) {
                    const cleanPath = targetPath
                        .replace(/^\/hippocamp\/data\/?/, '')
                        .replace(/^data\/?/, '');
                    const fileEl = document.querySelector(`.tree-item.file[data-path="${cleanPath}"]`);
                    if (fileEl) {
                        selectFile(cleanPath, fileEl);
                    }
                }
            }
        }

        // Log UI interactions to command history
        async function logUIAction(command) {
            if (!command) return;
            try {
                await fetch('/api/log_command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source: 'webui',
                        command,
                        result: { success: true, output: 'ui' },
                        is_error: false
                    })
                });
            } catch (e) {
                // Best-effort logging; ignore failures.
            }
        }

        function createDynamicViewerWindow(path, appMeta = null) {
            const area = document.querySelector('.content-area');
            if (!area) return null;
            const meta = normalizeViewerAppMeta(appMeta || getViewerAppMetaByExt(getFileExtFromPath(path)));
            viewerAppMetaRegistry[meta.type] = meta;
            const windowId = `viewer_dynamic_${Date.now()}_${Math.floor(Math.random() * 100000)}`;
            const panel = document.createElement('div');
            panel.className = 'preview-panel file-viewer-window';
            panel.id = windowId;
            panel.dataset.windowKind = 'dynamic-viewer';
            panel.innerHTML = `
                <div class="preview-body">
                    <div class="preview-content">Loading...</div>
                </div>
            `;
            area.appendChild(panel);
            const areaRect = getWindowAreaRect();
            const visibleCount = getVisibleDynamicViewerPanels().length;
            const width = Math.min(860, Math.max(520, Math.round(areaRect.width * 0.56)));
            const height = Math.min(620, Math.max(360, Math.round(areaRect.height * 0.64)));
            const baseLeft = Math.max(52, Math.round(areaRect.width * 0.08));
            const baseTop = Math.max(46, Math.round(areaRect.height * 0.09));
            const cascadeStep = 30;
            const leftRaw = baseLeft + ((visibleCount % 7) * cascadeStep);
            const topRaw = baseTop + ((visibleCount % 6) * 24);
            const minLeft = Math.min(0, -width + 48);
            const maxLeft = areaRect.width - 48;
            const minTop = 0;
            const maxTop = areaRect.height - 36;
            panel.style.left = `${Math.round(Math.max(minLeft, Math.min(maxLeft, leftRaw)))}px`;
            panel.style.top = `${Math.round(Math.max(minTop, Math.min(maxTop, topRaw)))}px`;
            panel.style.width = `${Math.round(width)}px`;
            panel.style.height = `${Math.round(height)}px`;
            dynamicWindowState[windowId] = {
                maximized: false,
                restore: null,
                path,
                title: String(path || '').split('/').pop() || 'File',
                appType: meta.type,
                appName: meta.name,
                appMeta: meta
            };
            focusWindowElement(panel);
            updateDockBadges();
            return windowId;
        }

        function minimizeDynamicWindow(windowId) {
            const panel = document.getElementById(windowId);
            if (!panel) return;
            const state = dynamicWindowState[windowId] || {};
            const appType = sanitizeDockAppType(state.appType || 'generic');
            if (!minimizedViewerWindows[appType]) {
                minimizedViewerWindows[appType] = [];
            }
            minimizedViewerWindows[appType].unshift({
                id: `d-${Date.now()}-${Math.floor(Math.random() * 100000)}`,
                title: panel.querySelector('.preview-header h2')?.textContent?.trim() || 'File',
                windowId
            });
            minimizedViewerWindows[appType] = minimizedViewerWindows[appType].slice(0, 24);
            panel.classList.add('files-hidden');
            updateDockBadges();
        }

        function closeDynamicWindow(windowId) {
            const panel = document.getElementById(windowId);
            if (panel) {
                panel.remove();
            }
            delete dynamicWindowState[windowId];
            Object.keys(minimizedViewerWindows).forEach((appType) => {
                minimizedViewerWindows[appType] = (minimizedViewerWindows[appType] || []).filter((entry) => entry.windowId !== windowId);
                if (!minimizedViewerWindows[appType].length) {
                    delete minimizedViewerWindows[appType];
                }
            });
            updateDockBadges();
        }

        function toggleDynamicWindowMaximize(windowId) {
            const panel = document.getElementById(windowId);
            if (!panel) return;
            const state = dynamicWindowState[windowId] || { maximized: false, restore: null };
            if (!state.maximized) {
                state.restore = {
                    left: panel.style.left,
                    top: panel.style.top,
                    width: panel.style.width,
                    height: panel.style.height
                };
                panel.classList.add('window-maximized');
                state.maximized = true;
            } else {
                panel.classList.remove('window-maximized');
                if (state.restore) {
                    panel.style.left = state.restore.left;
                    panel.style.top = state.restore.top;
                    panel.style.width = state.restore.width;
                    panel.style.height = state.restore.height;
                }
                state.maximized = false;
            }
            dynamicWindowState[windowId] = state;
            focusWindowElement(panel);
        }

        function openFileInFloatingWindow(path) {
            const appMeta = getViewerAppMetaByExt(getFileExtFromPath(path));
            const windowId = createDynamicViewerWindow(path, appMeta);
            if (!windowId) return;
            const handlers = {
                minimize: `minimizeDynamicWindow('${windowId}')`,
                maximize: `toggleDynamicWindowMaximize('${windowId}')`,
                close: `closeDynamicWindow('${windowId}')`
            };
            loadFilePreview(path, {
                source: 'webui',
                operation: 'open_file',
                panelId: windowId,
                contentId: `previewContent_${windowId}`,
                windowKind: 'viewer',
                headerHandlers: handlers,
                floating: true
            });
        }

        // Select file
        function selectFile(path, element) {
            document.querySelectorAll('.tree-item.selected').forEach(el => el.classList.remove('selected'));
            if (element) element.classList.add('selected');

            setSelectedItem(path, 'file');
            const parentPath = getParentPath(path);
            if (parentPath !== sidebarCurrentPath) {
                sidebarCurrentPath = parentPath;
                renderSidebarDesktopBrowser(document.getElementById('sidebarQuickSearch')?.value || '');
            }
            document.getElementById('currentPath').innerHTML = `<span class="path">${path}</span>`;
            logUIAction(`ui:select_file ${path}`);
            if (element) {
                const label = `Open ${String(path || '').split('/').pop() || 'file'}`;
                animateCursorToElement(element, { label, click: true, doubleClick: true }).then(() => {
                    hideAgentCursorLater(360);
                });
            }

            openFileInFloatingWindow(path);
        }

        const IMAGE_FILE_EXTS = new Set(['png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'tiff', 'tif']);
        const VIDEO_FILE_EXTS = new Set(['mp4', 'mov', 'avi', 'mkv', 'webm', 'm4v']);
        const AUDIO_FILE_EXTS = new Set(['mp3', 'wav', 'm4a', 'flac', 'aac', 'ogg']);
        const CSV_FILE_EXTS = new Set(['csv', 'tsv']);
        const MAIL_FILE_EXTS = new Set(['eml']);
        const TEXT_FILE_EXTS = new Set(['txt', 'md', 'json', 'log', 'py', 'js', 'ts', 'html', 'htm', 'xml', 'yaml', 'yml', 'ini', 'ics', 'sql']);
        const WORD_EXTS = new Set(['docx', 'doc']);
        const SHEET_EXTS = new Set(['xlsx', 'xls']);
        const SLIDE_EXTS = new Set(['pptx', 'ppt']);

        function getFileExtFromPath(path) {
            const fileName = String(path || '').split('/').pop() || '';
            const idx = fileName.lastIndexOf('.');
            if (idx < 0) return '';
            return fileName.slice(idx + 1).toLowerCase();
        }

        function getViewerAppMetaByExt(ext) {
            const e = String(ext || '').replace(/^\./, '').toLowerCase();
            if (IMAGE_FILE_EXTS.has(e)) return { type: 'image-viewer', name: 'Image Viewer', icon: '&#x1F5BC;' };
            if (e === 'pdf') return { type: 'document-viewer', name: 'Document Viewer', icon: '&#x1F4D5;' };
            if (CSV_FILE_EXTS.has(e) || SHEET_EXTS.has(e)) return { type: 'calc', name: 'LibreOffice Calc', icon: '&#x1F4CA;' };
            if (MAIL_FILE_EXTS.has(e)) return { type: 'mail', name: 'Mail', icon: '&#x2709;' };
            if (e === 'ics') return { type: 'calendar', name: 'Calendar', icon: '&#x1F4C5;' };
            if (WORD_EXTS.has(e)) return { type: 'writer', name: 'LibreOffice Writer', icon: '&#x1F4D8;' };
            if (SLIDE_EXTS.has(e)) return { type: 'impress', name: 'LibreOffice Impress', icon: '&#x1F4FD;' };
            if (VIDEO_FILE_EXTS.has(e)) return { type: 'videos', name: 'Videos', icon: '&#x1F3AC;' };
            if (AUDIO_FILE_EXTS.has(e)) return { type: 'music', name: 'Music', icon: '&#x1F3B5;' };
            if (TEXT_FILE_EXTS.has(e)) return { type: 'text-editor', name: 'Text Editor', icon: '&#x1F4DD;' };
            return { type: 'generic', name: 'File Viewer', icon: '&#x1F4C4;' };
        }

        function getAppNameByExt(ext) {
            return getViewerAppMetaByExt(ext).name;
        }

        function buildPreviewAppFrame(appName, fileName, bodyHtml) {
            return `
                <div class="app-file-header">
                    <span class="app-name">${escapeHtml(appName)}</span>
                    <span class="file-name">${escapeHtml(fileName)}</span>
                </div>
                <div class="app-file-body">${bodyHtml}</div>
            `;
        }

        async function fetchServedText(path, maxChars = 220000) {
            const resp = await fetch(`/api/serve_file/${encodePath(path)}`, { cache: 'no-store' });
            if (!resp.ok) throw new Error(`Cannot open file (${resp.status})`);
            let text = await resp.text();
            if (text.length > maxChars) {
                text = `${text.slice(0, maxChars)}\n\n...[truncated]`;
            }
            return text;
        }

        async function fetchServedBuffer(path) {
            const resp = await fetch(`/api/serve_file/${encodePath(path)}`, { cache: 'no-store' });
            if (!resp.ok) throw new Error(`Cannot open file (${resp.status})`);
            return await resp.arrayBuffer();
        }

        async function tryOfficeImagePreview(path, appName, fileName, sid = 'viewer') {
            try {
                const resp = await apiFetch(`/api/return_img/${encodePath(path)}`);
                const data = await resp.json();
                if (!data.success) return false;
                const rawPaths = data.image_paths && data.image_paths.length ? data.image_paths : [data.image_path];
                const paths = normalizeImagePaths(rawPaths);
                if (!paths.length) return false;

                const content = document.getElementById('previewContent');
                if (!content) return false;
                const imageItems = paths.map((p, idx) => {
                    const clean = p.startsWith('/') ? p.substring(1) : p;
                    return `<img src="/api/serve_image/${encodePath(clean)}" alt="Page ${idx + 1}" style="width:100%; margin-bottom:12px; border-radius:8px;">`;
                }).join('');
                content.innerHTML = `
                    ${buildPreviewAppFrame(appName, fileName, `
                        <div class="viewer-mini-toolbar">
                            <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">Zoom -</button>
                            <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                            <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">Zoom +</button>
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -360, this)">Up</button>
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 360, this)">Down</button>
                            <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'office-pages', this)">Auto Browse</button>
                        </div>
                        <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">
                            <div id="viewerZoomTarget_${sid}">${imageItems}</div>
                        </div>
                    `)}
                `;
                setViewerScale(sid, 1);
                return true;
            } catch (e) {
                return false;
            }
        }

        function formatClock(seconds) {
            const total = Math.max(0, Math.floor(Number(seconds) || 0));
            const mm = Math.floor(total / 60);
            const ss = total % 60;
            return `${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
        }

        function toColumnLabel(index) {
            let n = Number(index) + 1;
            let label = '';
            while (n > 0) {
                const rem = (n - 1) % 26;
                label = String.fromCharCode(65 + rem) + label;
                n = Math.floor((n - 1) / 26);
            }
            return label;
        }

        function rowsToHtmlTable(rows, options = {}) {
            const allRows = Array.isArray(rows) ? rows : [];
            const maxRows = options.maxRows || 500;
            const maxCols = options.maxCols || 36;
            const limitedRows = allRows.slice(0, maxRows);
            const colCount = Math.min(
                maxCols,
                Math.max(1, limitedRows.reduce((m, r) => Math.max(m, Array.isArray(r) ? r.length : 0), 0))
            );

            const headCells = ['<th class="sheet-rownum"></th>'];
            for (let i = 0; i < colCount; i++) {
                headCells.push(`<th>${toColumnLabel(i)}</th>`);
            }

            const bodyRows = limitedRows.map((row, rowIndex) => {
                const cells = [`<th class="sheet-rownum">${rowIndex + 1}</th>`];
                for (let i = 0; i < colCount; i++) {
                    const value = Array.isArray(row) ? (row[i] ?? '') : '';
                    cells.push(`<td>${escapeHtml(String(value))}</td>`);
                }
                const rowText = (Array.isArray(row) ? row : []).join(' ').toLowerCase();
                const cls = rowIndex === 0 ? ' class="header-row"' : '';
                return `<tr${cls} data-search="${escapeHtml(rowText)}">${cells.join('')}</tr>`;
            }).join('');

            return `
                <div class="sheet-table-wrap">
                    <table class="spreadsheet-table sheet-table" id="sheetTable">
                        <thead><tr>${headCells.join('')}</tr></thead>
                        <tbody>${bodyRows}</tbody>
                    </table>
                </div>
            `;
        }

        function filterSheetRows(term) {
            const keyword = String(term || '').trim().toLowerCase();
            document.querySelectorAll('#sheetTable tbody tr').forEach((row) => {
                if (!keyword) {
                    row.style.display = '';
                    return;
                }
                const text = (row.dataset.search || '').toLowerCase();
                row.style.display = text.includes(keyword) ? '' : 'none';
            });
        }

        function parseCsvRows(rawText) {
            const text = String(rawText || '');
            if (typeof XLSX !== 'undefined') {
                try {
                    const wb = XLSX.read(text, { type: 'string' });
                    const firstSheet = wb.SheetNames && wb.SheetNames[0];
                    if (firstSheet) {
                        return XLSX.utils.sheet_to_json(wb.Sheets[firstSheet], { header: 1, raw: false, defval: '' });
                    }
                } catch (e) {}
            }
            return text
                .split(/\r?\n/)
                .filter(line => line.length > 0)
                .map(line => line.split(','));
        }

        function renderCsvViewer(fileName, rawText) {
            const rows = parseCsvRows(rawText);
            const visibleRows = rows.slice(0, 500);
            const columnCount = visibleRows.reduce((m, row) => Math.max(m, Array.isArray(row) ? row.length : 0), 0);
            const truncated = rows.length > visibleRows.length;
            const table = rowsToHtmlTable(visibleRows, { maxRows: 500, maxCols: 40 });
            return buildPreviewAppFrame(
                'LibreOffice Calc',
                fileName,
                `
                    <div class="sheet-toolbar">
                        <input type="text" placeholder="Filter rows..." oninput="filterSheetRows(this.value)">
                        <span class="sheet-stats">Rows: ${rows.length}  Cols: ${columnCount || 0}</span>
                    </div>
                    ${table}
                    ${truncated ? `<div class="viewer-note">Showing first 500 rows.</div>` : ''}
                `
            );
        }

        function decodeBytesWithCharset(bytes, charset = 'utf-8') {
            try {
                return new TextDecoder(charset || 'utf-8', { fatal: false }).decode(bytes);
            } catch (e) {
                try {
                    return new TextDecoder('utf-8', { fatal: false }).decode(bytes);
                } catch (err) {
                    return '';
                }
            }
        }

        function base64DecodeToUtf8(base64Value, charset = 'utf-8') {
            const clean = String(base64Value || '').replace(/\s+/g, '');
            if (!clean) return '';
            try {
                const bin = atob(clean);
                const bytes = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) {
                    bytes[i] = bin.charCodeAt(i);
                }
                return decodeBytesWithCharset(bytes, charset);
            } catch (e) {
                return '';
            }
        }

        function decodeQuotedPrintable(text, charset = 'utf-8') {
            const input = String(text || '').replace(/=\r?\n/g, '');
            const bytes = [];
            for (let i = 0; i < input.length; i++) {
                if (input[i] === '=' && /^[0-9A-Fa-f]{2}$/.test(input.slice(i + 1, i + 3))) {
                    bytes.push(parseInt(input.slice(i + 1, i + 3), 16));
                    i += 2;
                } else {
                    bytes.push(input.charCodeAt(i));
                }
            }
            return decodeBytesWithCharset(new Uint8Array(bytes), charset);
        }

        function decodeMimeWords(value) {
            return String(value || '').replace(/=\?([^?]+)\?([bBqQ])\?([^?]+)\?=/g, (_, charset, enc, payload) => {
                if (!payload) return '';
                if (String(enc).toUpperCase() === 'B') {
                    const decoded = base64DecodeToUtf8(payload, charset);
                    return decoded || payload;
                }
                const qText = payload
                    .replace(/_/g, ' ')
                    .replace(/=([0-9A-Fa-f]{2})/g, (m, hex) => String.fromCharCode(parseInt(hex, 16)));
                const bytes = new Uint8Array(Array.from(qText).map(ch => ch.charCodeAt(0)));
                const decoded = decodeBytesWithCharset(bytes, charset);
                return decoded || qText;
            });
        }

        function splitHeaderAndBody(rawText) {
            const raw = String(rawText || '');
            const m = raw.match(/\r?\n\r?\n/);
            if (!m || m.index === undefined) {
                return { headerText: raw, bodyText: '' };
            }
            const idx = m.index;
            return {
                headerText: raw.slice(0, idx),
                bodyText: raw.slice(idx + m[0].length)
            };
        }

        function parseHeaders(headerText) {
            const unfolded = String(headerText || '').replace(/\r?\n[ \t]+/g, ' ');
            const map = {};
            unfolded.split(/\r?\n/).forEach((line) => {
                const idx = line.indexOf(':');
                if (idx <= 0) return;
                const key = line.slice(0, idx).trim().toLowerCase();
                const val = decodeMimeWords(line.slice(idx + 1).trim());
                if (!map[key]) {
                    map[key] = val;
                } else {
                    map[key] = `${map[key]}, ${val}`;
                }
            });
            return map;
        }

        function decodeTransferBody(bodyText, encoding, charset = 'utf-8') {
            const enc = String(encoding || '').toLowerCase();
            if (enc.includes('base64')) {
                return base64DecodeToUtf8(bodyText, charset);
            }
            if (enc.includes('quoted-printable')) {
                return decodeQuotedPrintable(bodyText, charset);
            }
            return String(bodyText || '');
        }

        function sanitizeEmailHtml(html) {
            return String(html || '')
                .replace(/<script[\s\S]*?<\/script>/gi, '')
                .replace(/<iframe[\s\S]*?<\/iframe>/gi, '')
                .replace(/\son\w+\s*=\s*(['"]).*?\1/gi, '')
                .replace(/\sjavascript:/gi, ' ');
        }

        function parseEml(rawText) {
            const { headerText, bodyText } = splitHeaderAndBody(rawText);
            const headers = parseHeaders(headerText);
            const ctype = String(headers['content-type'] || '');
            const charsetMatch = ctype.match(/charset="?([^";]+)"?/i);
            const charset = charsetMatch ? charsetMatch[1] : 'utf-8';
            const transfer = headers['content-transfer-encoding'] || '';

            let html = '';
            let text = '';

            const boundaryMatch = ctype.match(/boundary="?([^";]+)"?/i);
            if (boundaryMatch && boundaryMatch[1]) {
                const boundary = boundaryMatch[1];
                const rawParts = String(bodyText || '').split(`--${boundary}`);
                for (const rawPart of rawParts) {
                    const part = rawPart.trim();
                    if (!part || part === '--') continue;
                    const cleaned = part.replace(/--$/, '').trim();
                    const { headerText: pHeaderText, bodyText: pBodyText } = splitHeaderAndBody(cleaned);
                    const pHeaders = parseHeaders(pHeaderText);
                    const pType = String(pHeaders['content-type'] || '').toLowerCase();
                    const pCharsetMatch = pType.match(/charset="?([^";]+)"?/i);
                    const pCharset = pCharsetMatch ? pCharsetMatch[1] : charset;
                    const pTransfer = pHeaders['content-transfer-encoding'] || '';
                    const decoded = decodeTransferBody(pBodyText, pTransfer, pCharset).trim();

                    if (!html && pType.includes('text/html')) {
                        html = decoded;
                    } else if (!text && pType.includes('text/plain')) {
                        text = decoded;
                    }
                }
            } else {
                const decoded = decodeTransferBody(bodyText, transfer, charset).trim();
                if (ctype.toLowerCase().includes('text/html')) {
                    html = decoded;
                } else {
                    text = decoded;
                }
            }

            return {
                subject: headers.subject || '(No subject)',
                from: headers.from || '',
                to: headers.to || '',
                cc: headers.cc || '',
                date: headers.date || '',
                html: sanitizeEmailHtml(html),
                text: text || ''
            };
        }

        function parseIcsDateValue(rawValue) {
            const value = String(rawValue || '').trim();
            if (!value) return '';
            if (/^\d{8}$/.test(value)) {
                const y = Number(value.slice(0, 4));
                const m = Number(value.slice(4, 6)) - 1;
                const d = Number(value.slice(6, 8));
                const dt = new Date(y, m, d);
                return Number.isNaN(dt.getTime()) ? value : dt.toLocaleDateString();
            }
            if (/^\d{8}T\d{6}Z?$/.test(value)) {
                const y = Number(value.slice(0, 4));
                const m = Number(value.slice(4, 6)) - 1;
                const d = Number(value.slice(6, 8));
                const hh = Number(value.slice(9, 11));
                const mm = Number(value.slice(11, 13));
                const ss = Number(value.slice(13, 15));
                const isUtc = value.endsWith('Z');
                const dt = isUtc
                    ? new Date(Date.UTC(y, m, d, hh, mm, ss))
                    : new Date(y, m, d, hh, mm, ss);
                return Number.isNaN(dt.getTime()) ? value : dt.toLocaleString();
            }
            return value;
        }

        function parseIcsEvents(rawText) {
            const unfolded = String(rawText || '').replace(/\r?\n[ \t]/g, '');
            const lines = unfolded.split(/\r?\n/);
            const events = [];
            let current = null;

            for (const line of lines) {
                if (line === 'BEGIN:VEVENT') {
                    current = {};
                    continue;
                }
                if (line === 'END:VEVENT') {
                    if (current) events.push(current);
                    current = null;
                    continue;
                }
                if (!current) continue;
                const idx = line.indexOf(':');
                if (idx < 0) continue;
                const rawKey = line.slice(0, idx).trim().toUpperCase();
                const value = line.slice(idx + 1).trim();
                const key = rawKey.split(';')[0];
                if (key === 'SUMMARY') current.summary = value;
                else if (key === 'DTSTART') current.start = parseIcsDateValue(value);
                else if (key === 'DTEND') current.end = parseIcsDateValue(value);
                else if (key === 'LOCATION') current.location = value;
                else if (key === 'DESCRIPTION') current.description = value.replace(/\\n/g, '\n');
            }

            return events;
        }

        function renderIcsViewer(fileName, rawText, sid) {
            const events = parseIcsEvents(rawText);
            const rows = events.slice(0, 240).map((event, idx) => `
                <div class="mail-header-row" style="grid-template-columns: 78px 1fr;">
                    <div class="label">#${idx + 1}</div>
                    <div class="value">
                        <div style="font-weight:700; color:#111827; margin-bottom:4px;">${escapeHtml(event.summary || '(Untitled event)')}</div>
                        ${event.start ? `<div><strong>Start:</strong> ${escapeHtml(event.start)}</div>` : ''}
                        ${event.end ? `<div><strong>End:</strong> ${escapeHtml(event.end)}</div>` : ''}
                        ${event.location ? `<div><strong>Location:</strong> ${escapeHtml(event.location)}</div>` : ''}
                        ${event.description ? `<div style="margin-top:4px; white-space:pre-wrap;">${escapeHtml(event.description)}</div>` : ''}
                    </div>
                </div>
            `).join('');

            return `
                <div class="viewer-mini-toolbar">
                    <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -320, this)">Up</button>
                    <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 320, this)">Down</button>
                    <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">A-</button>
                    <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                    <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">A+</button>
                    <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'calendar', this)">Auto Browse</button>
                </div>
                <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">
                    <div id="viewerText_${sid}">
                        ${buildPreviewAppFrame(
                            'Calendar',
                            fileName,
                            events.length
                                ? `<div class="mail-headers">${rows}</div>`
                                : `<pre class="mail-body-text">${escapeHtml(rawText || '(No calendar entries)')}</pre>`
                        )}
                    </div>
                </div>
            `;
        }

        function buildMailDocument(htmlBody) {
            return `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
body{font-family:Arial,sans-serif;color:#111827;line-height:1.45;padding:14px;margin:0;background:#fff}
img{max-width:100%;height:auto}
table{max-width:100%;border-collapse:collapse}
a{color:#1d4ed8}
</style>
</head>
<body>${htmlBody}</body>
</html>`;
        }

        function renderEmailViewer(fileName, rawText) {
            const mail = parseEml(rawText);
            const rows = [
                ['Subject', mail.subject || '(No subject)'],
                ['From', mail.from || ''],
                ['To', mail.to || ''],
                ['Cc', mail.cc || ''],
                ['Date', mail.date || '']
            ].filter(([, value]) => String(value || '').trim().length > 0);

            const headersHtml = rows.map(([label, value]) => `
                <div class="mail-header-row">
                    <div class="label">${escapeHtml(label)}</div>
                    <div class="value">${escapeHtml(value)}</div>
                </div>
            `).join('');

            const bodyHtml = mail.html
                ? `<iframe class="mail-body-frame" sandbox src="data:text/html;charset=utf-8,${encodeURIComponent(buildMailDocument(mail.html))}"></iframe>`
                : `<pre class="mail-body-text">${escapeHtml(mail.text || '(No body)')}</pre>`;

            return buildPreviewAppFrame(
                'Mail',
                fileName,
                `
                    <div class="mail-viewer">
                        <div class="mail-headers">${headersHtml}</div>
                        <div class="mail-body-wrap">${bodyHtml}</div>
                    </div>
                `
            );
        }

        function initAudioViewer() {
            const audio = document.getElementById('audioPlayerMain');
            const seek = document.getElementById('audioSeek');
            const current = document.getElementById('audioCurrentTime');
            const total = document.getElementById('audioTotalTime');
            if (!audio || !seek || !current || !total) return;
            if (audio.dataset.bound === '1') return;
            audio.dataset.bound = '1';

            audio.addEventListener('loadedmetadata', () => {
                seek.max = String(Math.max(0, Math.floor(audio.duration || 0)));
                total.textContent = formatClock(audio.duration);
            });

            audio.addEventListener('timeupdate', () => {
                if (!seek.matches(':active')) {
                    seek.value = String(Math.max(0, Math.floor(audio.currentTime || 0)));
                }
                current.textContent = formatClock(audio.currentTime);
            });

            seek.addEventListener('input', () => {
                audio.currentTime = Number(seek.value || 0);
            });
        }

        // Load file preview - open with simulated Ubuntu apps
        async function loadFilePreview(path, options = {}) {
            const virtualPath = normalizeVirtualPath(path);
            const actualPath = resolveActualPath(path);
            const windowKind = options.windowKind || 'viewer';
            const panelId = options.panelId || (windowKind === 'viewer' ? 'fileViewerPanel' : 'previewPanel');
            const panel = document.getElementById(panelId);
            if (!panel) return;
            const floating = !!options.floating;
            if (windowKind === 'viewer' && !floating) {
                if (!fileViewerVisible) {
                    setFileViewerVisible(true);
                }
            } else if (!filesWindowVisible) {
                setFilesWindowVisible(true);
            }
            const fileName = virtualPath.split('/').pop();
            const ext = getFileExtFromPath(virtualPath);
            const appName = getAppNameByExt(ext);
            const source = options.source || 'webui';
            const headerOperation = options.headerOperation || appName;
            const headerHandlers = options.headerHandlers || null;
            const contentId = options.contentId || `previewContent_${String(panelId).replace(/[^a-zA-Z0-9_]/g, '_')}`;
            const sid = toViewerScopeId(contentId);
            const manualWindow = source === 'webui' || source === 'terminal';
            previewWindowState = {
                isOpen: true,
                source,
                operation: options.operation || 'preview',
                filePath: virtualPath,
                windowKind,
                autoCloseAfterCommand: manualWindow ? null : commandSequence + 1
            };

            panel.innerHTML = `
                ${renderPreviewHeader(fileName, headerOperation, source, windowKind, headerHandlers)}
                <div class="preview-body">
                    <div class="preview-content" id="${contentId}">
                        <div class="loading">
                            <div class="loading-spinner"></div>
                            <span>Opening in ${appName}...</span>
                        </div>
                    </div>
                </div>
            `;
            if (floating) {
                focusWindowElement(panel);
            } else {
                focusAppWindow(windowKind === 'viewer' ? 'viewer' : 'files');
            }

            const skipMetadata = !!options.skipMetadata;
            if (!skipMetadata) {
                await loadMetadata(actualPath);
            }
            const content = document.getElementById(contentId);
            if (!content) return;

            try {
                if (IMAGE_FILE_EXTS.has(ext)) {
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">Zoom -</button>
                                <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">Zoom +</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -260, this)">Up</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 260, this)">Down</button>
                                <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'image', this)">Auto Browse</button>
                            </div>
                            <div class="viewer-scroll-wrap" id="viewerScroll_${sid}">
                                <img id="viewerImage_${sid}" src="/api/serve_file/${encodePath(actualPath)}" alt="${escapeHtml(virtualPath)}">
                            </div>
                        `
                    );
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (ext === 'pdf') {
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">Zoom -</button>
                                <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">Zoom +</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -420, this)">Page Up</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 420, this)">Page Down</button>
                                <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'pdf', this)">Auto Read</button>
                            </div>
                            <div class="viewer-scroll-wrap" id="viewerScroll_${sid}">
                                <iframe id="viewerFrame_${sid}" src="/api/serve_file/${encodePath(actualPath)}"></iframe>
                            </div>
                        `
                    );
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (CSV_FILE_EXTS.has(ext)) {
                    const csvText = await fetchServedText(actualPath, 1800000);
                    content.innerHTML = `
                        <div class="viewer-mini-toolbar">
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -280, this)">Up</button>
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 280, this)">Down</button>
                            <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">A-</button>
                            <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                            <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">A+</button>
                            <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'sheet', this)">Auto Browse</button>
                        </div>
                        <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">
                            <div id="viewerText_${sid}">${renderCsvViewer(fileName, csvText)}</div>
                        </div>
                    `;
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (MAIL_FILE_EXTS.has(ext)) {
                    const mailText = await fetchServedText(actualPath, 2000000);
                    content.innerHTML = `
                        <div class="viewer-mini-toolbar">
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -280, this)">Up</button>
                            <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 280, this)">Down</button>
                            <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'mail', this)">Auto Read</button>
                        </div>
                        <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">${renderEmailViewer(fileName, mailText)}</div>
                    `;
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (ext === 'ics') {
                    const icsText = await fetchServedText(actualPath, 2000000);
                    content.innerHTML = renderIcsViewer(fileName, icsText, sid);
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (VIDEO_FILE_EXTS.has(ext)) {
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" id="videoPlayBtn_${sid}" onclick="toggleVideoPlayback('${sid}', this)">Play / Pause</button>
                                <span class="viewer-tool-label" id="videoCurrentTime_${sid}">00:00</span>
                                <input class="audio-range" type="range" id="videoSeek_${sid}" min="0" max="0" step="1" value="0">
                                <span class="viewer-tool-label" id="videoTotalTime_${sid}">00:00</span>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">Zoom -</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">Zoom +</button>
                            </div>
                            <div class="viewer-scroll-wrap" id="viewerScroll_${sid}">
                                <video id="videoPlayer_${sid}" controls style="width: 100%; max-height: 70vh;">
                                    <source src="/api/serve_file/${encodePath(actualPath)}">
                                </video>
                            </div>
                        `
                    );
                    initVideoViewerScoped(sid);
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (AUDIO_FILE_EXTS.has(ext)) {
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="audio-viewer">
                                <div class="audio-head">
                                    <div class="audio-art">&#x266B;</div>
                                    <div class="audio-meta">
                                        <div class="title">${escapeHtml(fileName)}</div>
                                        <div class="sub">${escapeHtml(ext.toUpperCase())} audio</div>
                                    </div>
                                </div>
                                <audio id="audioPlayer_${sid}" controls preload="metadata" style="width:100%; margin-bottom:8px;">
                                    <source src="/api/serve_file/${encodePath(actualPath)}">
                                </audio>
                                <div class="audio-controls">
                                    <button class="viewer-tool-btn" id="audioPlayBtn_${sid}" type="button" onclick="toggleAudioPlayback('${sid}', this)">Play / Pause</button>
                                    <span class="audio-time" id="audioCurrentTime_${sid}">00:00</span>
                                    <input class="audio-range" type="range" id="audioSeek_${sid}" min="0" max="0" step="1" value="0">
                                    <span class="audio-time" id="audioTotalTime_${sid}">00:00</span>
                                </div>
                            </div>
                        `
                    );
                    initAudioViewerScoped(sid);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (TEXT_FILE_EXTS.has(ext)) {
                    const text = await fetchServedText(actualPath);
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">A-</button>
                                <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">A+</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -320, this)">Up</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 320, this)">Down</button>
                                <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'text', this)">Auto Read</button>
                            </div>
                            <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">
                                <pre id="viewerText_${sid}">${escapeHtml(text)}</pre>
                            </div>
                        `
                    );
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (WORD_EXTS.has(ext) && typeof mammoth !== 'undefined') {
                    const buf = await fetchServedBuffer(actualPath);
                    const rendered = await mammoth.convertToHtml({ arrayBuffer: buf });
                    const html = rendered && rendered.value ? rendered.value : '<p>Empty document.</p>';
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -320, this)">Up</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 320, this)">Down</button>
                                <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'document', this)">Auto Read</button>
                            </div>
                            <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">${html}</div>
                        `
                    );
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (SHEET_EXTS.has(ext) && typeof XLSX !== 'undefined') {
                    const buf = await fetchServedBuffer(actualPath);
                    const wb = XLSX.read(buf, { type: 'array' });
                    const firstSheet = wb.SheetNames[0];
                    const rows = XLSX.utils.sheet_to_json(wb.Sheets[firstSheet], { header: 1, raw: false, defval: '' });
                    const columnCount = rows.reduce((m, row) => Math.max(m, Array.isArray(row) ? row.length : 0), 0);
                    content.innerHTML = buildPreviewAppFrame(
                        appName,
                        fileName,
                        `
                            <div class="viewer-mini-toolbar">
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', -280, this)">Up</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerScrollBy('${sid}', 280, this)">Down</button>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', -0.1, this)">A-</button>
                                <span class="viewer-tool-label" id="viewerZoomLabel_${sid}">100%</span>
                                <button class="viewer-tool-btn" type="button" onclick="viewerZoomBy('${sid}', 0.1, this)">A+</button>
                                <button class="viewer-tool-btn" id="viewerAutoBtn_${sid}" type="button" onclick="viewerAutoBrowse('${sid}', 'sheet', this)">Auto Browse</button>
                            </div>
                            <div class="sheet-toolbar">
                                <input type="text" placeholder="Filter rows..." oninput="filterSheetRows(this.value)">
                                <span class="sheet-stats">Rows: ${rows.length}  Cols: ${columnCount || 0}</span>
                            </div>
                            <div id="viewerScroll_${sid}" class="viewer-scroll-wrap">
                                <div id="viewerText_${sid}">${rowsToHtmlTable(rows, { maxRows: 500, maxCols: 40 })}</div>
                            </div>
                            ${rows.length > 500 ? `<div class="viewer-note">Showing first 500 rows.</div>` : ''}
                        `
                    );
                    setViewerScale(sid, 1);
                    scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                    return;
                }

                if (WORD_EXTS.has(ext) || SHEET_EXTS.has(ext) || SLIDE_EXTS.has(ext)) {
                    const ok = await tryOfficeImagePreview(actualPath, appName, fileName, sid);
                    if (ok) {
                        scheduleViewerExperience(sid, ext, source, options.operation || 'preview');
                        return;
                    }
                }

                content.innerHTML = buildPreviewAppFrame(
                    appName,
                    fileName,
                    `
                        <p style="margin-bottom: 10px;">This file type cannot be rendered inline.</p>
                        <button class="toolbar-btn" onclick="openOriginalFile('${encodePath(actualPath)}')">Open file</button>
                    `
                );
            } catch (e) {
                content.innerHTML = buildPreviewAppFrame(
                    appName,
                    fileName,
                    `
                        <p style="margin-bottom: 10px; color: var(--accent-red);">Failed to open file: ${escapeHtml(e.message || 'unknown error')}</p>
                        <button class="toolbar-btn" onclick="openOriginalFile('${encodePath(actualPath)}')">Open file</button>
                    `
                );
            }
        }

        // Get file icon based on extension
        function getFileIcon(ext) {
            const normalizedExt = String(ext || '').replace(/^\./, '').toLowerCase();
            const icons = {
                'pdf': '&#x1F4D5;',
                'docx': '&#x1F4D8;', 'doc': '&#x1F4D8;',
                'xlsx': '&#x1F4D7;', 'xls': '&#x1F4D7;',
                'pptx': '&#x1F4D9;', 'ppt': '&#x1F4D9;',
                'png': '&#x1F5BC;', 'jpg': '&#x1F5BC;', 'jpeg': '&#x1F5BC;', 'gif': '&#x1F5BC;',
                'mp3': '&#x1F3B5;', 'wav': '&#x1F3B5;', 'm4a': '&#x1F3B5;',
                'mp4': '&#x1F3AC;', 'mov': '&#x1F3AC;', 'mkv': '&#x1F3AC;',
                'py': '&#x1F40D;',
                'json': '&#x2699;',
                'csv': '&#x1F4CA;',
                'eml': '&#x1F4E7;',
                'ics': '&#x1F4C5;',
                'txt': '&#x1F4DD;',
                'md': '&#x1F4DD;'
            };
            return icons[normalizedExt] || '&#x1F4C4;';
        }

        // Load metadata
        async function loadMetadata(path) {
            try {
                const actualPath = resolveActualPath(path);
                const resp = await apiFetch(`/api/return_metadata/${encodePath(actualPath)}`);
                const data = await resp.json();

                if (data.success && data.metadata) {
                    window.currentMetadata = data.metadata;
                }
            } catch (e) {
                console.error('Failed to load metadata:', e);
            }
        }

        // Show metadata in preview content
        function showMetadata() {
            const content = document.getElementById('previewContent');
            const meta = window.currentMetadata || {};
            const entries = Object.entries(meta);

            content.innerHTML = `
                <h3 style="color: var(--accent-cyan); margin-bottom: 16px;">&#x2139; Metadata</h3>
                ${entries.length ? renderMetadataCards(meta, selectedFile || '') : `
                    <p style="color: var(--text-muted);">No metadata available.</p>
                `}
            `;
        }

        // Call API
        async function callAPI(api) {
            if (!selectedFile) {
                showToast('Please select a file first', 'error');
                return;
            }
            const virtualPath = normalizeVirtualPath(selectedFile);
            const apiPath = resolveActualPath(virtualPath);
            if (flagsInitialized && api === 'return_txt' && !enableReturnTxt) {
                showToast('return_txt is disabled by feature flags', 'error');
                return;
            }
            if (flagsInitialized && api === 'return_img' && !enableReturnImg) {
                showToast('return_img is disabled by feature flags', 'error');
                return;
            }

            if (!fileViewerVisible) {
                setFileViewerVisible(true);
            }
            const panel = document.getElementById('fileViewerPanel');
            if (!panel) return;

            panel.innerHTML = `
                ${renderPreviewHeader(virtualPath.split('/').pop(), api, 'webui', 'viewer')}
                <div class="preview-body">
                    <div class="preview-content" id="previewContent">
                        <div class="loading">
                            <div class="loading-spinner"></div>
                            <span>Calling ${api}...</span>
                        </div>
                    </div>
                </div>
            `;
            setPreviewWindowLifecycle(api, 'webui', virtualPath);
            runOperationCursorAnimation(api, virtualPath, 'webui');

            try {
                const url = api === 'return_txt'
                    ? `/api/${api}/${encodePath(apiPath)}?preview=1&max_chars=50000`
                    : api === 'return_ori'
                        ? `/api/${api}/${encodePath(apiPath)}?preview=1&max_chars=50000`
                        : `/api/${api}/${encodePath(apiPath)}`;
                const resp = await apiFetch(url, {
                    headers: { 'X-Skip-Log': '0' }
                });
                const data = await resp.json();
                updatePreviewFromOperation({
                    ...data,
                    operation: api,
                    file_path: virtualPath,
                    source: 'webui',
                    success: !!data.success
                });
                if (!data.success) {
                    showToast(data.error || `${api} failed`, 'error');
                }
            } catch (e) {
                updatePreviewFromOperation({
                    operation: api,
                    file_path: virtualPath,
                    source: 'webui',
                    success: false,
                    error: `API call failed: ${e.message}`
                });
                showToast('API call failed', 'error');
            }
        }

        // Show API help
        function showAPIHelp(api) {
            logUIAction(`ui:open_help ${api}`);
            if (!fileViewerVisible) {
                setFileViewerVisible(true);
            }
            previewWindowState = {
                isOpen: true,
                source: 'webui',
                operation: `help:${api}`,
                filePath: selectedFile || '',
                windowKind: 'viewer',
                autoCloseAfterCommand: null
            };
            const helps = {
                'return_txt': `
                    <h3 style="color: var(--accent-cyan); margin-bottom: 12px;">return_txt</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">Returns the gold text (JSON) for a file containing structured information extracted from the file.</p>
                    <div style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; font-family: 'JetBrains Mono', monospace; font-size: 13px;">
                        <div style="color: var(--text-muted); margin-bottom: 8px;">Usage:</div>
                        <div style="color: var(--accent-yellow);">return_txt &lt;file_path&gt;</div>
                        <div style="color: var(--text-muted); margin: 12px 0 8px;">Example:</div>
                        <div style="color: var(--accent-green);">return_txt Documents/report.docx</div>
                    </div>
                `,
                'return_img': `
                    <h3 style="color: var(--accent-pink); margin-bottom: 12px;">return_img</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">Convert a file to image and return the path. Note: Cannot convert audio/video files (mp3, mp4, etc.)</p>
                    <div style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; font-family: 'JetBrains Mono', monospace; font-size: 13px;">
                        <div style="color: var(--text-muted); margin-bottom: 8px;">Usage:</div>
                        <div style="color: var(--accent-yellow);">return_img &lt;file_path&gt; [output_path]</div>
                        <div style="color: var(--text-muted); margin: 12px 0 8px;">Example:</div>
                        <div style="color: var(--accent-green);">return_img Pictures/photo.png</div>
                    </div>
                `,
                'return_ori': `
                    <h3 style="color: var(--accent-yellow); margin-bottom: 12px;">return_ori</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">Return the original file path, or copy to output location.</p>
                    <div style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; font-family: 'JetBrains Mono', monospace; font-size: 13px;">
                        <div style="color: var(--text-muted); margin-bottom: 8px;">Usage:</div>
                        <div style="color: var(--accent-yellow);">return_ori &lt;file_path&gt; [output_path]</div>
                        <div style="color: var(--text-muted); margin: 12px 0 8px;">Examples:</div>
                        <div style="color: var(--accent-green);">return_ori Downloads/data.csv</div>
                        <div style="color: var(--accent-green);">return_ori Downloads/data.csv /tmp/copy.csv</div>
                    </div>
                `
                ,
                'return_metadata': `
                    <h3 style="color: var(--accent-cyan); margin-bottom: 12px;">return_metadata</h3>
                    <p style="margin-bottom: 16px; color: var(--text-secondary);">Return metadata for a file, including type, modality, dates, and location.</p>
                    <div style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; font-family: 'JetBrains Mono', monospace; font-size: 13px;">
                        <div style="color: var(--text-muted); margin-bottom: 8px;">Usage:</div>
                        <div style="color: var(--accent-yellow);">return_metadata &lt;file_path&gt;</div>
                        <div style="color: var(--text-muted); margin: 12px 0 8px;">Example:</div>
                        <div style="color: var(--accent-green);">return_metadata Documents/notes.txt</div>
                    </div>
                `
            };

            const panel = document.getElementById('fileViewerPanel');
            panel.innerHTML = `
                ${renderPreviewHeader(api, 'help', 'webui', 'viewer')}
                <div class="preview-body">
                    <div class="preview-content" id="previewContent">
                        ${helps[api] || ''}
                    </div>
                </div>
            `;
        }

        // Terminal functions
        function addTerminalEntry(entry) {
            if (!entry || !entry.command) return;
            const entryKey = buildEntryKey(entry);
            if (seenCommandKeys.has(entryKey)) {
                return;
            }
            seenCommandKeys.add(entryKey);
            commandSequence += 1;
            maybeAutoClosePreviewWindow();

            const isHistoricalEntry = !!(entry.ts_ms && entry.ts_ms < uiBootTsMs);
            if (!isHistoricalEntry && entry.source === 'agent' && terminalVisible) {
                applyAgentTerminalLayout(false);
            }

            const output = document.getElementById('terminalOutput');
            const line = document.createElement('div');
            line.className = `terminal-line ${entry.source === 'terminal' ? 'from-terminal' : ''}`;
            const timeText = formatEntryTime(entry);

            let resultHtml = '';
            if (entry.result) {
                const isError = entry.is_error || !entry.result.success;

                if (entry.result.type === 'bash' && entry.result.output) {
                    const outputText = entry.result.output.length > 2000
                        ? entry.result.output.substring(0, 2000) + '\n... (truncated)'
                        : entry.result.output;
                    resultHtml = `<pre class="bash-output ${isError ? 'error' : ''}">${escapeHtml(outputText)}</pre>`;

                    if (entry.source === 'webui') {
                        const content = document.getElementById('previewContent');
                        if (content) {
                            content.innerHTML = `
                                <h3 style="color: var(--accent-cyan); margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                                    <span style="color: var(--accent-green);">$</span> ${escapeHtml(entry.command)}
                                </h3>
                                <pre style="background: rgba(0,0,0,0.4); padding: 16px; border-radius: 10px; overflow: auto; max-height: 60vh; font-family: 'JetBrains Mono', monospace; font-size: 13px; white-space: pre-wrap;">${escapeHtml(entry.result.output)}</pre>
                            `;
                        }
                    }
                } else {
                    const fallbackError = (entry.result.exit_code !== undefined && entry.result.exit_code !== null)
                        ? `Exit code ${entry.result.exit_code}`
                        : 'Error';
                    const resultText = isError ? (entry.result.error || fallbackError) : 'Success';
                    resultHtml = `<div class="result ${isError ? 'error' : ''}">${isError ? '&#x2717;' : '&#x2713;'} ${resultText}</div>`;
                }
            }

            line.innerHTML = `
                <div class="terminal-line-header">
                    <span class="time">${timeText}</span>
                    <span class="source ${entry.source}">${entry.source}</span>
                </div>
                <span class="command">hippocamp_user@hippocamp:~$ ${escapeHtml(entry.command)}</span>
                ${resultHtml}
            `;

            output.appendChild(line);
            output.scrollTop = output.scrollHeight;

            if (!isHistoricalEntry) {
                // Handle shell commands for file tree
                if (entry.result && (entry.result.type === 'bash' || !entry.result.error)) {
                    handleShellCommand(entry.command, entry.result);
                }

                // Handle HippoCamp API commands from terminal - update preview panel
                if (entry.source === 'terminal' || entry.source === 'agent' || entry.source === 'webui') {
                    handleTerminalAPICommand(entry.command, entry.source || 'terminal');
                }

                if (entry.command && entry.command.trim().startsWith('list_files')) {
                    handleListFilesCommand(entry);
                }
            }
        }

        function formatEntryTime(entry) {
            if (entry.ts_ms) {
                const d = new Date(entry.ts_ms);
                if (!isNaN(d.getTime())) return d.toLocaleTimeString();
            }
            if (entry.timestamp) {
                const d = new Date(entry.timestamp);
                if (!isNaN(d.getTime())) return d.toLocaleTimeString();
                return entry.timestamp;
            }
            return '';
        }

        function openFullReturnTxt(filePath) {
            const normalizedPath = filePath && /%[0-9A-Fa-f]{2}/.test(filePath) ? filePath : encodePath(filePath);
            const url = `/api/return_txt_full/${normalizedPath}`;
            window.open(url, '_blank');
        }

        function openFullReturnOri(filePath) {
            const normalizedPath = filePath && /%[0-9A-Fa-f]{2}/.test(filePath) ? filePath : encodePath(filePath);
            const url = `/api/return_ori_full/${normalizedPath}`;
            window.open(url, '_blank');
        }

        function openOriginalFile(encodedPath) {
            if (!encodedPath) return;
            window.open(`/api/serve_file/${encodedPath}`, '_blank');
        }

        function normalizeDatasetPath(path) {
            return normalizeVirtualPath(String(path || '').replace(/^['"]|['"]$/g, ''));
        }

        function getDirectoryStateByPath(files, path) {
            const cleanPath = normalizeDatasetPath(path);
            if (!cleanPath) {
                return { exists: true, children: files || [] };
            }
            const parts = cleanPath.split('/').filter(Boolean);
            let current = files || [];
            for (const part of parts) {
                const next = current.find(item => item.type === 'directory' && item.name === part);
                if (!next) return { exists: false, children: [] };
                current = next.children || [];
            }
            return { exists: true, children: current };
        }

        function getSubtreeByPath(files, path) {
            return getDirectoryStateByPath(files, path).children;
        }

        function handleListFilesCommand(entry) {
            if (!entry || !entry.command) return;
            const raw = entry.command.trim();
            if (!raw.startsWith('list_files')) return;
            const sourceTag = entry.source || 'agent';
            const path = normalizeDatasetPath(raw.split(/\s+/).slice(1).join(' '));
            if (sourceTag === 'agent' && wasOperationHandledRecently('list_files', path, sourceTag, 1200)) {
                return;
            }
            markOperationHandled('list_files', path, sourceTag);
            if (entry.result && (entry.result.success === false || entry.is_error)) {
                const errorMsg = entry.result.error || (path ? `: ${path}` : '');
                showToast(errorMsg, 'error');
                updatePreviewFromOperation({
                    operation: 'list_files',
                    file_path: path,
                    source: sourceTag,
                    success: false,
                    error: errorMsg
                });
                return;
            }

            if (isGlobPattern(path)) {
                apiFetch(`/api/files/list?pattern=${encodeURIComponent(path)}`).then(resp => resp.json()).then(data => {
                    if (data.success) {
                        updatePreviewFromOperation({
                            operation: 'list_files',
                            file_path: path,
                            flat_files: data.files || [],
                            source: sourceTag,
                            success: true
                        });
                    } else {
                        const errorMsg = data.error || `: ${path}`;
                        showToast(errorMsg, 'error');
                        updatePreviewFromOperation({
                            operation: 'list_files',
                            file_path: path,
                            source: sourceTag,
                            success: false,
                            error: errorMsg
                        });
                    }
                }).catch(() => {});
                return;
            }

            const update = () => {
                const dirState = getDirectoryStateByPath(fileData, path);
                const isFileResult = !!(entry.result && (
                    entry.result.path_type === 'file' ||
                    (Array.isArray(entry.result.files) && entry.result.files.length === 1 && normalizeDatasetPath(entry.result.files[0]) === path)
                ));
                if (path && !dirState.exists && !isFileResult) {
                    const errorMsg = `: ${path}`;
                    showToast(errorMsg, 'error');
                    updatePreviewFromOperation({
                        operation: 'list_files',
                        file_path: path,
                        source: sourceTag,
                        success: false,
                        error: errorMsg
                    });
                    return;
                }
                if (isFileResult) {
                    openSidebarFolder(getParentPath(path), false);
                    updatePreviewFromOperation({
                        operation: 'list_files',
                        file_path: path,
                        flat_files: [path],
                        source: sourceTag,
                        success: true
                    });
                    return;
                }
                if (path) {
                    openSidebarFolder(path);
                } else {
                    openSidebarFolder('');
                }
                updatePreviewFromOperation({
                    operation: 'list_files',
                    file_path: path,
                    files: dirState.children,
                    source: sourceTag,
                    success: true
                });
            };

            if (!fileData || !fileData.length) {
                loadFiles().then(update);
            } else {
                update();
            }
        }

        // Handle HippoCamp API commands from terminal/agent/webui command input.
        async function handleTerminalAPICommand(command, source = 'terminal') {
            const raw = (command || '').trim();
            const cmdMatch = raw.match(/^(\S+)(?:\s+([\s\S]+))?$/);
            if (!cmdMatch) return;

            const cmd = cmdMatch[1];
            const rest = (cmdMatch[2] || '').trim();
            const apiCommands = ['return_txt', 'return_img', 'return_ori', 'return_metadata', 'txt', 'img', 'ori'];
            if (!apiCommands.includes(cmd)) return;

            let filePath = '';
            if (rest.startsWith('"') || rest.startsWith("'")) {
                const quote = rest[0];
                const end = rest.indexOf(quote, 1);
                if (end > 0) {
                    filePath = rest.slice(1, end);
                }
            } else if (rest) {
                filePath = rest.split(/\s+/)[0];
            }
            if (!filePath) return;

            const cmdMap = { txt: 'return_txt', img: 'return_img', ori: 'return_ori' };
            const apiCmd = cmdMap[cmd] || cmd;
            const cleanPath = filePath
                .replace(/\/$/, '')
                .replace(/^\/hippocamp\/data\/?/, '')
                .replace(/^data\/?/, '');
            if (!cleanPath) return;
            if (source === 'agent' && wasOperationHandledRecently(apiCmd, cleanPath, source, 1200)) {
                return;
            }
            markOperationHandled(apiCmd, cleanPath, source || 'terminal');

            setSelectedItem(cleanPath, 'file');
            selectFileByPath(cleanPath);
            runOperationCursorAnimation(apiCmd, cleanPath, source || 'terminal');
            document.getElementById('currentPath').innerHTML = `<span class="path">${escapeHtml(cleanPath)}</span>`;

            if (!fileViewerVisible) {
                setFileViewerVisible(true);
            }
            const panel = document.getElementById('fileViewerPanel');
            if (panel) {
                panel.innerHTML = `
                    ${renderPreviewHeader(cleanPath.split('/').pop(), apiCmd, source, 'viewer')}
                    <div class="preview-body">
                        <div class="preview-content" id="previewContent">
                            <div class="loading">
                                <div class="loading-spinner"></div>
                                <span>Loading ${apiCmd}...</span>
                            </div>
                        </div>
                    </div>
                `;
            }

            try {
                const url = apiCmd === 'return_txt'
                    ? `/api/${apiCmd}/${encodePath(cleanPath)}?preview=1&max_chars=50000`
                    : apiCmd === 'return_ori'
                        ? `/api/${apiCmd}/${encodePath(cleanPath)}?preview=1&max_chars=50000`
                        : `/api/${apiCmd}/${encodePath(cleanPath)}`;
                const resp = await apiFetch(url, {
                    headers: {
                        'X-Source': source || 'terminal',
                        'X-Skip-Log': '1'
                    }
                });
                const data = await resp.json();
                updatePreviewFromOperation({
                    ...data,
                    operation: apiCmd,
                    file_path: cleanPath,
                    source: source || 'terminal',
                    success: !!data.success
                });
                if (!data.success) {
                    showToast(data.error || `${apiCmd} failed`, 'error');
                }
            } catch (e) {
                updatePreviewFromOperation({
                    operation: apiCmd,
                    file_path: cleanPath,
                    source: source || 'terminal',
                    success: false,
                    error: `Failed to fetch: ${e.message}`
                });
            }
        }

        // Select file in tree by path (smart search)
        function selectFileByPath(filePath) {
            if (!filePath) return;

            // First try exact match
            let fileEl = document.querySelector(`.tree-item.file[data-path="${filePath}"]`);

            // If not found, search by filename
            if (!fileEl) {
                const fileName = filePath.split('/').pop();
                const allFiles = document.querySelectorAll('.tree-item.file');
                for (const el of allFiles) {
                    const elPath = el.dataset.path || '';
                    if (elPath === fileName || elPath.endsWith('/' + fileName)) {
                        fileEl = el;
                        filePath = elPath;
                        break;
                    }
                }
            }

            if (fileEl) {
                // Expand parent folders
                const pathParts = filePath.split('/');
                pathParts.pop(); // Remove filename
                let buildPath = '';
                pathParts.forEach(p => {
                    buildPath = buildPath ? buildPath + '/' + p : p;
                    const parentDir = document.querySelector(`.tree-item.directory[data-path="${buildPath}"]`);
                    if (parentDir) {
                        parentDir.classList.add('open');
                        const children = parentDir.nextElementSibling;
                        if (children && children.classList.contains('tree-children')) {
                            children.classList.add('expanded');
                        }
                    }
                });

                // Select the file
                document.querySelectorAll('.tree-item.selected').forEach(el => el.classList.remove('selected'));
                fileEl.classList.add('selected');
                fileEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                setSelectedItem(filePath, 'file');
                const parentPath = getParentPath(filePath);
                if (parentPath !== sidebarCurrentPath) {
                    sidebarCurrentPath = parentPath;
                    renderSidebarDesktopBrowser(document.getElementById('sidebarQuickSearch')?.value || '');
                }
            }
        }

        function executeCommand() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();

            if (!command) return;

            if (!socket || !socket.connected) {
                showToast('Terminal link is not connected yet. Try again in a moment.', 'error');
                return;
            }
            socket.emit('execute_command', { command });
            input.value = '';
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter') {
                executeCommand();
            }
        }

        // Utilities
        function apiFetch(url, options = {}) {
            const headers = Object.assign(
                { 'X-Skip-Log': '1', 'X-Source': 'webui' },
                options.headers || {}
            );
            return fetch(url, Object.assign({}, options, { headers }));
        }

        function encodePath(path) {
            if (!path) return '';
            return path.split('/').map(part => part ? encodeURIComponent(part) : '').join('/');
        }

        function escapeHtml(str) {
            if (!str) return '';
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        // Count files recursively
        function countFilesRecursive(items) {
            let count = 0;
            for (const item of items) {
                if (item.type === 'file') {
                    count++;
                } else if (item.children) {
                    count += countFilesRecursive(item.children);
                }
            }
            return count;
        }

        function openGridItem(encodedPath, itemType) {
            const path = decodeURIComponent(encodedPath || '');
            if (!path) return;

            if (itemType === 'directory') {
                expandFolderByPath(path);
                const subtree = getSubtreeByPath(fileData, path);
                updatePreviewFromOperation({
                    operation: 'list_files',
                    file_path: path,
                    files: subtree,
                    source: 'webui',
                    success: true
                });
            } else {
                selectFileByPath(path);
            }
        }

        function renderFolderGridHTML(items) {
            if (!items || !items.length) return '';
            const cards = items.map((item) => {
                const isDir = item.type === 'directory';
                const path = item.path || item.name || '';
                const encodedPath = encodeURIComponent(path);
                const ext = (item.ext || '').replace('.', '').toLowerCase();
                const icon = isDir ? '&#x1F4C1;' : getFileIcon(ext);
                return `
                    <div class="folder-grid-item" onclick="openGridItem('${encodedPath}', '${isDir ? 'directory' : 'file'}')">
                        <span class="icon">${icon}</span>
                        <span class="name">${escapeHtml(item.name || path || 'Unknown')}</span>
                    </div>
                `;
            }).join('');
            return `<div class="folder-grid">${cards}</div>`;
        }

        function renderFlatFolderGridHTML(paths) {
            if (!paths || !paths.length) return '';
            const cards = paths.map((p) => {
                const name = (p || '').split('/').pop() || p;
                const ext = name.includes('.') ? name.split('.').pop().toLowerCase() : '';
                const icon = getFileIcon(ext);
                return `
                    <div class="folder-grid-item" onclick="openGridItem('${encodeURIComponent(p)}', 'file')">
                        <span class="icon">${icon}</span>
                        <span class="name">${escapeHtml(name)}</span>
                    </div>
                `;
            }).join('');
            return `<div class="folder-grid">${cards}</div>`;
        }

        function formatJSON(obj) {
            if (typeof obj === 'string') {
                try {
                    obj = JSON.parse(obj);
                } catch (e) {
                    return escapeHtml(obj);
                }
            }

            return JSON.stringify(obj, null, 2)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"([^"]+)":/g, '<span class="json-key">"$1"</span>:')
                .replace(/: "([^"]*)"/g, ': <span class="json-string">"$1"</span>')
                .replace(/: (\d+)/g, ': <span class="json-number">$1</span>')
                .replace(/: (true|false)/g, ': <span class="json-boolean">$1</span>');
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show ${type}`;

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function isGlobPattern(value) {
            if (!value) return false;
            return /[*?\[]/.test(value);
        }
    </script>
</body>
</html>
